###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               16/Feb/2018  21:39:33
# Copyright 2004-2017 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 10.10
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\Source\znp_spi.c
#    Command line       =  
#        -f C:\Users\Oskar\AppData\Local\Temp\EW8B74.tmp ("C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\Source\znp_spi.c" -D
#        FEATURE_SYSTEM_STATS -D POWER_SAVING -D xTC_LINKKEY_JOIN -lC "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" -lA
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC -DMT_SAPI_FUNC
#        -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC -DMT_ZDO_MGMT
#        -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f "C:\Texas Instruments\Z-Stack
#        Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary163\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary283\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  German_Germany.1252
#    List file          =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\List\znp_spi.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj\znp_spi.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Projects\zstack\ZNP\CC253x\Source\znp_spi.c
      1          /**************************************************************************************************
      2            Filename:       znp_spi.c
      3            Revised:        $Date: 2010-07-28 18:42:54 -0700 (Wed, 28 Jul 2010) $
      4            Revision:       $Revision: 23203 $
      5          
      6            Description:
      7          
      8            This file contains the interface to the H/W-specific ZNP SPI driver.
      9          
     10          
     11            Copyright 2009-2010 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License").  You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product.  Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com. 
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "comdef.h"
     48          #include "hal_assert.h"
     49          #include "hal_dma.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd7
   \   unsigned char volatile __sfr DMAREQ
   \                     DMAREQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf8
   \   union <unnamed> volatile __sfr _A_U1CSR
   \                     _A_U1CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfc
   \   unsigned char volatile __sfr U1GCR
   \                     U1GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     50          #include "MT_RPC.h"
     51          #include "OnBoard.h"
     52          #include "osal.h"
     53          #if defined POWER_SAVING
     54          #include "OSAL_PwrMgr.h"
     55          #endif        
     56          #include "ZDApp.h"
     57          #include "znp_app.h"
     58          #include "znp_spi.h"
     59          
     60          /* ------------------------------------------------------------------------------------------------
     61           *                                           Macros
     62           * ------------------------------------------------------------------------------------------------
     63           */
     64          
     65          /*
     66           *  The MAC_ASSERT macro is for use during debugging.
     67           *  The given expression must evaluate as "true" or else fatal error occurs.
     68           *  At that point, the call stack feature of the debugger can pinpoint where the problem occurred.
     69           *
     70           *  To disable this feature and save code size, the project should define NP_SPI_NODEBUG to TRUE.
     71           */
     72          
     73          #if !defined ( NP_SPI_NODEBUG )
     74            #define NP_SPI_NODEBUG              TRUE
     75          #endif
     76          
     77          #if ( NP_SPI_NODEBUG )
     78            #define NP_SPI_ASSERT( expr )
     79          #else
     80            #define NP_SPI_ASSERT( expr)        HAL_ASSERT( expr )
     81          #endif
     82          
     83          #if defined CC2530_MK
     84          #define DMATRIG_RX  HAL_DMA_TRIG_URX0
     85          #define DMATRIG_TX  HAL_DMA_TRIG_UTX0
     86          #define DMA_UDBUF   NP_SPI_U0DBUF
     87          #else
     88          #define DMATRIG_RX  HAL_DMA_TRIG_URX1
     89          #define DMATRIG_TX  HAL_DMA_TRIG_UTX1
     90          #define DMA_UDBUF   NP_SPI_U1DBUF
     91          #endif
     92          
     93          #define DMA_RX() \
     94            st( \
     95              volatile uint8 clearRx = *((uint8 *)DMA_UDBUF); \
     96              \
     97              HAL_DMA_CLEAR_IRQ(HAL_DMA_CH_RX); \
     98              \
     99              HAL_DMA_ARM_CH(HAL_DMA_CH_RX); \
    100            )
    101          
    102          #define DMA_TX( buf ) \
    103            st( \
    104              halDMADesc_t *ch = HAL_DMA_GET_DESC1234(HAL_DMA_CH_TX); \
    105              \
    106              HAL_DMA_SET_SOURCE(ch, (buf)); \
    107              \
    108              HAL_DMA_CLEAR_IRQ(HAL_DMA_CH_TX); \
    109              \
    110              HAL_DMA_ARM_CH(HAL_DMA_CH_TX); \
    111              \
    112              HAL_DMA_START_CH(HAL_DMA_CH_TX); \
    113            )
    114          
    115          #define HAL_DMA_GET_SOURCE( pDesc, src ) \
    116            st( \
    117              src = (uint16)(pDesc->srcAddrH) << 8; \
    118              src += pDesc->srcAddrL; \
    119            )
    120          
    121          /* ------------------------------------------------------------------------------------------------
    122           *                                           Constants
    123           * ------------------------------------------------------------------------------------------------
    124           */
    125          
    126          #define NP_SPI_U0DBUF  0x70C1
    127          #define NP_SPI_U1DBUF  0x70F9
    128          
    129          /* UxCSR - USART Control and Status Register. */
    130          #define CSR_MODE       0x80
    131          #define CSR_RE         0x40
    132          #define CSR_SLAVE      0x20
    133          #define CSR_FE         0x10
    134          #define CSR_ERR        0x08
    135          #define CSR_RX_BYTE    0x04
    136          #define CSR_TX_BYTE    0x02
    137          #define CSR_ACTIVE     0x01
    138          
    139          /* UxUCR - USART UART Control Register. */
    140          #define UCR_FLUSH      0x80
    141          #define UCR_FLOW       0x40
    142          #define UCR_D9         0x20
    143          #define UCR_BIT9       0x10
    144          #define UCR_PARITY     0x08
    145          #define UCR_SPB        0x04
    146          #define UCR_STOP       0x02
    147          #define UCR_START      0x01
    148          
    149          #define UTX0IE         0x04
    150          #define UTX1IE         0x08
    151          
    152          #define NP_SPI_RX_SREQ_EVENT  ZNP_SPI_RX_SREQ_EVENT
    153          #define NP_SPI_RX_AREQ_EVENT  ZNP_SPI_RX_AREQ_EVENT
    154          
    155          /* Reference data sheet section 8.2.4: When using variable-length transfers, then LEN
    156           * should be set to the largest allowed transfer length plus one.
    157           */
    158          #define NP_SPI_BUF_LEN  (MT_RPC_DATA_MAX + MT_RPC_FRAME_HDR_SZ + 1)
    159          
    160          #if defined CC2530_MK
    161          #define NP_RDYIn_BIT     BV(0)
    162          #define NP_RDYIn         P2_0
    163          #define NP_RDYOut        P1_0
    164          #define NP_RDYOut_BIT    BV(0)
    165          
    166          #elif !defined CC2530ZNP_MK
    167          
    168          #define NP_RDYIn_BIT     BV(3)
    169          #define NP_RDYIn         P0_3
    170          #define NP_RDYOut        P0_4
    171          #define NP_RDYOut_BIT    BV(4)
    172          #endif
    173          
    174          #define NP_CSR_MODE      BV(5)  //  CSR_SLAVE
    175          
    176          /* ------------------------------------------------------------------------------------------------
    177           *                                           TypeDefs
    178           * ------------------------------------------------------------------------------------------------
    179           */
    180          
    181          typedef enum
    182          {
    183            NP_SPI_IDLE,           /* Idle, no transaction in progress. */
    184            NP_SPI_MRDY,           /* Idle, but got MRDY ISR, so waiting to enable the RX DMA. */
    185            NP_SPI_WAIT_RX,        /* Waiting for RX to complete. */
    186            NP_SPI_WAIT_TX,        /* Waiting for TX to complete. */
    187            NP_SPI_WAIT_AREQ,      /* Waiting for asynchronous request to finish processing. */
    188            NP_SPI_WAIT_SREQ       /* Waiting for a synchronous request to finish processing. */
    189          } spiState_t;
    190          
    191          /* ------------------------------------------------------------------------------------------------
    192           *                                           Local Variables
    193           * ------------------------------------------------------------------------------------------------
    194           */
    195          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    196          static uint8 npSpiBuf[NP_SPI_BUF_LEN];
   \                     npSpiBuf:
   \   000000                DS 254
   \   0000FE                REQUIRE __INIT_XDATA_Z
    197          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    198          static volatile spiState_t npSpiState;
   \                     npSpiState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    199          
    200          /* ------------------------------------------------------------------------------------------------
    201           *                                           Local Functions
    202           * ------------------------------------------------------------------------------------------------
    203           */
    204          
    205          static void dmaInit(void);
    206          
    207          /**************************************************************************************************
    208           * @fn          dmaInit
    209           *
    210           * @brief       This function initializes the DMA for the SPI driver.
    211           *
    212           * input parameters
    213           *
    214           * None.
    215           *
    216           * output parameters
    217           *
    218           * None.
    219           *
    220           * @return      None.
    221           **************************************************************************************************
    222           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    223          static void dmaInit(void)
   \                     dmaInit:
    224          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    225            halDMADesc_t *ch;
    226          
    227            /* Setup Tx by DMA. */
    228            ch = HAL_DMA_GET_DESC1234(HAL_DMA_CH_TX);
    229          
    230            /* The start address of the source and destination. */
    231            HAL_DMA_SET_SOURCE(ch, npSpiBuf);
   \   000004   78..         MOV       R0,#npSpiBuf & 0xff
   \   000006   74..         MOV       A,#(npSpiBuf >> 8) & 0xff
   \   000008   FA           MOV       R2,A
   \   000009   90....       MOV       DPTR,#dmaCh1234 + 24
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   E8           MOV       A,R0
   \   00000E   A3           INC       DPTR
   \   00000F   F0           MOVX      @DPTR,A
    232            HAL_DMA_SET_DEST(ch, DMA_UDBUF);
   \   000010   A3           INC       DPTR
   \   000011   7470         MOV       A,#0x70
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   74F9         MOV       A,#-0x7
   \   000017   12....       LCALL     ?Subroutine3 & 0xFFFF
    233          
    234            /* Transfer the first byte + the number of bytes indicated by the first byte + 2 more bytes. */
    235            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_1_P_VALOFFIRST_P_2);
    236            HAL_DMA_SET_LEN(ch, NP_SPI_BUF_LEN);
   \                     ??CrossCallReturnLabel_5:
   \   00001A   90....       MOV       DPTR,#dmaCh1234 + 28
   \   00001D   7480         MOV       A,#-0x80
   \   00001F   F0           MOVX      @DPTR,A
    237          
    238            /* One byte is transferred each time. */
    239            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    240          
    241            /* The bytes are transferred 1-by-1 on Tx Complete trigger. */
    242            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    243            HAL_DMA_SET_TRIG_SRC(ch, DMATRIG_TX);
   \   000020   90....       MOV       DPTR,#dmaCh1234 + 30
   \   000023   7411         MOV       A,#0x11
   \   000025   F0           MOVX      @DPTR,A
    244          
    245            /* The source address is decremented by 1 byte after each transfer. */
    246            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    247          
    248            /* The destination address is constant - the Tx Data Buffer. */
    249            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    250          
    251            /* The DMA shall issue an IRQ upon completion. */
    252            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_ENABLE);
    253          
    254            /* Xfer all 8 bits of a byte xfer. */
    255            HAL_DMA_SET_M8(ch, HAL_DMA_M8_USE_8_BITS);
    256          
    257            /* DMA has highest priority for memory access. */
    258            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   000026   A3           INC       DPTR
   \   000027   744A         MOV       A,#0x4a
   \   000029   F0           MOVX      @DPTR,A
    259          
    260            /* Setup Rx by DMA. */
    261            ch = HAL_DMA_GET_DESC1234(HAL_DMA_CH_RX);
    262          
    263            /* The start address of the source and destination. */
    264            HAL_DMA_SET_SOURCE(ch, DMA_UDBUF);
   \   00002A   90....       MOV       DPTR,#dmaCh1234 + 16
   \   00002D   7470         MOV       A,#0x70
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   74F9         MOV       A,#-0x7
   \   000033   F0           MOVX      @DPTR,A
    265            HAL_DMA_SET_DEST(ch, npSpiBuf);
   \   000034   EA           MOV       A,R2
   \   000035   A3           INC       DPTR
   \   000036   F0           MOVX      @DPTR,A
   \   000037   E8           MOV       A,R0
   \   000038   A3           INC       DPTR
   \   000039   12....       LCALL     ?Subroutine3 & 0xFFFF
    266          
    267            /* Transfer the first byte + the number of bytes indicated by the first byte + 2 more bytes. */
    268            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_1_P_VALOFFIRST_P_2);
    269            HAL_DMA_SET_LEN(ch, NP_SPI_BUF_LEN);
   \                     ??CrossCallReturnLabel_6:
   \   00003C   90....       MOV       DPTR,#dmaCh1234 + 20
   \   00003F   7480         MOV       A,#-0x80
   \   000041   F0           MOVX      @DPTR,A
    270          
    271            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    272          
    273            /* The bytes are transferred 1-by-1 on Rx Complete trigger. */
    274            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    275            HAL_DMA_SET_TRIG_SRC(ch, DMATRIG_RX);
   \   000042   90....       MOV       DPTR,#dmaCh1234 + 22
   \   000045   7410         MOV       A,#0x10
   \   000047   F0           MOVX      @DPTR,A
    276          
    277            /* The source address is constant - the Rx Data Buffer. */
    278            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_0);
    279          
    280            /* The destination address is incremented by 1 byte after each transfer. */
    281            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_1);
    282          
    283            /* The DMA shall issue an IRQ upon completion. */
    284            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_ENABLE);
    285          
    286            /* Xfer all 8 bits of a byte xfer. */
    287            HAL_DMA_SET_M8(ch, HAL_DMA_M8_USE_8_BITS);
    288          
    289            /* DMA has highest priority for memory access. */
    290            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   000048   A3           INC       DPTR
   \   000049   741A         MOV       A,#0x1a
   \   00004B   F0           MOVX      @DPTR,A
    291          }
   \   00004C   02....       LJMP      ??Subroutine4_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   E0           MOVX      A,@DPTR
   \   000003   541F         ANL       A,#0x1f
   \   000005   4480         ORL       A,#0x80
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    292          
    293          /**************************************************************************************************
    294           * @fn          npSpiInit
    295           *
    296           * @brief       This function is called to set up the SPI interface.
    297           *
    298           * input parameters
    299           *
    300           * None.
    301           *
    302           * output parameters
    303           *
    304           * None.
    305           *
    306           * @return      None.
    307           **************************************************************************************************
    308           */
    309          #if defined CC2530_MK
    310          void npSpiInit(void)  // TODO - hard-coded for USART0 alt1 SPI for now.
    311          {
    312            if (ZNP_CFG1_UART == znpCfg1)
    313            {
    314              return;
    315            }
    316          
    317            /* Set bit order to MSB */
    318            U0GCR |= BV(5);
    319          
    320            /* Set UART0 I/O to alternate 1 location on P1 pins. */
    321            //PERCFG |= 0x02;  /* U1CFG */
    322          
    323            /* Mode select UART1 SPI Mode as slave. */
    324            U0CSR = NP_CSR_MODE;
    325          
    326            /* Select peripheral function on I/O pins. */
    327            P0SEL |= 0x3C;  /* SELP0_[5:2] */
    328          
    329            /* Give UART1 priority over Timer3. */
    330            //P2SEL &= ~0x20;  /* PRI2P1 */
    331          
    332            /* Set RDY to inactive high. */
    333            NP_RDYOut = 1;
    334          
    335            /* Select general purpose on I/O pins. */
    336            P1SEL &= ~(NP_RDYOut_BIT);  /* P1.0 SRDY - GPIO */
    337            P2SEL &= ~(NP_RDYIn_BIT);   /* P2.0 MRDY - GPIO */
    338          
    339            /* Select GPIO direction */
    340            P1DIR |= NP_RDYOut_BIT;  /* P1.0 SRDY - OUT */
    341            P2DIR &= ~NP_RDYIn_BIT;  /* P2.0 MRDY - IN */
    342          
    343            /* Falling edge on P2 pins triggers interrupt. */
    344            PICTL |= BV(3);  /* P2ICON */
    345          
    346            /* Trigger an interrupt on MRDY input. */
    347            P2IFG &= ~NP_RDYIn_BIT;
    348            P2IEN |=  NP_RDYIn_BIT;
    349            IEN2 |= 0x02;
    350          
    351            dmaInit();
    352          
    353            U0CSR |= CSR_RE;
    354          }
    355          #else

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          void npSpiInit(void)
   \                     npSpiInit:
    357          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    358            if (ZNP_CFG1_UART == znpCfg1)
   \   000004   90....       MOV       DPTR,#znpCfg1
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6033         JZ        ??npSpiInit_0
    359            {
    360              return;
    361            }
    362          
    363            /* Set bit order to MSB */
    364            U1GCR |= BV(5);
   \   00000A   43FC20       ORL       0xfc,#0x20
    365          
    366            /* Set UART1 I/O to alternate 2 location on P1 pins. */
    367            PERCFG |= 0x02;  /* U1CFG */
   \   00000D   43F102       ORL       0xf1,#0x2
    368          
    369            /* Mode select UART1 SPI Mode as slave. */
    370            U1CSR = NP_CSR_MODE;
   \   000010   75F820       MOV       0xf8,#0x20
    371          
    372            /* Select peripheral function on I/O pins. */
    373            P1SEL |= 0xF0;  /* SELP1_[7:4] */
   \   000013   43F4F0       ORL       0xf4,#0xf0
    374          
    375            /* Give UART1 priority over Timer3. */
    376            P2SEL &= ~0x20;  /* PRI2P1 */
   \   000016   53F5DF       ANL       0xf5,#0xdf
    377          
    378            /* Set RDY to inactive high. */
    379            NP_RDYOut = 1;
   \   000019   D284         SETB      0x80.4
    380          
    381            /* Select general purpose on I/O pins. */
    382            P0SEL &= ~(NP_RDYIn_BIT);   /* P0.3 MRDY - GPIO */
   \   00001B   53F3F7       ANL       0xf3,#0xf7
    383            P0SEL &= ~(NP_RDYOut_BIT);  /* P0.4 SRDY - GPIO */
   \   00001E   53F3EF       ANL       0xf3,#0xef
    384          
    385            /* Select GPIO direction */
    386            P0DIR &= ~NP_RDYIn_BIT;  /* P0.3 MRDY - IN */
   \   000021   53FDF7       ANL       0xfd,#0xf7
    387            P0DIR |= NP_RDYOut_BIT;  /* P0.4 SRDY - OUT */
   \   000024   43FD10       ORL       0xfd,#0x10
    388          
    389            P0INP &= ~NP_RDYIn_BIT;  /* Pullup/down enable of MRDY input. */
   \   000027   538FF7       ANL       0x8f,#0xf7
    390            P2INP &= ~BV(5);         /* Pullup all P0 inputs. */
   \   00002A   53F7DF       ANL       0xf7,#0xdf
    391          
    392            /* Falling edge on P0 pins triggers interrupt. */
    393            PICTL |= BV(0);  /* P0ICON */
   \   00002D   438C01       ORL       0x8c,#0x1
    394          
    395            /* Trigger an interrupt on MRDY input. */
    396            P0IFG &= ~NP_RDYIn_BIT;
   \   000030   5389F7       ANL       0x89,#0xf7
    397            P0IEN |=  NP_RDYIn_BIT;
   \   000033   43AB08       ORL       0xab,#0x8
    398            P0IE = 1;
   \   000036   D2BD         SETB      0xb8.5
    399          
    400            dmaInit();
   \   000038                ; Setup parameters for call to function dmaInit
   \   000038   12....       LCALL     `??dmaInit::?relay`; Banked call to: dmaInit
    401          
    402            U1CSR |= CSR_RE;
   \   00003B   D2FE         SETB      0xf8.6
    403          }
   \                     ??npSpiInit_0:
   \   00003D   02....       LJMP      ??Subroutine4_0 & 0xFFFF
   \   000040                REQUIRE U1GCR
   \   000040                REQUIRE PERCFG
   \   000040                REQUIRE _A_U1CSR
   \   000040                REQUIRE P1SEL
   \   000040                REQUIRE P2SEL
   \   000040                REQUIRE _A_P0
   \   000040                REQUIRE P0SEL
   \   000040                REQUIRE P0DIR
   \   000040                REQUIRE P0INP
   \   000040                REQUIRE P2INP
   \   000040                REQUIRE PICTL
   \   000040                REQUIRE P0IFG
   \   000040                REQUIRE P0IEN
   \   000040                REQUIRE _A_IEN1
    404          #endif
    405          
    406          /**************************************************************************************************
    407           * @fn          npSpiMonitor
    408           *
    409           * @brief       This function monitors the SPI signals for error conditions and for the end of a
    410           *              transaction. If an error is detected it attempts to recover.
    411           *
    412           * input parameters
    413           *
    414           * None.
    415           *
    416           * output parameters
    417           *
    418           * None.
    419           *
    420           * @return      None.
    421           **************************************************************************************************
    422           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    423          void npSpiMonitor(void)
   \                     npSpiMonitor:
    424          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV       A,#-0x1
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    425            if (ZNP_CFG1_UART == znpCfg1)
   \   000009   90....       MOV       DPTR,#znpCfg1
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   7003         JNZ       $+5
   \   00000F   02....       LJMP      ??npSpiMonitor_0 & 0xFFFF
    426            {
    427              return;
    428            }
    429          
    430          #if ZNP_RUN_WDOG
    431            if ((devState != DEV_HOLD) && (npSpiState == NP_SPI_IDLE))
    432            {
    433              // Enable the watchdog for 1 second period and pet it.
    434              WatchDogEnable( WDTIMX );
    435            }
    436          #endif
    437          
    438            switch (npSpiState)
   \   000012   90....       MOV       DPTR,#npSpiState
   \   000015   E0           MOVX      A,@DPTR
   \   000016   6401         XRL       A,#0x1
   \   000018   7003         JNZ       ??CrossCallReturnLabel_0
    439            {
    440            case NP_SPI_IDLE:
    441              NP_SPI_ASSERT((P1IFG & NP_RDYIn_BIT) == 0);
    442              break;
    443          
    444          #if defined POWER_SAVING
    445            case NP_SPI_MRDY:
    446              npSpiState = NP_SPI_WAIT_RX;
   \   00001A   12....       LCALL     ?Subroutine1 & 0xFFFF
    447              DMA_RX();
    448              NP_RDYOut = 0;
    449              break;
    450          #endif        
    451          
    452            case NP_SPI_WAIT_RX:
    453              NP_SPI_ASSERT((HAL_DMA_CHECK_IRQ(HAL_DMA_CH_RX)) == 0);
    454              break;
    455          
    456            case NP_SPI_WAIT_TX:
    457              NP_SPI_ASSERT((HAL_DMA_CHECK_IRQ(HAL_DMA_CH_TX)) == 0);
    458              break;
    459          
    460            case NP_SPI_WAIT_AREQ:
    461              break;
    462          
    463            default:
    464              NP_SPI_ASSERT(0);
    465              break;
    466            }
    467          
    468            if (npSpiState == NP_SPI_IDLE)
   \                     ??CrossCallReturnLabel_0:
   \   00001D   90....       MOV       DPTR,#npSpiState
   \   000020   E0           MOVX      A,@DPTR
   \   000021   7014         JNZ       ??npSpiMonitor_1
    469            {
    470              *((uint8 *)DMA_UDBUF) = 0;  // Clear the SPI Tx buffer to zero.
   \   000023   9070F9       MOV       DPTR,#0x70f9
   \   000026   E4           CLR       A
   \   000027   F0           MOVX      @DPTR,A
    471          
    472              /* Poll for MRDY in case it was set before slave had setup the ISR.
    473               * Also, async responses may get queued, so flush them out here.
    474               */
    475              if ((NP_RDYIn == 0) || (npSpiReadyCallback()))
   \   000028   A283         MOV       C,0x80.3
   \   00002A   5006         JNC       ??npSpiMonitor_2
   \   00002C                ; Setup parameters for call to function npSpiReadyCallback
   \   00002C   12....       LCALL     `??npSpiReadyCallback::?relay`; Banked call to: npSpiReadyCallback
   \   00002F   E9           MOV       A,R1
   \   000030   6047         JZ        ??npSpiMonitor_3
    476              {
    477                npSpiAReqReady();
   \                     ??npSpiMonitor_2:
   \   000032                ; Setup parameters for call to function npSpiAReqReady
   \   000032   12....       LCALL     `??npSpiAReqReady::?relay`; Banked call to: npSpiAReqReady
   \   000035   8042         SJMP      ??npSpiMonitor_3
    478              }
    479            }
    480            else
    481            {
    482              halIntState_t his;
    483          
    484              HAL_ENTER_CRITICAL_SECTION(his);
   \                     ??npSpiMonitor_1:
   \   000037   A2AF         MOV       C,0xa8.7
   \   000039   E4           CLR       A
   \   00003A   33           RLC       A
   \   00003B   F8           MOV       R0,A
   \   00003C   C2AF         CLR       0xa8.7
    485              if (((npSpiState == NP_SPI_WAIT_RX) &&
    486                  (!HAL_DMA_CH_ARMED(HAL_DMA_CH_RX) && !HAL_DMA_CHECK_IRQ(HAL_DMA_CH_RX)))
    487              ||  ((npSpiState == NP_SPI_WAIT_TX) &&
    488                  (!HAL_DMA_CH_ARMED(HAL_DMA_CH_TX) && !HAL_DMA_CHECK_IRQ(HAL_DMA_CH_TX))))
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   6402         XRL       A,#0x2
   \   000041   700C         JNZ       ??npSpiMonitor_4
   \   000043   E5D6         MOV       A,0xd6
   \   000045   A2E3         MOV       C,0xE0 /* A   */.3
   \   000047   4006         JC        ??npSpiMonitor_4
   \   000049   E5D1         MOV       A,0xd1
   \   00004B   A2E3         MOV       C,0xE0 /* A   */.3
   \   00004D   5011         JNC       ??npSpiMonitor_5
   \                     ??npSpiMonitor_4:
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   6403         XRL       A,#0x3
   \   000052   7020         JNZ       ??npSpiMonitor_6
   \   000054   E5D6         MOV       A,0xd6
   \   000056   A2E4         MOV       C,0xE0 /* A   */.4
   \   000058   401A         JC        ??npSpiMonitor_6
   \   00005A   E5D1         MOV       A,0xd1
   \   00005C   A2E4         MOV       C,0xE0 /* A   */.4
   \   00005E   4014         JC        ??npSpiMonitor_6
    489              {
    490                HAL_EXIT_CRITICAL_SECTION(his);
   \                     ??npSpiMonitor_5:
   \   000060   E8           MOV       A,R0
   \   000061   A2E0         MOV       C,0xE0 /* A   */.0
   \   000063   92AF         MOV       0xa8.7,C
    491          
    492                if (npSpiState == NP_SPI_WAIT_RX)
   \   000065   E0           MOVX      A,@DPTR
   \   000066   6402         XRL       A,#0x2
   \   000068   7005         JNZ       ??npSpiMonitor_7
    493                {
    494                  npSpiRxIsr();
   \   00006A                ; Setup parameters for call to function npSpiRxIsr
   \   00006A   12....       LCALL     `??npSpiRxIsr::?relay`; Banked call to: npSpiRxIsr
   \   00006D   800A         SJMP      ??npSpiMonitor_3
    495                }
    496                else  // if (npSpiState == NP_SPI_WAIT_TX)
    497                {
    498                  npSpiTxIsr();
   \                     ??npSpiMonitor_7:
   \   00006F                ; Setup parameters for call to function npSpiTxIsr
   \   00006F   12....       LCALL     `??npSpiTxIsr::?relay`; Banked call to: npSpiTxIsr
   \   000072   8005         SJMP      ??npSpiMonitor_3
    499                }
    500              }
    501              else
    502              {
    503                HAL_EXIT_CRITICAL_SECTION(his);
   \                     ??npSpiMonitor_6:
   \   000074   E8           MOV       A,R0
   \   000075   A2E0         MOV       C,0xE0 /* A   */.0
   \   000077   92AF         MOV       0xa8.7,C
    504              }
    505            }
    506          
    507          #if defined POWER_SAVING
    508            /* A simple ZAP application sending a unicast at 2-Hz was seen to bog down to < 1-Hz OTA unicast
    509             * when the ZNP was configured to be a ZED (i.e. POWER_SAVING was enabled). So adding this delay
    510             * of only 10 msecs before re-enabling CONSERVE showed that the problem was fixed while still
    511             * allowing the ZNP to enter sleep.
    512             */
    513            static uint8 znpSpiActiveShdw;
    514          
    515            if (ZG_DEVICE_ENDDEVICE_TYPE && (npSpiState == NP_SPI_IDLE))
   \                     ??npSpiMonitor_3:
   \   000079   90....       MOV       DPTR,#zgDeviceLogicalType
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   6402         XRL       A,#0x2
   \   00007F   704B         JNZ       ??npSpiMonitor_8
   \   000081   90....       MOV       DPTR,#npSpiState
   \   000084   E0           MOVX      A,@DPTR
   \   000085   7045         JNZ       ??npSpiMonitor_8
    516            {
    517              if (znpSpiActiveShdw)
   \   000087   90....       MOV       DPTR,#??znpSpiActiveShdw
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   606A         JZ        ??npSpiMonitor_0
    518              {
    519                uint8 rxOnIdle;
    520                (void)ZMacGetReq(ZMacRxOnIdle, &rxOnIdle);
   \   00008D                ; Setup parameters for call to function ZMacGetReq
   \   00008D   AA..         MOV       R2,?XSP + 0
   \   00008F   AB..         MOV       R3,?XSP + 1
   \   000091   7952         MOV       R1,#0x52
   \   000093   12....       LCALL     `??ZMacGetReq::?relay`; Banked call to: ZMacGetReq
    521                if (!rxOnIdle)
   \   000096   85..82       MOV       DPL,?XSP + 0
   \   000099   85..83       MOV       DPH,?XSP + 1
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   7058         JNZ       ??npSpiMonitor_0
    522                {
    523                  znpSpiActiveShdw = FALSE;
   \   00009F   90....       MOV       DPTR,#??znpSpiActiveShdw
   \   0000A2   E4           CLR       A
   \   0000A3   F0           MOVX      @DPTR,A
    524                  if (ZSuccess != osal_start_timerEx(znpTaskId, ZNP_PWRMGR_CONSERVE_EVENT,
    525                                                                ZNP_PWRMGR_CONSERVE_DELAY))
   \   0000A4                ; Setup parameters for call to function osal_start_timerEx
   \   0000A4   90....       MOV       DPTR,#__Constant_a
   \   0000A7   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0000AA   7A80         MOV       R2,#-0x80
   \   0000AC   7B00         MOV       R3,#0x0
   \   0000AE   90....       MOV       DPTR,#MT_TaskID
   \   0000B1   E0           MOVX      A,@DPTR
   \   0000B2   F9           MOV       R1,A
   \   0000B3   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0000B6   7404         MOV       A,#0x4
   \   0000B8   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BB   E9           MOV       A,R1
   \   0000BC   6039         JZ        ??npSpiMonitor_0
    526                  {
    527                    (void)osal_set_event(znpTaskId, ZNP_PWRMGR_CONSERVE_EVENT);
   \   0000BE                ; Setup parameters for call to function osal_set_event
   \   0000BE   7A80         MOV       R2,#-0x80
   \   0000C0   7B00         MOV       R3,#0x0
   \   0000C2   90....       MOV       DPTR,#MT_TaskID
   \   0000C5   E0           MOVX      A,@DPTR
   \   0000C6   F9           MOV       R1,A
   \   0000C7   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   0000CA   802B         SJMP      ??npSpiMonitor_0
    528                  }
    529                }
    530              }
    531            }
    532            else if (!znpSpiActiveShdw)
   \                     ??npSpiMonitor_8:
   \   0000CC   90....       MOV       DPTR,#??znpSpiActiveShdw
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   7025         JNZ       ??npSpiMonitor_0
    533            {
    534              znpSpiActiveShdw = TRUE;
   \   0000D2   7401         MOV       A,#0x1
   \   0000D4   F0           MOVX      @DPTR,A
    535              (void)osal_stop_timerEx(znpTaskId, ZNP_PWRMGR_CONSERVE_EVENT);
   \   0000D5                ; Setup parameters for call to function osal_stop_timerEx
   \   0000D5   7A80         MOV       R2,#-0x80
   \   0000D7   7B00         MOV       R3,#0x0
   \   0000D9   90....       MOV       DPTR,#MT_TaskID
   \   0000DC   E0           MOVX      A,@DPTR
   \   0000DD   F9           MOV       R1,A
   \   0000DE   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    536              (void)osal_clear_event(znpTaskId, ZNP_PWRMGR_CONSERVE_EVENT);
   \   0000E1                ; Setup parameters for call to function osal_clear_event
   \   0000E1   7A80         MOV       R2,#-0x80
   \   0000E3   7B00         MOV       R3,#0x0
   \   0000E5   90....       MOV       DPTR,#MT_TaskID
   \   0000E8   E0           MOVX      A,@DPTR
   \   0000E9   F9           MOV       R1,A
   \   0000EA   12....       LCALL     `??osal_clear_event::?relay`; Banked call to: osal_clear_event
    537              (void)osal_pwrmgr_task_state(znpTaskId, PWRMGR_HOLD);
   \   0000ED                ; Setup parameters for call to function osal_pwrmgr_task_state
   \   0000ED   7A01         MOV       R2,#0x1
   \   0000EF   90....       MOV       DPTR,#MT_TaskID
   \   0000F2   E0           MOVX      A,@DPTR
   \   0000F3   F9           MOV       R1,A
   \   0000F4   12....       LCALL     `??osal_pwrmgr_task_state::?relay`; Banked call to: osal_pwrmgr_task_state
    538            }
    539          #endif
    540          }
   \                     ??npSpiMonitor_0:
   \   0000F7   80..         SJMP      ?Subroutine0
   \   0000F9                REQUIRE DMAIRQ
   \   0000F9                REQUIRE DMAARM
   \   0000F9                REQUIRE _A_P0
   \   0000F9                REQUIRE _A_IEN0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7401         MOV       A,#0x1
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine4_0
   \   000005                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7402         MOV       A,#0x2
   \   000002   F0           MOVX      @DPTR,A
   \   000003   9070F9       MOV       DPTR,#0x70f9
   \   000006   E0           MOVX      A,@DPTR
   \   000007   85..82       MOV       DPL,?XSP + 0
   \   00000A   85..83       MOV       DPH,?XSP + 1
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   75D1F7       MOV       0xd1,#-0x9
   \   000011   75D608       MOV       0xd6,#0x8
   \   000014   C284         CLR       0x80.4
   \   000016   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??znpSpiActiveShdw:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    541          
    542          /**************************************************************************************************
    543           * @fn          npSpiSRspAlloc
    544           *
    545           * @brief       This function is called by MT to allocate a buffer in which to build an SRSP frame.
    546           *              MT must only call this function after processing a received SREQ frame.
    547           *
    548           * input parameters
    549           *
    550           * @param       len - Length of the buffer required.
    551           *
    552           * output parameters
    553           *
    554           * None.
    555           *
    556           * @return      NULL for failure; a pointer to the npSpiBuf on success. Success is determined by
    557           *              the correct npSpiState and H/W signals as well as a valid length request.
    558           **************************************************************************************************
    559           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    560          uint8 *npSpiSRspAlloc(uint8 len)
   \                     npSpiSRspAlloc:
    561          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    562            if (npSpiState == NP_SPI_WAIT_SREQ)
   \   000004   90....       MOV       DPTR,#npSpiState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6405         XRL       A,#0x5
   \   00000A   7006         JNZ       ??npSpiSRspAlloc_0
    563            {
    564              return npSpiBuf;
   \   00000C   7A..         MOV       R2,#npSpiBuf & 0xff
   \   00000E   7B..         MOV       R3,#(npSpiBuf >> 8) & 0xff
   \   000010   8004         SJMP      ??npSpiSRspAlloc_1
    565            }
    566            else
    567            {
    568              return NULL;
   \                     ??npSpiSRspAlloc_0:
   \   000012   7A00         MOV       R2,#0x0
   \   000014   7B00         MOV       R3,#0x0
    569            }
   \                     ??npSpiSRspAlloc_1:
   \   000016   80..         SJMP      ??Subroutine4_0
    570          }
    571          
    572          /**************************************************************************************************
    573           * @fn          npSpiAReqAlloc
    574           *
    575           * @brief       This function is called by MT to allocate a buffer in which to buld an AREQ frame.
    576           *
    577           * input parameters
    578           *
    579           * @param       len - Length of the buffer required.
    580           *
    581           * output parameters
    582           *
    583           * None.
    584           *
    585           * @return      NULL for failure; otherwise a pointer to the data of an osal message.
    586           **************************************************************************************************
    587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    588          uint8 *npSpiAReqAlloc(uint8 len)
   \                     npSpiAReqAlloc:
    589          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
    590            return osal_msg_allocate(len + MT_RPC_FRAME_HDR_SZ);
   \   000006                ; Setup parameters for call to function osal_msg_allocate
   \   000006   2403         ADD       A,#0x3
   \   000008   FA           MOV       R2,A
   \   000009   E4           CLR       A
   \   00000A   3400         ADDC      A,#0x0
   \   00000C   FB           MOV       R3,A
   \   00000D   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000010   7F01         MOV       R7,#0x1
   \   000012   02....       LJMP      ?BANKED_LEAVE_XDATA
    591          }
    592          
    593          /**************************************************************************************************
    594           * @fn          npSpiSRspReady
    595           *
    596           * @brief       This function is called by MT to notify SPI driver that an SRSP is ready to Tx.
    597           *
    598           * input parameters
    599           *
    600           * @param       pBuf - Pointer to the buffer to transmit on the SPI.
    601           *
    602           * output parameters
    603           *
    604           * None.
    605           *
    606           * @return      None.
    607           **************************************************************************************************
    608           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    609          void npSpiSRspReady(uint8 *pBuf)
   \                     npSpiSRspReady:
    610          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    611            if ((npSpiState == NP_SPI_WAIT_SREQ) && (NP_RDYOut == 0))
   \   000004   90....       MOV       DPTR,#npSpiState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6405         XRL       A,#0x5
   \   00000A   7009         JNZ       ??npSpiSRspReady_0
   \   00000C   A284         MOV       C,0x80.4
   \   00000E   4005         JC        ??npSpiSRspReady_0
    612            {
    613              npSpiState = NP_SPI_WAIT_TX;
   \   000010   12....       LCALL     ?Subroutine2 & 0xFFFF
    614              DMA_TX( pBuf );
    615              NP_RDYOut = 1;
   \                     ??CrossCallReturnLabel_3:
   \   000013   D284         SETB      0x80.4
    616            }
    617          }
   \                     ??npSpiSRspReady_0:
   \   000015   80..         SJMP      ??Subroutine4_0
   \   000017                REQUIRE _A_P0
   \   000017                REQUIRE DMAIRQ
   \   000017                REQUIRE DMAARM
   \   000017                REQUIRE DMAREQ

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7403         MOV       A,#0x3
   \   000002   F0           MOVX      @DPTR,A
   \   000003   EA           MOV       A,R2
   \   000004   FC           MOV       R4,A
   \   000005   EB           MOV       A,R3
   \   000006   90....       MOV       DPTR,#dmaCh1234 + 24
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   EC           MOV       A,R4
   \   00000B   A3           INC       DPTR
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   75D1EF       MOV       0xd1,#-0x11
   \   000010   75D610       MOV       0xd6,#0x10
   \   000013   75D710       MOV       0xd7,#0x10
   \   000016   22           RET
    618          
    619          /**************************************************************************************************
    620           * @fn          npSpiAReqReady
    621           *
    622           * @brief       This function is called by MT to notify the SPI driver that an AREQ frame is ready
    623           *              to be transmitted.
    624           *
    625           * input parameters
    626           *
    627           * None.
    628           *
    629           * output parameters
    630           *
    631           * None.
    632           *
    633           * @return      None.
    634           **************************************************************************************************
    635           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    636          void npSpiAReqReady(void)
   \                     npSpiAReqReady:
    637          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV       A,#-0x1
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    638            halIntState_t intState;
    639            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   F8           MOV       R0,A
   \   00000E   C2AF         CLR       0xa8.7
    640          
    641            if (npSpiState == NP_SPI_IDLE)
   \   000010   90....       MOV       DPTR,#npSpiState
   \   000013   E0           MOVX      A,@DPTR
   \   000014   7003         JNZ       ??CrossCallReturnLabel_1
    642            {
    643              npSpiState = NP_SPI_WAIT_RX;
   \   000016   12....       LCALL     ?Subroutine1 & 0xFFFF
    644              DMA_RX();
    645              NP_RDYOut = 0;
    646            }
    647          
    648            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_1:
   \   000019   E8           MOV       A,R0
   \   00001A   A2E0         MOV       C,0xE0 /* A   */.0
   \   00001C   92AF         MOV       0xa8.7,C
    649          }
   \   00001E   80..         SJMP      ?Subroutine0
   \   000020                REQUIRE _A_IEN0
   \   000020                REQUIRE DMAIRQ
   \   000020                REQUIRE DMAARM
   \   000020                REQUIRE _A_P0
    650          
    651          /**************************************************************************************************
    652           * @fn          npSpiAReqComplete
    653           *
    654           * @brief       This function is called by MT to notify the SPI driver that the processing of a
    655           *              received AREQ is complete.
    656           *
    657           * input parameters
    658           *
    659           * None.
    660           *
    661           * output parameters
    662           *
    663           * None.
    664           *
    665           * @return      None.
    666           **************************************************************************************************
    667           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    668          void npSpiAReqComplete(void)
   \                     npSpiAReqComplete:
    669          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    670            if (npSpiState == NP_SPI_WAIT_AREQ)
   \   000004   90....       MOV       DPTR,#npSpiState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6404         XRL       A,#0x4
   \   00000A   7002         JNZ       ??npSpiAReqComplete_0
    671            {
    672              npSpiState = NP_SPI_IDLE;
   \   00000C   E4           CLR       A
   \   00000D   F0           MOVX      @DPTR,A
    673            }
    674          }
   \                     ??npSpiAReqComplete_0:
   \   00000E   80..         SJMP      ??Subroutine4_0
    675          
    676          /**************************************************************************************************
    677           * @fn          npSpiGetReqBuf
    678           *
    679           * @brief       This function is called by the application to get the buffer containing the
    680           *              currently received AREQ or SREQ.
    681           *
    682           * input parameters
    683           *
    684           * None.
    685           *
    686           * output parameters
    687           *
    688           * None.
    689           *
    690           * @return      Pointer to the buffer containing the currently received AREQ or SREQ.
    691           **************************************************************************************************
    692           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    693          uint8 *npSpiGetReqBuf(void)
   \                     npSpiGetReqBuf:
    694          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    695            if (npSpiState != NP_SPI_IDLE)
   \   000004   90....       MOV       DPTR,#npSpiState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6006         JZ        ??npSpiGetReqBuf_0
    696            {
    697              return npSpiBuf;
   \   00000A   7A..         MOV       R2,#npSpiBuf & 0xff
   \   00000C   7B..         MOV       R3,#(npSpiBuf >> 8) & 0xff
   \   00000E   8004         SJMP      ??npSpiGetReqBuf_1
    698            }
    699            else
    700            {
    701              return NULL;
   \                     ??npSpiGetReqBuf_0:
   \   000010   7A00         MOV       R2,#0x0
   \   000012   7B00         MOV       R3,#0x0
    702            }
   \                     ??npSpiGetReqBuf_1:
   \   000014   02....       LJMP      ??Subroutine4_0 & 0xFFFF
    703          }
    704          
    705          /**************************************************************************************************
    706           * @fn          npSpiMrdyIsr
    707           *
    708           * @brief       This function is called when a GPIO falling-edge interrupt occurs on the MRDY.
    709           *
    710           * input parameters
    711           *
    712           * None.
    713           *
    714           * output parameters
    715           *
    716           * None.
    717           *
    718           * @return      None.
    719           **************************************************************************************************
    720           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    721          void npSpiMrdyIsr(void)
   \                     npSpiMrdyIsr:
    722          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV       A,#-0x1
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    723            if (npSpiState == NP_SPI_IDLE)
   \   000009   90....       MOV       DPTR,#npSpiState
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   7013         JNZ       ??CrossCallReturnLabel_2
    724            {
    725          #if defined POWER_SAVING
    726              if (ZG_DEVICE_ENDDEVICE_TYPE)
   \   00000F   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000012   E0           MOVX      A,@DPTR
   \   000013   6402         XRL       A,#0x2
   \   000015   90....       MOV       DPTR,#npSpiState
   \   000018   7005         JNZ       ??npSpiMrdyIsr_0
    727              {
    728                npSpiState = NP_SPI_MRDY;
   \   00001A   7401         MOV       A,#0x1
   \   00001C   F0           MOVX      @DPTR,A
   \   00001D   8003         SJMP      ??CrossCallReturnLabel_2
    729              }
    730              else
    731          #endif        
    732              {
    733                npSpiState = NP_SPI_WAIT_RX;
   \                     ??npSpiMrdyIsr_0:
   \   00001F   12....       LCALL     ?Subroutine1 & 0xFFFF
    734                DMA_RX();
    735                NP_RDYOut = 0;
    736              }
    737            }
    738          }
   \                     ??CrossCallReturnLabel_2:
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000025                REQUIRE DMAIRQ
   \   000025                REQUIRE DMAARM
   \   000025                REQUIRE _A_P0
    739          
    740          /**************************************************************************************************
    741           * @fn          npSpiRxIsr
    742           *
    743           * @brief       This function handles the DMA Rx complete interrupt.
    744           *
    745           * input parameters
    746           *
    747           * None.
    748           *
    749           * output parameters
    750           *
    751           * None.
    752           *
    753           * @return      None.
    754           **************************************************************************************************
    755           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    756          void npSpiRxIsr(void)
   \                     npSpiRxIsr:
    757          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    758            mtRpcCmdType_t type = (mtRpcCmdType_t)(npSpiBuf[1] & MT_RPC_CMD_TYPE_MASK);
    759            uint8 *pBuf, rdy = 1;
   \   000005   7E01         MOV       R6,#0x1
    760          
    761            NP_SPI_ASSERT(npSpiState == NP_SPI_WAIT_RX);
    762          
    763            switch (type)
   \   000007   90....       MOV       DPTR,#npSpiBuf + 1
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   54E0         ANL       A,#0xe0
   \   00000D   600A         JZ        ??npSpiRxIsr_0
   \   00000F   24E0         ADD       A,#-0x20
   \   000011   6026         JZ        ??npSpiRxIsr_1
   \   000013   24E0         ADD       A,#-0x20
   \   000015   6038         JZ        ??npSpiRxIsr_2
   \   000017   804A         SJMP      ??npSpiRxIsr_3
    764            {
    765            case MT_RPC_CMD_POLL:
    766              if ( (pBuf = npSpiPollCallback()) == NULL )
   \                     ??npSpiRxIsr_0:
   \   000019                ; Setup parameters for call to function npSpiPollCallback
   \   000019   12....       LCALL     `??npSpiPollCallback::?relay`; Banked call to: npSpiPollCallback
   \   00001C   8B..         MOV       ?V1,R3
   \   00001E   A9..         MOV       R1,?V1
   \   000020   EA           MOV       A,R2
   \   000021   49           ORL       A,R1
   \   000022   700D         JNZ       ??npSpiRxIsr_4
    767              {
    768                pBuf = npSpiBuf;
   \   000024   7A..         MOV       R2,#npSpiBuf & 0xff
   \   000026   7B..         MOV       R3,#(npSpiBuf >> 8) & 0xff
    769                npSpiBuf[0] = 0;
   \   000028   90....       MOV       DPTR,#npSpiBuf
   \   00002B   E4           CLR       A
   \   00002C   F0           MOVX      @DPTR,A
    770                npSpiBuf[1] = 0;
   \   00002D   A3           INC       DPTR
   \   00002E   F0           MOVX      @DPTR,A
    771                npSpiBuf[2] = 0;
   \   00002F   A3           INC       DPTR
   \   000030   F0           MOVX      @DPTR,A
    772              }
    773              npSpiState = NP_SPI_WAIT_TX;
   \                     ??npSpiRxIsr_4:
   \   000031   90....       MOV       DPTR,#npSpiState
   \   000034   12....       LCALL     ?Subroutine2 & 0xFFFF
    774              DMA_TX(pBuf);
    775              break;
   \                     ??CrossCallReturnLabel_4:
   \   000037   802F         SJMP      ??npSpiRxIsr_5
    776          
    777            case MT_RPC_CMD_SREQ:
    778              npSpiState = NP_SPI_WAIT_SREQ;
   \                     ??npSpiRxIsr_1:
   \   000039   90....       MOV       DPTR,#npSpiState
   \   00003C   7405         MOV       A,#0x5
   \   00003E   F0           MOVX      @DPTR,A
    779              osal_set_event(znpTaskId, ZNP_SPI_RX_SREQ_EVENT);
   \   00003F                ; Setup parameters for call to function osal_set_event
   \   00003F   7A00         MOV       R2,#0x0
   \   000041   7B20         MOV       R3,#0x20
   \   000043   90....       MOV       DPTR,#MT_TaskID
   \   000046   E0           MOVX      A,@DPTR
   \   000047   F9           MOV       R1,A
   \   000048   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    780              rdy = 0;
   \   00004B   7E00         MOV       R6,#0x0
    781              break;
   \   00004D   8019         SJMP      ??npSpiRxIsr_5
    782          
    783            case MT_RPC_CMD_AREQ:
    784              npSpiState = NP_SPI_WAIT_AREQ;
   \                     ??npSpiRxIsr_2:
   \   00004F   90....       MOV       DPTR,#npSpiState
   \   000052   7404         MOV       A,#0x4
   \   000054   F0           MOVX      @DPTR,A
    785              osal_set_event(znpTaskId, ZNP_SPI_RX_AREQ_EVENT);
   \   000055                ; Setup parameters for call to function osal_set_event
   \   000055   7A00         MOV       R2,#0x0
   \   000057   7B40         MOV       R3,#0x40
   \   000059   90....       MOV       DPTR,#MT_TaskID
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F9           MOV       R1,A
   \   00005E   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    786              break;
   \   000061   8005         SJMP      ??npSpiRxIsr_5
    787          
    788            default:
    789              npSpiState = NP_SPI_IDLE;
   \                     ??npSpiRxIsr_3:
   \   000063   90....       MOV       DPTR,#npSpiState
   \   000066   E4           CLR       A
   \   000067   F0           MOVX      @DPTR,A
    790              break;
    791            }
    792            NP_RDYOut = rdy;
   \                     ??npSpiRxIsr_5:
   \   000068   EE           MOV       A,R6
   \   000069   C4           SWAP      A
   \   00006A   54F0         ANL       A,#0xf0
   \   00006C   F8           MOV       R0,A
   \   00006D   E580         MOV       A,0x80
   \   00006F   54EF         ANL       A,#0xef
   \   000071   48           ORL       A,R0
   \   000072   F580         MOV       0x80,A
    793          }
   \   000074   7F02         MOV       R7,#0x2
   \   000076   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000079                REQUIRE DMAIRQ
   \   000079                REQUIRE DMAARM
   \   000079                REQUIRE DMAREQ
   \   000079                REQUIRE _A_P0
    794          
    795          /**************************************************************************************************
    796           * @fn          npSpiTxIsr
    797           *
    798           * @brief       This function handles the DMA Tx complete interrupt.
    799           *
    800           * input parameters
    801           *
    802           * None.
    803           *
    804           * output parameters
    805           *
    806           * None.
    807           *
    808           * @return      None.
    809           **************************************************************************************************
    810           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    811          void npSpiTxIsr(void)
   \                     npSpiTxIsr:
    812          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    813            halDMADesc_t *ch = HAL_DMA_GET_DESC1234(HAL_DMA_CH_TX);
    814            uint16 src;
    815          
    816            NP_SPI_ASSERT(npSpiState == NP_SPI_WAIT_TX);
    817          
    818            HAL_DMA_GET_SOURCE( ch, src );
   \   000004   90....       MOV       DPTR,#dmaCh1234 + 24
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   A3           INC       DPTR
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   FA           MOV       R2,A
   \   00000C   E9           MOV       A,R1
   \   00000D   FB           MOV       R3,A
    819          
    820            if ((uint8 *)src != npSpiBuf)
   \   00000E   74..         MOV       A,#npSpiBuf & 0xff
   \   000010   6A           XRL       A,R2
   \   000011   7003         JNZ       ??npSpiTxIsr_0
   \   000013   74..         MOV       A,#(npSpiBuf >> 8) & 0xff
   \   000015   6B           XRL       A,R3
   \                     ??npSpiTxIsr_0:
   \   000016   6003         JZ        ??npSpiTxIsr_1
    821            {
    822              osal_msg_deallocate((uint8 *)src);
   \   000018                ; Setup parameters for call to function osal_msg_deallocate
   \   000018   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    823            }
    824          
    825            npSpiState = NP_SPI_IDLE;
   \                     ??npSpiTxIsr_1:
   \   00001B   90....       MOV       DPTR,#npSpiState
   \   00001E   E4           CLR       A
   \   00001F   F0           MOVX      @DPTR,A
    826          }
   \   000020   02....       LJMP      ??Subroutine4_0 & 0xFFFF
    827          
    828          /**************************************************************************************************
    829           * @fn          npSpiIdle
    830           *
    831           * @brief       This function returns true if SPI is idle and there is no queued data.
    832           *
    833           * input parameters
    834           *
    835           * None.
    836           *
    837           * output parameters
    838           *
    839           * None.
    840           *
    841           * @return      True if SPI is idle with no quequed data.
    842           **************************************************************************************************
    843           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    844          bool npSpiIdle(void)
   \                     npSpiIdle:
    845          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    846            return (npSpiState == NP_SPI_IDLE && !npSpiReadyCallback());
   \   000004   90....       MOV       DPTR,#npSpiState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   700A         JNZ       ??npSpiIdle_0
   \   00000A                ; Setup parameters for call to function npSpiReadyCallback
   \   00000A   12....       LCALL     `??npSpiReadyCallback::?relay`; Banked call to: npSpiReadyCallback
   \   00000D   E9           MOV       A,R1
   \   00000E   7004         JNZ       ??npSpiIdle_0
   \   000010   7901         MOV       R1,#0x1
   \   000012   8002         SJMP      ??npSpiIdle_1
   \                     ??npSpiIdle_0:
   \   000014   7900         MOV       R1,#0x0
   \                     ??npSpiIdle_1:
   \   000016   02....       LJMP      ??Subroutine4_0 & 0xFFFF
    847          }
    848          
    849          /**************************************************************************************************
    850           * @fn          portN-Isr
    851           *
    852           * @brief       This function handles the PORT-N interrupt.
    853           *
    854           * input parameters
    855           *
    856           * None.
    857           *
    858           * output parameters
    859           *
    860           * None.
    861           *
    862           * @return      None.
    863           **************************************************************************************************
    864           */
    865          #if defined CC2530_MK
    866          HAL_ISR_FUNCTION(port2Isr, P2INT_VECTOR)
    867          {
    868            P2IFG = 0;
    869            P2IF = 0;
    870          #else

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    871          HAL_ISR_FUNCTION(port0Isr, P0INT_VECTOR)
   \                     port0Isr:
    872          {
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    873            P0IFG = 0;
   \   000007   758900       MOV       0x89,#0x0
    874            P0IF = 0;
   \   00000A   C2C5         CLR       0xc0.5
    875          #endif
    876          
    877            // Knowing which pin requires a #define from _hal_uart_dma.c
    878            //if (P0IFG & NP_RDYIn_BIT)
    879            {
    880              if (ZNP_CFG1_UART == znpCfg1)
   \   00000C   90....       MOV       DPTR,#znpCfg1
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   700E         JNZ       ??port0Isr_0
    881              {
    882                osal_set_event(znpTaskId, ZNP_UART_TX_READY_EVENT);
   \   000012                ; Setup parameters for call to function osal_set_event
   \   000012   7A00         MOV       R2,#0x0
   \   000014   7B10         MOV       R3,#0x10
   \   000016   90....       MOV       DPTR,#MT_TaskID
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F9           MOV       R1,A
   \   00001B   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   00001E   8003         SJMP      ??port0Isr_1
    883              }
    884              else
    885              {
    886                npSpiMrdyIsr();
   \                     ??port0Isr_0:
   \   000020                ; Setup parameters for call to function npSpiMrdyIsr
   \   000020   12....       LCALL     `??npSpiMrdyIsr::?relay`; Banked call to: npSpiMrdyIsr
    887              }
    888            }
    889          }
   \                     ??port0Isr_1:
   \   000023   7F01         MOV       R7,#0x1
   \   000025   02....       LJMP      ?INTERRUPT_LEAVE_XSP
   \   000028                REQUIRE P0IFG
   \   000028                REQUIRE _A_IRCON

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??port0Isr::??INTVEC 107`:
   \   00006B   02....       LJMP       (port0Isr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_a:
   \   000000   0A000000     DD 10

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??dmaInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    dmaInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiMonitor::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiMonitor

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiSRspAlloc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiSRspAlloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiAReqAlloc::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiAReqAlloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiSRspReady::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiSRspReady

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiAReqReady::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiAReqReady

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiAReqComplete::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiAReqComplete

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiGetReqBuf::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiGetReqBuf

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiMrdyIsr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiMrdyIsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiRxIsr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiRxIsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiTxIsr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiTxIsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??npSpiIdle::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    npSpiIdle
    890          
    891          /**************************************************************************************************
    892          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   dmaInit
      0      9   npSpiAReqAlloc
        0      9   -> osal_msg_allocate
      2      0   npSpiAReqComplete
      3      2   npSpiAReqReady
      2      0   npSpiGetReqBuf
      2      0   npSpiIdle
        2      0   -> npSpiReadyCallback
      2      0   npSpiInit
        2      0   -> dmaInit
      3      5   npSpiMonitor
        2      1   -> ZMacGetReq
        2      1   -> npSpiAReqReady
        2      1   -> npSpiReadyCallback
        2      1   -> npSpiRxIsr
        2      1   -> npSpiTxIsr
        2      1   -> osal_clear_event
        2      1   -> osal_pwrmgr_task_state
        2      1   -> osal_set_event
        2      5   -> osal_start_timerEx
        2      1   -> osal_stop_timerEx
      3     15   npSpiMrdyIsr
      0     11   npSpiRxIsr
        0     10   -> npSpiPollCallback
        0     10   -> osal_set_event
      2      0   npSpiSRspAlloc
      2      0   npSpiSRspReady
      2      1   npSpiTxIsr
        2      0   -> osal_msg_deallocate
      0     14   port0Isr
        0     14   -> npSpiMrdyIsr
        0     14   -> osal_set_event


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ??Subroutine4_0
       5  ?Subroutine0
      23  ?Subroutine1
      23  ?Subroutine2
      13  ?Subroutine3
       1  DMAARM
       1  DMAIRQ
       1  DMAREQ
       1  P0DIR
       1  P0IEN
       1  P0IFG
       1  P0INP
       1  P0SEL
       1  P1SEL
       1  P2INP
       1  P2SEL
       1  PERCFG
       1  PICTL
       1  U1GCR
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       1  _A_P0
       1  _A_U1CSR
       4  __Constant_a
      79  dmaInit
       6  dmaInit::?relay
      21  npSpiAReqAlloc
       6  npSpiAReqAlloc::?relay
      16  npSpiAReqComplete
       6  npSpiAReqComplete::?relay
      32  npSpiAReqReady
       6  npSpiAReqReady::?relay
     254  npSpiBuf
      23  npSpiGetReqBuf
       6  npSpiGetReqBuf::?relay
      25  npSpiIdle
       6  npSpiIdle::?relay
      64  npSpiInit
       6  npSpiInit::?relay
     249  npSpiMonitor
       6  npSpiMonitor::?relay
      37  npSpiMrdyIsr
       6  npSpiMrdyIsr::?relay
     121  npSpiRxIsr
       6  npSpiRxIsr::?relay
      24  npSpiSRspAlloc
       6  npSpiSRspAlloc::?relay
      23  npSpiSRspReady
       6  npSpiSRspReady::?relay
       1  npSpiState
      35  npSpiTxIsr
       6  npSpiTxIsr::?relay
      40  port0Isr
       3  port0Isr::??INTVEC 107
       1  znpSpiActiveShdw

 
 820 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
   3 bytes in segment INTVEC
  40 bytes in segment NEAR_CODE
  19 bytes in segment SFR_AN
   4 bytes in segment XDATA_ROM_C
 256 bytes in segment XDATA_Z
 
 118 bytes of CODE     memory (+  3 bytes shared)
   0 bytes of CONST    memory (+  4 bytes shared)
   0 bytes of DATA     memory (+ 19 bytes shared)
 820 bytes of HUGECODE memory
 256 bytes of XDATA    memory

Errors: none
Warnings: none
