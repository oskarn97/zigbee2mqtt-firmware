###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               16/Feb/2018  22:13:28
# Copyright 2004-2017 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 10.10
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\nwk\BindingTable.c
#    Command line       =  
#        -f C:\Users\Oskar\AppData\Local\Temp\EWA81E.tmp ("C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Components\stack\nwk\BindingTable.c" -D
#        FEATURE_SYSTEM_STATS -D CC2531ZNP -D POWER_SAVING -D ASSERT_RESET -D
#        FAKE_CRC_SHDW -D xTC_LINKKEY_JOIN -lC "C:\Texas Instruments\Z-Stack
#        Home 1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2531-ProdHex\List" -lA
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2531-ProdHex\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2531-ProdHex\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DTC_LINKKEY_JOIN -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC
#        -DMT_SAPI_FUNC -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC
#        -DMT_ZDO_MGMT -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Utilities\BootLoad\Source\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530USB\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530USB\usb\library\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530USB\usb\library\cc2531\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530USB\usb\class_cdc\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary163\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary283\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  German_Germany.1252
#    List file          =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2531-ProdHex\List\BindingTable.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2531-ProdHex\Obj\BindingTable.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Components\stack\nwk\BindingTable.c
      1          /**************************************************************************************************
      2            Filename:       BindingTable.c
      3            Revised:        $Date: 2014-10-08 08:37:03 -0700 (Wed, 08 Oct 2014) $
      4            Revision:       $Revision: 40512 $
      5          
      6            Description:    Device binding table functions.
      7          
      8          
      9            Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          #include "nwk_globals.h"
     47          #include "AddrMgr.h"
     48          #include "BindingTable.h"
     49          #include "nwk_util.h"
     50          
     51          /*********************************************************************
     52           * MACROS
     53           */
     54          
     55          /*********************************************************************
     56           * CONSTANTS
     57           */
     58          #define NV_BIND_EMPTY   0xFF
     59          #define NV_BIND_REC_SIZE (gBIND_REC_SIZE)
     60          #define NV_BIND_ITEM_SIZE  (gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES)
     61          
     62          /*********************************************************************
     63           * TYPEDEFS
     64           */
     65          typedef struct
     66          {
     67            uint8        srcEP;
     68            uint16       dstIndex;
     69            uint8        dstEP;
     70            uint8        dstAddrMode;
     71            uint8        clusterIDs;
     72            uint16*      clusterIDList;
     73          } bindFields_t;
     74          
     75          /*********************************************************************
     76           * GLOBAL VARIABLES
     77           */
     78          
     79          /*********************************************************************
     80           * LOCAL FUNCTIONS
     81           */
     82          void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryOld,
     83                              AddrMgrEntry_t *entryNew );
     84          BindingEntry_t *bindFindEmpty( void );
     85          uint16 bindingAddrMgsHelperFind( zAddrType_t *addr );
     86          uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr );
     87          void bindAddrMgrLocalLoad( void );
     88          
     89          #if !defined ( BINDINGTABLE_NV_SINGLES )
     90            #if !defined ( DONT_UPGRADE_BIND )
     91              static uint8 BindCopyBackupToNewNV( uint16 dupLen, uint16 newLen );
     92              static uint8 BindUpgradeTableInNV( void );
     93            #endif
     94          #endif // !BINDINGTABLE_NV_SINGLES
     95          
     96          
     97          /*********************************************************************
     98           * LOCAL VARIABLES
     99           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    100          static uint8 bindAddrMgrLocalLoaded = FALSE;
   \                     bindAddrMgrLocalLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    101          
    102          /*********************************************************************
    103           * Function Pointers
    104           */
    105          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    106          BindingEntry_t *(*pbindAddEntry)( byte srcEpInt,
   \                     pbindAddEntry:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    107                                            zAddrType_t *dstAddr, byte dstEpInt,
    108                                            byte numClusterIds, uint16 *clusterIds ) = (void*)NULL;

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    109          uint16 (*pbindNumOfEntries)( void ) = (void*)NULL;
   \                     pbindNumOfEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    110          void (*pbindRemoveDev)( zAddrType_t *Addr ) = (void*)NULL;
   \                     pbindRemoveDev:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          byte (*pBindInitNV)( void ) = (void*)NULL;
   \                     pBindInitNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          void (*pBindSetDefaultNV)( void ) = (void*)NULL;
   \                     pBindSetDefaultNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          uint16 (*pBindRestoreFromNV)( void ) = (void*)NULL;
   \                     pBindRestoreFromNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    114          void (*pBindWriteNV)( void ) = (void*)NULL;
   \                     pBindWriteNV:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    115          
    116          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
    117          /*********************************************************************
    118           * @fn      BindAddrMgrCB()
    119           *
    120           * @brief   Address Manager Callback function
    121           *
    122           * @param   update -
    123           * @param   entry -
    124           *
    125           * @return  pointer to
    126           */
    127          void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryNew,
    128                              AddrMgrEntry_t *entryOld )
    129          {
    130            // Check for either deleted items or changed Extended (Duplicate) addresses
    131          }
    132          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
    133          
    134          /*********************************************************************
    135           * @fn      InitBindingTable()
    136           *
    137           * @brief
    138           *
    139           *   This function is used to initialise the binding table
    140           *
    141           * @param   none
    142           *
    143           * @return  none
    144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void InitBindingTable( void )
   \                     InitBindingTable:
    146          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    147            osal_memset( BindingTable, 0xFF, gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES );
   \   000005                ; Setup parameters for call to function osal_memset
   \   000005   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000008   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000B   E4           CLR       A
   \   00000C   93           MOVC      A,@A+DPTR
   \   00000D   F5..         MOV       ?V0,A
   \   00000F   EC           MOV       A,R4
   \   000010   85..F0       MOV       B,?V0
   \   000013   A4           MUL       AB
   \   000014   FC           MOV       R4,A
   \   000015   A8F0         MOV       R0,B
   \   000017   85..F0       MOV       B,?V0
   \   00001A   ED           MOV       A,R5
   \   00001B   A4           MUL       AB
   \   00001C   28           ADD       A,R0
   \   00001D   FD           MOV       R5,A
   \   00001E   79FF         MOV       R1,#-0x1
   \   000020   7A..         MOV       R2,#BindingTable & 0xff
   \   000022   7B..         MOV       R3,#(BindingTable >> 8) & 0xff
   \   000024   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    148          
    149            pbindAddEntry = bindAddEntry;
   \   000027   90....       MOV       DPTR,#pbindAddEntry
   \   00002A   74..         MOV       A,#`??bindAddEntry::?relay` & 0xff
   \   00002C   F0           MOVX      @DPTR,A
   \   00002D   A3           INC       DPTR
   \   00002E   74..         MOV       A,#(`??bindAddEntry::?relay` >> 8) & 0xff
   \   000030   F0           MOVX      @DPTR,A
    150            pbindNumOfEntries = bindNumOfEntries;
   \   000031   90....       MOV       DPTR,#pbindNumOfEntries
   \   000034   74..         MOV       A,#`??bindNumOfEntries::?relay` & 0xff
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   74..         MOV       A,#(`??bindNumOfEntries::?relay` >> 8) & 0xff
   \   00003A   F0           MOVX      @DPTR,A
    151            pbindRemoveDev = bindRemoveDev;
   \   00003B   90....       MOV       DPTR,#pbindRemoveDev
   \   00003E   74..         MOV       A,#`??bindRemoveDev::?relay` & 0xff
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   74..         MOV       A,#(`??bindRemoveDev::?relay` >> 8) & 0xff
   \   000044   F0           MOVX      @DPTR,A
    152            pBindInitNV = BindInitNV;
   \   000045   90....       MOV       DPTR,#pBindInitNV
   \   000048   74..         MOV       A,#`??BindInitNV::?relay` & 0xff
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   A3           INC       DPTR
   \   00004C   74..         MOV       A,#(`??BindInitNV::?relay` >> 8) & 0xff
   \   00004E   F0           MOVX      @DPTR,A
    153            pBindSetDefaultNV = BindSetDefaultNV;
   \   00004F   90....       MOV       DPTR,#pBindSetDefaultNV
   \   000052   74..         MOV       A,#`??BindSetDefaultNV::?relay` & 0xff
   \   000054   F0           MOVX      @DPTR,A
   \   000055   A3           INC       DPTR
   \   000056   74..         MOV       A,#(`??BindSetDefaultNV::?relay` >> 8) & 0xff
   \   000058   F0           MOVX      @DPTR,A
    154            pBindRestoreFromNV = BindRestoreFromNV;
   \   000059   90....       MOV       DPTR,#pBindRestoreFromNV
   \   00005C   74..         MOV       A,#`??BindRestoreFromNV::?relay` & 0xff
   \   00005E   F0           MOVX      @DPTR,A
   \   00005F   A3           INC       DPTR
   \   000060   74..         MOV       A,#(`??BindRestoreFromNV::?relay` >> 8) & 0xff
   \   000062   F0           MOVX      @DPTR,A
    155            pBindWriteNV = BindWriteNV;
   \   000063   90....       MOV       DPTR,#pBindWriteNV
   \   000066   74..         MOV       A,#`??BindWriteNV::?relay` & 0xff
   \   000068   F0           MOVX      @DPTR,A
   \   000069   A3           INC       DPTR
   \   00006A   74..         MOV       A,#(`??BindWriteNV::?relay` >> 8) & 0xff
   \   00006C   F0           MOVX      @DPTR,A
    156          
    157            bindAddrMgrLocalLoaded = FALSE;
   \   00006D   90....       MOV       DPTR,#bindAddrMgrLocalLoaded
   \   000070   E4           CLR       A
   \   000071   F0           MOVX      @DPTR,A
    158          
    159          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
    160            // Register with the address manager
    161            AddrMgrRegister( ADDRMGR_REG_BINDING, BindAddrMgrCB );
    162          #endif
    163          }
   \   000072   80..         SJMP      ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   FC           MOV       R4,A
   \   000006   7401         MOV       A,#0x1
   \   000008   93           MOVC      A,@A+DPTR
   \   000009   FD           MOV       R5,A
   \   00000A   22           RET
    164          
    165          /*********************************************************************
    166           * @fn      bindFindEmpty()
    167           *
    168           * @brief   This function returns a pointer to an empty binding slot
    169           *
    170           * @param   none
    171           *
    172           * @return  pointer to binding table entry, NULL if not added
    173           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    174          BindingEntry_t *bindFindEmpty( void )
   \                     bindFindEmpty:
    175          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    176            bindTableIndex_t x;
    177          
    178            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000004   7A00         MOV       R2,#0x0
   \   000006   8001         SJMP      ??bindFindEmpty_0
   \                     ??bindFindEmpty_1:
   \   000008   0A           INC       R2
   \                     ??bindFindEmpty_0:
   \   000009   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000C   E4           CLR       A
   \   00000D   93           MOVC      A,@A+DPTR
   \   00000E   F8           MOV       R0,A
   \   00000F   EA           MOV       A,R2
   \   000010   C3           CLR       C
   \   000011   98           SUBB      A,R0
   \   000012   500B         JNC       ??bindFindEmpty_2
    179            {
    180              // It's empty if the index is "Not Found"
    181              if ( BindingTable[x].srcEP == NV_BIND_EMPTY )
   \   000014   EA           MOV       A,R2
   \   000015   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000018   70EE         JNZ       ??bindFindEmpty_1
    182              {
    183                return ( &BindingTable[x] );
   \   00001A   12....       LCALL     ?Subroutine14 & 0xFFFF
    184              }
    185            }
   \                     ??CrossCallReturnLabel_18:
   \   00001D   8004         SJMP      ??bindFindEmpty_3
    186          
    187            return ( (BindingEntry_t *)NULL );
   \                     ??bindFindEmpty_2:
   \   00001F   7A00         MOV       R2,#0x0
   \   000021   7B00         MOV       R3,#0x0
   \                     ??bindFindEmpty_3:
   \   000023   02....       LJMP      ??Subroutine41_0 & 0xFFFF
    188          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007                REQUIRE ??Subroutine34_0
   \   000007                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000003   F4           CPL       A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   74..         MOV       A,#BindingTable & 0xff
   \   000002   28           ADD       A,R0
   \   000003   FA           MOV       R2,A
   \   000004   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000006   39           ADDC      A,R1
   \   000007   FB           MOV       R3,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   74..         MOV       A,#BindingTable & 0xff
   \   000002   28           ADD       A,R0
   \   000003   F582         MOV       DPL,A
   \   000005   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000007   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   39           ADDC      A,R1
   \   000001   F583         MOV       DPH,A
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    189          
    190          /*********************************************************************
    191           * @fn      bindNumOfEntries()
    192           *
    193           * @brief   This function returns the number of binding table entries.
    194           *          The return for this is the number of clusters in the
    195           *          table NOT the number of entries.
    196           *
    197           * @param   none
    198           *
    199           * @return  number of entries
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          uint16 bindNumOfEntries( void )
   \                     bindNumOfEntries:
    202          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    203            bindTableIndex_t x;
    204            uint16 found;
    205          
    206            for ( found = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000004   7A00         MOV       R2,#0x0
   \   000006   7B00         MOV       R3,#0x0
   \   000008   7C00         MOV       R4,#0x0
   \   00000A   8018         SJMP      ??bindNumOfEntries_0
    207            {
    208              // It's empty if the index is "Not Found"
    209              if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \                     ??bindNumOfEntries_1:
   \   00000C   EC           MOV       A,R4
   \   00000D   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000010   6011         JZ        ??bindNumOfEntries_2
    210              {
    211                found += BindingTable[x].numClusterIds;
   \   000012   74..         MOV       A,#(BindingTable + 5) & 0xff
   \   000014   28           ADD       A,R0
   \   000015   F582         MOV       DPL,A
   \   000017   74..         MOV       A,#((BindingTable + 5) >> 8) & 0xff
   \   000019   12....       LCALL     ?Subroutine32 & 0xFFFF
    212              }
    213            }
   \                     ??CrossCallReturnLabel_58:
   \   00001C   F8           MOV       R0,A
   \   00001D   EA           MOV       A,R2
   \   00001E   28           ADD       A,R0
   \   00001F   FA           MOV       R2,A
   \   000020   E4           CLR       A
   \   000021   3B           ADDC      A,R3
   \   000022   FB           MOV       R3,A
   \                     ??bindNumOfEntries_2:
   \   000023   0C           INC       R4
   \                     ??bindNumOfEntries_0:
   \   000024   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000027   E4           CLR       A
   \   000028   93           MOVC      A,@A+DPTR
   \   000029   F8           MOV       R0,A
   \   00002A   EC           MOV       A,R4
   \   00002B   C3           CLR       C
   \   00002C   98           SUBB      A,R0
   \   00002D   40DD         JC        ??bindNumOfEntries_1
    214          
    215            return ( found );
   \   00002F   02....       LJMP      ??Subroutine41_0 & 0xFFFF
    216          }
    217          
    218          /*********************************************************************
    219           * @fn      bindCapacity()
    220           *
    221           * @brief   This function returns the number of binding entries
    222           *          possible and used.
    223           *
    224           * @param   maxEntries - pointer to a place to put the max entries
    225           * @param   usedEntries - pointer to a place to put the number
    226           *               of used entries
    227           *
    228           * @return  none
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          void bindCapacity( uint16 *maxEntries, uint16 *usedEntries  )
   \                     bindCapacity:
    231          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    232            bindTableIndex_t x;
    233            bindTableIndex_t used;
    234          
    235            for ( used = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000005   7F00         MOV       R7,#0x0
   \   000007   7E00         MOV       R6,#0x0
   \   000009   8012         SJMP      ??bindCapacity_0
    236            {
    237              // It's empty if the index is "Not Found"
    238              if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \                     ??bindCapacity_1:
   \   00000B   EE           MOV       A,R6
   \   00000C   75F00E       MOV       B,#0xe
   \   00000F   A4           MUL       AB
   \   000010   F8           MOV       R0,A
   \   000011   85F0..       MOV       ?V0,B
   \   000014   A9..         MOV       R1,?V0
   \   000016   12....       LCALL     ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000019   6001         JZ        ??bindCapacity_2
    239              {
    240                used++;
   \   00001B   0F           INC       R7
    241              }
    242            }
   \                     ??bindCapacity_2:
   \   00001C   0E           INC       R6
   \                     ??bindCapacity_0:
   \   00001D   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000020   E4           CLR       A
   \   000021   93           MOVC      A,@A+DPTR
   \   000022   F8           MOV       R0,A
   \   000023   EE           MOV       A,R6
   \   000024   C3           CLR       C
   \   000025   98           SUBB      A,R0
   \   000026   40E3         JC        ??bindCapacity_1
    243          
    244            *maxEntries = gNWK_MAX_BINDING_ENTRIES;
   \   000028   E4           CLR       A
   \   000029   93           MOVC      A,@A+DPTR
   \   00002A   8A82         MOV       DPL,R2
   \   00002C   8B83         MOV       DPH,R3
   \   00002E   F0           MOVX      @DPTR,A
   \   00002F   A3           INC       DPTR
   \   000030   E4           CLR       A
   \   000031   F0           MOVX      @DPTR,A
    245            *usedEntries = used;
   \   000032   EF           MOV       A,R7
   \   000033   8C82         MOV       DPL,R4
   \   000035   8D83         MOV       DPH,R5
   \   000037   F0           MOVX      @DPTR,A
   \   000038   A3           INC       DPTR
   \   000039   E4           CLR       A
   \   00003A   F0           MOVX      @DPTR,A
    246          }
   \   00003B   02....       LJMP      ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    247          
    248          /*********************************************************************
    249           * @fn      bindAddEntry()
    250           *
    251           * @brief   This function is used to Add an entry to the binding table
    252           *
    253           * @param       srcEpInt - source endpoint
    254           * @param       dstAddr - destination Address
    255           * @param       dstEpInt - destination endpoint
    256           * @param       numClusterIds - number of cluster Ids in the list
    257           * @param       clusterIds - pointer to the Object ID list
    258           *
    259           * @return  pointer to binding table entry, NULL if not added
    260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    261          BindingEntry_t *bindAddEntry( byte srcEpInt,
   \                     bindAddEntry:
    262                                        zAddrType_t *dstAddr, byte dstEpInt,
    263                                        byte numClusterIds, uint16 *clusterIds )
    264          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV       A,#-0x14
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V7,R1
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
   \   00000B   8C..         MOV       ?V8,R4
   \   00000D   8D..         MOV       ?V0,R5
    265            uint8            index;
    266            bindTableIndex_t bindIdx;
    267            BindingEntry_t*  entry;
    268            bindFields_t     fields;
    269          
    270            // initialize results
    271            entry = NULL;
   \   00000F   7E00         MOV       R6,#0x0
   \   000011   7F00         MOV       R7,#0x0
    272          
    273            // make sure local addresses have been loaded
    274            bindAddrMgrLocalLoad();
   \   000013                ; Setup parameters for call to function bindAddrMgrLocalLoad
   \   000013   12....       LCALL     `??bindAddrMgrLocalLoad::?relay`; Banked call to: bindAddrMgrLocalLoad
    275          
    276            // setup fields
    277            fields.dstIndex = bindAddrIndexGet( dstAddr );
   \   000016                ; Setup parameters for call to function bindAddrIndexGet
   \   000016   AA..         MOV       R2,?V2
   \   000018   AB..         MOV       R3,?V3
   \   00001A   12....       LCALL     `??bindAddrIndexGet::?relay`; Banked call to: bindAddrIndexGet
   \   00001D   8A..         MOV       ?V4,R2
   \   00001F   8B..         MOV       ?V5,R3
    278            fields.srcEP    = srcEpInt;
    279          
    280            if ( dstAddr->addrMode == AddrGroup )
   \   000021   85..82       MOV       DPL,?V2
   \   000024   85..83       MOV       DPH,?V3
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   6401         XRL       A,#0x1
   \   000032   7008         JNZ       ??bindAddEntry_0
    281            {
    282              fields.dstAddrMode = DSTGROUPMODE_GROUP;
   \   000034   75..01       MOV       ?V6,#0x1
    283              fields.dstEP       = 0;
   \   000037   75..00       MOV       ?V1,#0x0
   \   00003A   8006         SJMP      ??bindAddEntry_1
    284            }
    285            else
    286            {
    287              fields.dstAddrMode = DSTGROUPMODE_ADDR;
   \                     ??bindAddEntry_0:
   \   00003C   75..00       MOV       ?V6,#0x0
    288              fields.dstEP       = dstEpInt;
   \   00003F   85....       MOV       ?V1,?V8
    289            }
    290          
    291            if ( fields.dstIndex != INVALID_NODE_ADDR  )
   \                     ??bindAddEntry_1:
   \   000042   74FE         MOV       A,#-0x2
   \   000044   65..         XRL       A,?V4
   \   000046   7004         JNZ       ??bindAddEntry_2
   \   000048   74FF         MOV       A,#-0x1
   \   00004A   65..         XRL       A,?V5
   \                     ??bindAddEntry_2:
   \   00004C   7003         JNZ       $+5
   \   00004E   02....       LJMP      ??bindAddEntry_3 & 0xFFFF
    292            {
    293              for ( bindIdx = 0; bindIdx < gNWK_MAX_BINDING_ENTRIES; bindIdx++ )
   \   000051   7A00         MOV       R2,#0x0
   \   000053   7414         MOV       A,#0x14
   \   000055   12....       LCALL     ?XSTACK_DISP0_8
   \   000058   E0           MOVX      A,@DPTR
   \   000059   F5..         MOV       ?V2,A
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   F5..         MOV       ?V3,A
   \   00005F   8001         SJMP      ??bindAddEntry_4
   \                     ??bindAddEntry_5:
   \   000061   0A           INC       R2
   \                     ??bindAddEntry_4:
   \   000062   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000065   E4           CLR       A
   \   000066   93           MOVC      A,@A+DPTR
   \   000067   F8           MOV       R0,A
   \   000068   EA           MOV       A,R2
   \   000069   C3           CLR       C
   \   00006A   98           SUBB      A,R0
   \   00006B   5059         JNC       ??bindAddEntry_6
    294              {
    295                if ( ( fields.srcEP       == BindingTable[bindIdx].srcEP        ) &&
    296                     ( fields.dstAddrMode == BindingTable[bindIdx].dstGroupMode ) &&
    297                     ( fields.dstIndex    == BindingTable[bindIdx].dstIdx       ) &&
    298                     ( fields.dstEP       == BindingTable[bindIdx].dstEP        )    )
   \   00006D   EA           MOV       A,R2
   \   00006E   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000071   65..         XRL       A,?V7
   \   000073   70EC         JNZ       ??bindAddEntry_5
   \   000075   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000078   65..         XRL       A,?V6
   \   00007A   70E5         JNZ       ??bindAddEntry_5
   \   00007C   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00007F   65..         XRL       A,?V4
   \   000081   7004         JNZ       ??bindAddEntry_7
   \   000083   A3           INC       DPTR
   \   000084   E0           MOVX      A,@DPTR
   \   000085   65..         XRL       A,?V5
   \                     ??bindAddEntry_7:
   \   000087   70D8         JNZ       ??bindAddEntry_5
   \   000089   74..         MOV       A,#(BindingTable + 4) & 0xff
   \   00008B   28           ADD       A,R0
   \   00008C   F582         MOV       DPL,A
   \   00008E   74..         MOV       A,#((BindingTable + 4) >> 8) & 0xff
   \   000090   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000093   65..         XRL       A,?V1
   \   000095   70CA         JNZ       ??bindAddEntry_5
    299                {
    300                  entry = &BindingTable[bindIdx];
   \   000097   74..         MOV       A,#BindingTable & 0xff
   \   000099   28           ADD       A,R0
   \   00009A   FE           MOV       R6,A
   \   00009B   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00009D   39           ADDC      A,R1
   \   00009E   FF           MOV       R7,A
    301          
    302                  // break from loop
    303                  break;
    304                }
    305              }
    306          
    307              if ( entry != NULL )
    308              {
    309                // Loop through the cluster IDs
    310                for ( index = 0; index < numClusterIds; index++ )
   \   00009F   75..00       MOV       ?V4,#0x0
   \                     ??bindAddEntry_8:
   \   0000A2   E5..         MOV       A,?V4
   \   0000A4   C3           CLR       C
   \   0000A5   95..         SUBB      A,?V0
   \   0000A7   4003         JC        $+5
   \   0000A9   02....       LJMP      ??bindAddEntry_3 & 0xFFFF
    311                {
    312                  // Found - is the cluster already defined?
    313                  if ( bindIsClusterIDinList( entry, clusterIds[index] ) == FALSE )
   \   0000AC                ; Setup parameters for call to function bindIsClusterIDinList
   \   0000AC   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000AF   12....       LCALL     `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   0000B2   E9           MOV       A,R1
   \   0000B3   700D         JNZ       ??bindAddEntry_9
    314                  {
    315                    // Nope, add this cluster
    316                    if ( bindAddClusterIdToList( entry, clusterIds[index] ) == FALSE )
   \   0000B5                ; Setup parameters for call to function bindAddClusterIdToList
   \   0000B5   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000B8   12....       LCALL     `??bindAddClusterIdToList::?relay`; Banked call to: bindAddClusterIdToList
   \   0000BB   E9           MOV       A,R1
   \   0000BC   7004         JNZ       ??bindAddEntry_9
    317                    {
    318                      // Indicate error if cluster list was full
    319                      entry = NULL;
   \   0000BE   7E00         MOV       R6,#0x0
   \   0000C0   7F00         MOV       R7,#0x0
    320                    }
    321                  }
    322                }
   \                     ??bindAddEntry_9:
   \   0000C2   05..         INC       ?V4
   \   0000C4   80DC         SJMP      ??bindAddEntry_8
    323              }
    324              else
    325              {
    326                // Find an empty slot
    327                entry = bindFindEmpty();
   \                     ??bindAddEntry_6:
   \   0000C6                ; Setup parameters for call to function bindFindEmpty
   \   0000C6   12....       LCALL     `??bindFindEmpty::?relay`; Banked call to: bindFindEmpty
   \   0000C9   8A..         MOV       ?V10,R2
   \   0000CB   8B..         MOV       ?V11,R3
   \   0000CD   AE..         MOV       R6,?V10
   \   0000CF   AF..         MOV       R7,?V11
    328          
    329                // Check against the maximum number allowed
    330                if ( entry != NULL )
   \   0000D1   EE           MOV       A,R6
   \   0000D2   4F           ORL       A,R7
   \   0000D3   6062         JZ        ??bindAddEntry_3
    331                {
    332                  // Add new entry
    333                  entry->srcEP         = fields.srcEP;
   \   0000D5   8E82         MOV       DPL,R6
   \   0000D7   8F83         MOV       DPH,R7
   \   0000D9   E5..         MOV       A,?V7
   \   0000DB   F0           MOVX      @DPTR,A
    334                  entry->dstGroupMode  = fields.dstAddrMode;
   \   0000DC   A3           INC       DPTR
   \   0000DD   E5..         MOV       A,?V6
   \   0000DF   F0           MOVX      @DPTR,A
    335                  entry->dstIdx        = fields.dstIndex;
   \   0000E0   8E82         MOV       DPL,R6
   \   0000E2   8F83         MOV       DPH,R7
   \   0000E4   A3           INC       DPTR
   \   0000E5   A3           INC       DPTR
   \   0000E6   E5..         MOV       A,?V4
   \   0000E8   F0           MOVX      @DPTR,A
   \   0000E9   A3           INC       DPTR
   \   0000EA   E5..         MOV       A,?V5
   \   0000EC   F0           MOVX      @DPTR,A
    336                  entry->dstEP         = fields.dstEP;
   \   0000ED   8E82         MOV       DPL,R6
   \   0000EF   8F83         MOV       DPH,R7
   \   0000F1   A3           INC       DPTR
   \   0000F2   A3           INC       DPTR
   \   0000F3   A3           INC       DPTR
   \   0000F4   A3           INC       DPTR
   \   0000F5   E5..         MOV       A,?V1
   \   0000F7   F0           MOVX      @DPTR,A
    337          
    338                  if ( numClusterIds > gMAX_BINDING_CLUSTER_IDS )
   \   0000F8   90....       MOV       DPTR,#gMAX_BINDING_CLUSTER_IDS
   \   0000FB   E4           CLR       A
   \   0000FC   93           MOVC      A,@A+DPTR
   \   0000FD   C3           CLR       C
   \   0000FE   95..         SUBB      A,?V0
   \   000100   5004         JNC       ??bindAddEntry_10
    339                  {
    340                    numClusterIds = gMAX_BINDING_CLUSTER_IDS;
   \   000102   E4           CLR       A
   \   000103   93           MOVC      A,@A+DPTR
   \   000104   F5..         MOV       ?V0,A
    341                  }
    342          
    343                  entry->numClusterIds = numClusterIds;
   \                     ??bindAddEntry_10:
   \   000106   8E82         MOV       DPL,R6
   \   000108   8F83         MOV       DPH,R7
   \   00010A   A3           INC       DPTR
   \   00010B   A3           INC       DPTR
   \   00010C   A3           INC       DPTR
   \   00010D   A3           INC       DPTR
   \   00010E   A3           INC       DPTR
   \   00010F   E5..         MOV       A,?V0
   \   000111   F0           MOVX      @DPTR,A
    344          
    345                  osal_memcpy( entry->clusterIdList,
    346                               clusterIds,
    347                               numClusterIds * sizeof(uint16) );
   \   000112                ; Setup parameters for call to function osal_memcpy
   \   000112   85....       MOV       ?V4,?V2
   \   000115   85....       MOV       ?V5,?V3
   \   000118   75..00       MOV       ?V6,#0x0
   \   00011B   78..         MOV       R0,#?V4
   \   00011D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000120   AC..         MOV       R4,?V0
   \   000122   EC           MOV       A,R4
   \   000123   2C           ADD       A,R4
   \   000124   FC           MOV       R4,A
   \   000125   E4           CLR       A
   \   000126   33           RLC       A
   \   000127   FD           MOV       R5,A
   \   000128   EE           MOV       A,R6
   \   000129   2406         ADD       A,#0x6
   \   00012B   FA           MOV       R2,A
   \   00012C   E4           CLR       A
   \   00012D   3F           ADDC      A,R7
   \   00012E   FB           MOV       R3,A
   \   00012F   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000132   7403         MOV       A,#0x3
   \   000134   12....       LCALL     ?DEALLOC_XSTACK8
    348                }
    349              }
    350            }
    351          
    352            return entry;
   \                     ??bindAddEntry_3:
   \   000137   EE           MOV       A,R6
   \   000138   FA           MOV       R2,A
   \   000139   EF           MOV       A,R7
   \   00013A   FB           MOV       R3,A
   \   00013B   7F0C         MOV       R7,#0xc
   \   00013D   02....       LJMP      ?BANKED_LEAVE_XDATA
    353          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   A8..         MOV       R0,?V4
   \   000002   E8           MOV       A,R0
   \   000003   28           ADD       A,R0
   \   000004   F8           MOV       R0,A
   \   000005   E4           CLR       A
   \   000006   33           RLC       A
   \   000007   F9           MOV       R1,A
   \   000008   E5..         MOV       A,?V2
   \   00000A   28           ADD       A,R0
   \   00000B   F582         MOV       DPL,A
   \   00000D   E5..         MOV       A,?V3
   \   00000F   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000012   FC           MOV       R4,A
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   FD           MOV       R5,A
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   FB           MOV       R3,A
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   74..         MOV       A,#(BindingTable + 1) & 0xff
   \   000002   28           ADD       A,R0
   \   000003   F582         MOV       DPL,A
   \   000005   74..         MOV       A,#((BindingTable + 1) >> 8) & 0xff
   \   000007   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   74..         MOV       A,#(BindingTable + 2) & 0xff
   \   000002   28           ADD       A,R0
   \   000003   F582         MOV       DPL,A
   \   000005   74..         MOV       A,#((BindingTable + 2) >> 8) & 0xff
   \   000007   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00000A   22           RET
    354          
    355          /*********************************************************************
    356           * @fn      bindRemoveEntry
    357           *
    358           * @brief   Removes a binding table entry.
    359           *
    360           * @param   pBind - pointer to binding table entry to delete
    361           *
    362           * @return  TRUE if Removed, FALSE if not
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          byte bindRemoveEntry( BindingEntry_t *pBind )
   \                     bindRemoveEntry:
    365          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    366            osal_memset( pBind, 0xFF, gBIND_REC_SIZE );
   \   000004                ; Setup parameters for call to function osal_memset
   \   000004   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000007   79FF         MOV       R1,#-0x1
   \   000009   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    367            return ( TRUE );
   \   00000C   7901         MOV       R1,#0x1
   \   00000E   02....       LJMP      ??Subroutine41_0 & 0xFFFF
    368          }
    369          
    370          /*********************************************************************
    371           * @fn      bindIsClusterIDinList()
    372           *
    373           * @brief   Is the clusterID in the clusterID list?
    374           *
    375           * @param   enter - binding table entry
    376           * @param   clusterId  - Cluster ID to look for
    377           *
    378           * @return  TRUE if found, FALSE if not found
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          byte bindIsClusterIDinList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindIsClusterIDinList:
    381          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    382            uint8 x;
    383          
    384            if ( entry != NULL )
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   6037         JZ        ??bindIsClusterIDinList_0
    385            {
    386              for ( x = 0; x < entry->numClusterIds; x++ )
   \   000009   7E00         MOV       R6,#0x0
   \   00000B   8001         SJMP      ??bindIsClusterIDinList_1
   \                     ??bindIsClusterIDinList_2:
   \   00000D   0E           INC       R6
   \                     ??bindIsClusterIDinList_1:
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   E0           MOVX      A,@DPTR
   \   000018   F8           MOV       R0,A
   \   000019   EE           MOV       A,R6
   \   00001A   C3           CLR       C
   \   00001B   98           SUBB      A,R0
   \   00001C   5022         JNC       ??bindIsClusterIDinList_0
    387              {
    388                if ( entry->clusterIdList[x] == clusterId )
   \   00001E   EE           MOV       A,R6
   \   00001F   25E0         ADD       A,0xE0 /* A   */
   \   000021   F8           MOV       R0,A
   \   000022   E4           CLR       A
   \   000023   33           RLC       A
   \   000024   F9           MOV       R1,A
   \   000025   EA           MOV       A,R2
   \   000026   28           ADD       A,R0
   \   000027   F582         MOV       DPL,A
   \   000029   EB           MOV       A,R3
   \   00002A   39           ADDC      A,R1
   \   00002B   F583         MOV       DPH,A
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6C           XRL       A,R4
   \   000035   7003         JNZ       ??bindIsClusterIDinList_3
   \   000037   A3           INC       DPTR
   \   000038   E0           MOVX      A,@DPTR
   \   000039   6D           XRL       A,R5
   \                     ??bindIsClusterIDinList_3:
   \   00003A   70D1         JNZ       ??bindIsClusterIDinList_2
    389                {
    390                  return ( TRUE );
   \   00003C   7901         MOV       R1,#0x1
   \   00003E   8002         SJMP      ??bindIsClusterIDinList_4
    391                }
    392              }
    393            }
    394          
    395            return ( FALSE );
   \                     ??bindIsClusterIDinList_0:
   \   000040   7900         MOV       R1,#0x0
   \                     ??bindIsClusterIDinList_4:
   \   000042   02....       LJMP      ?Subroutine2 & 0xFFFF
    396          }
    397          
    398          /*********************************************************************
    399           * @fn      bindRemoveClusterIdFromList()
    400           *
    401           * @brief   Removes a ClusterID from a list of ClusterIDs.
    402           *
    403           * @param   enter - binding table entry
    404           * @param   clusterId  - Cluster ID to look for
    405           *
    406           * @return  TRUE if there are at least 1 clusterID left, FALSE if none
    407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          byte bindRemoveClusterIdFromList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindRemoveClusterIdFromList:
    409          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    410            byte x;
    411            uint16 *listPtr;
    412            byte numIds;
    413          
    414            if ( entry )
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   607B         JZ        ??bindRemoveClusterIdFromList_0
    415            {
    416              if ( entry->numClusterIds > 0 )
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   E0           MOVX      A,@DPTR
   \   000013   606F         JZ        ??bindRemoveClusterIdFromList_0
    417              {
    418                listPtr = entry->clusterIdList;
   \   000015   EA           MOV       A,R2
   \   000016   2406         ADD       A,#0x6
   \   000018   F8           MOV       R0,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   F9           MOV       R1,A
    419                numIds = entry->numClusterIds;
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   8B83         MOV       DPH,R3
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   F5..         MOV       ?V1,A
    420          
    421                // Copy the new list over
    422                for ( x = 0; x < numIds; x++ )
   \   000028   75..00       MOV       ?V0,#0x0
   \   00002B   800F         SJMP      ??bindRemoveClusterIdFromList_1
    423                {
    424                  if ( entry->clusterIdList[x] != clusterId )
    425                  {
    426                    *listPtr++ = entry->clusterIdList[x];
    427                  }
    428                  else
    429                  {
    430                    entry->numClusterIds--;
   \                     ??bindRemoveClusterIdFromList_2:
   \   00002D   EA           MOV       A,R2
   \   00002E   2405         ADD       A,#0x5
   \   000030   F582         MOV       DPL,A
   \   000032   E4           CLR       A
   \   000033   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000036   14           DEC       A
   \   000037   F0           MOVX      @DPTR,A
    431                    if ( entry->numClusterIds == 0 )
   \   000038   604A         JZ        ??bindRemoveClusterIdFromList_0
    432                    {
    433                      break;
    434                    }
    435                  }
   \                     ??bindRemoveClusterIdFromList_3:
   \   00003A   05..         INC       ?V0
   \                     ??bindRemoveClusterIdFromList_1:
   \   00003C   E5..         MOV       A,?V0
   \   00003E   C3           CLR       C
   \   00003F   95..         SUBB      A,?V1
   \   000041   5031         JNC       ??bindRemoveClusterIdFromList_4
   \   000043   AE..         MOV       R6,?V0
   \   000045   EE           MOV       A,R6
   \   000046   2E           ADD       A,R6
   \   000047   FE           MOV       R6,A
   \   000048   E4           CLR       A
   \   000049   33           RLC       A
   \   00004A   FF           MOV       R7,A
   \   00004B   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00004E   6C           XRL       A,R4
   \   00004F   7003         JNZ       ??bindRemoveClusterIdFromList_5
   \   000051   A3           INC       DPTR
   \   000052   E0           MOVX      A,@DPTR
   \   000053   6D           XRL       A,R5
   \                     ??bindRemoveClusterIdFromList_5:
   \   000054   60D7         JZ        ??bindRemoveClusterIdFromList_2
   \   000056   AE..         MOV       R6,?V0
   \   000058   EE           MOV       A,R6
   \   000059   2E           ADD       A,R6
   \   00005A   FE           MOV       R6,A
   \   00005B   12....       LCALL     ?Subroutine25 & 0xFFFF
    436                }
    437              }
    438            }
   \                     ??CrossCallReturnLabel_44:
   \   00005E   FE           MOV       R6,A
   \   00005F   A3           INC       DPTR
   \   000060   E0           MOVX      A,@DPTR
   \   000061   FF           MOV       R7,A
   \   000062   8882         MOV       DPL,R0
   \   000064   8983         MOV       DPH,R1
   \   000066   EE           MOV       A,R6
   \   000067   F0           MOVX      @DPTR,A
   \   000068   A3           INC       DPTR
   \   000069   EF           MOV       A,R7
   \   00006A   F0           MOVX      @DPTR,A
   \   00006B   E8           MOV       A,R0
   \   00006C   2402         ADD       A,#0x2
   \   00006E   F8           MOV       R0,A
   \   00006F   50C9         JNC       ??bindRemoveClusterIdFromList_3
   \   000071   09           INC       R1
   \   000072   80C6         SJMP      ??bindRemoveClusterIdFromList_3
   \                     ??bindRemoveClusterIdFromList_4:
   \   000074   8A82         MOV       DPL,R2
   \   000076   8B83         MOV       DPH,R3
   \   000078   A3           INC       DPTR
   \   000079   A3           INC       DPTR
   \   00007A   A3           INC       DPTR
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   6004         JZ        ??bindRemoveClusterIdFromList_0
    439          
    440            if ( entry && (entry->numClusterIds > 0) )
    441            {
    442              return ( TRUE );
   \   000080   7901         MOV       R1,#0x1
   \   000082   8002         SJMP      ??bindRemoveClusterIdFromList_6
    443            }
    444            else
    445            {
    446              return ( FALSE );
   \                     ??bindRemoveClusterIdFromList_0:
   \   000084   7900         MOV       R1,#0x0
   \                     ??bindRemoveClusterIdFromList_6:
   \   000086   7F03         MOV       R7,#0x3
   \   000088   02....       LJMP      ?BANKED_LEAVE_XDATA
    447            }
    448          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   EA           MOV       A,R2
   \   000001   2E           ADD       A,R6
   \   000002   F582         MOV       DPL,A
   \   000004   EB           MOV       A,R3
   \   000005   3F           ADDC      A,R7
   \   000006   F583         MOV       DPH,A
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   3B           ADDC      A,R3
   \   000001   F583         MOV       DPH,A
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET
    449          
    450          /*********************************************************************
    451           * @fn      bindAddClusterIdToList()
    452           *
    453           * @brief   Adds a ClusterID to a list of ClusterIDs.
    454           *
    455           * @param   enter - binding table entry
    456           * @param   clusterId  - Cluster ID to Add
    457           *
    458           * @return  TRUE if Added, FALSE if not
    459           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    460          byte bindAddClusterIdToList( BindingEntry_t *entry, uint16 clusterId )
   \                     bindAddClusterIdToList:
    461          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    462            if ( entry && entry->numClusterIds < gMAX_BINDING_CLUSTER_IDS )
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   6039         JZ        ??bindAddClusterIdToList_0
   \   000009   90....       MOV       DPTR,#gMAX_BINDING_CLUSTER_IDS
   \   00000C   E4           CLR       A
   \   00000D   93           MOVC      A,@A+DPTR
   \   00000E   F8           MOV       R0,A
   \   00000F   8A82         MOV       DPL,R2
   \   000011   8B83         MOV       DPH,R3
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   C3           CLR       C
   \   00001A   98           SUBB      A,R0
   \   00001B   5025         JNC       ??bindAddClusterIdToList_0
    463            {
    464              // Add the new one
    465              entry->clusterIdList[entry->numClusterIds] = clusterId;
   \   00001D   EA           MOV       A,R2
   \   00001E   2405         ADD       A,#0x5
   \   000020   F8           MOV       R0,A
   \   000021   E4           CLR       A
   \   000022   3B           ADDC      A,R3
   \   000023   F9           MOV       R1,A
   \   000024   8882         MOV       DPL,R0
   \   000026   8983         MOV       DPH,R1
   \   000028   E0           MOVX      A,@DPTR
   \   000029   25E0         ADD       A,0xE0 /* A   */
   \   00002B   FE           MOV       R6,A
   \   00002C   E4           CLR       A
   \   00002D   33           RLC       A
   \   00002E   FF           MOV       R7,A
   \   00002F   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000032   EC           MOV       A,R4
   \   000033   F0           MOVX      @DPTR,A
   \   000034   A3           INC       DPTR
   \   000035   ED           MOV       A,R5
   \   000036   F0           MOVX      @DPTR,A
    466              entry->numClusterIds++;
   \   000037   8882         MOV       DPL,R0
   \   000039   8983         MOV       DPH,R1
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   04           INC       A
   \   00003D   F0           MOVX      @DPTR,A
    467              return ( TRUE );
   \   00003E   7901         MOV       R1,#0x1
   \   000040   8002         SJMP      ??bindAddClusterIdToList_1
    468            }
    469            return ( FALSE );
   \                     ??bindAddClusterIdToList_0:
   \   000042   7900         MOV       R1,#0x0
   \                     ??bindAddClusterIdToList_1:
   \   000044                REQUIRE ?Subroutine2
   \   000044                ; // Fall through to label ?Subroutine2
    470          }
    471          
    472          /*********************************************************************
    473           * @fn      bindFindExisting
    474           *
    475           * @brief   Finds an existing src/epint to dst/epint bind record
    476           *
    477           * @param   srcEpInt - Source Endpoint/Interface
    478           * @param   dstAddr - Destination address
    479           * @param   dstEpInt - Destination Endpoint/Interface
    480           *
    481           * @return  pointer to existing entry or NULL
    482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    483          BindingEntry_t *bindFindExisting( byte srcEpInt,
   \                     bindFindExisting:
    484                                            zAddrType_t *dstAddr, byte dstEpInt )
    485          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V0,R1
   \   000007   EA           MOV       A,R2
   \   000008   FE           MOV       R6,A
   \   000009   EB           MOV       A,R3
   \   00000A   FF           MOV       R7,A
   \   00000B   8C..         MOV       ?V1,R4
    486            uint16 dstIdx;
    487            bindTableIndex_t x;
    488          
    489            // Find the records in the assoc list
    490            if ( dstAddr->addrMode == AddrGroup )
   \   00000D   8E82         MOV       DPL,R6
   \   00000F   8F83         MOV       DPH,R7
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   6401         XRL       A,#0x1
   \   00001C   7009         JNZ       ??bindFindExisting_0
    491            {
    492              dstIdx = dstAddr->addr.shortAddr;
   \   00001E   8E82         MOV       DPL,R6
   \   000020   8F83         MOV       DPH,R7
   \   000022   12....       LCALL     ?Subroutine22 & 0xFFFF
    493            }
   \                     ??CrossCallReturnLabel_36:
   \   000025   800B         SJMP      ??bindFindExisting_1
    494            else
    495            {
    496              dstIdx = bindingAddrMgsHelperFind( dstAddr );
   \                     ??bindFindExisting_0:
   \   000027                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000027   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   00002A   8A..         MOV       ?V2,R2
   \   00002C   8B..         MOV       ?V3,R3
   \   00002E   A8..         MOV       R0,?V2
   \   000030   A9..         MOV       R1,?V3
    497            }
    498          
    499            if ( dstIdx == INVALID_NODE_ADDR )
   \                     ??bindFindExisting_1:
   \   000032   74FE         MOV       A,#-0x2
   \   000034   68           XRL       A,R0
   \   000035   7003         JNZ       ??bindFindExisting_2
   \   000037   74FF         MOV       A,#-0x1
   \   000039   69           XRL       A,R1
   \                     ??bindFindExisting_2:
   \   00003A   7003         JNZ       $+5
   \   00003C   02....       LJMP      ??bindFindExisting_3 & 0xFFFF
    500            {
    501              return ( (BindingEntry_t *)NULL );
    502            }
    503          
    504            // Start at the beginning
    505            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00003F   7C00         MOV       R4,#0x0
   \   000041   801A         SJMP      ??bindFindExisting_4
    506            {
    507              if ( (BindingTable[x].srcEP == srcEpInt) )
    508              {
    509                if ( ((dstAddr->addrMode == AddrGroup)
    510                        && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
    511                        && (dstIdx == BindingTable[x].dstIdx))
    512                   || ((dstAddr->addrMode != AddrGroup)
    513                       && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
    514                       && (dstIdx == BindingTable[x].dstIdx) && (BindingTable[x].dstEP == dstEpInt)) )
   \                     ??bindFindExisting_5:
   \   000043   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000046   6401         XRL       A,#0x1
   \   000048   7012         JNZ       ??bindFindExisting_6
   \   00004A   74..         MOV       A,#(BindingTable + 2) & 0xff
   \   00004C   2A           ADD       A,R2
   \   00004D   F582         MOV       DPL,A
   \   00004F   74..         MOV       A,#((BindingTable + 2) >> 8) & 0xff
   \   000051   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000054   68           XRL       A,R0
   \   000055   7003         JNZ       ??bindFindExisting_7
   \   000057   A3           INC       DPTR
   \   000058   E0           MOVX      A,@DPTR
   \   000059   69           XRL       A,R1
   \                     ??bindFindExisting_7:
   \   00005A   605A         JZ        ??bindFindExisting_8
   \                     ??bindFindExisting_6:
   \   00005C   0C           INC       R4
   \                     ??bindFindExisting_4:
   \   00005D   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000060   E4           CLR       A
   \   000061   93           MOVC      A,@A+DPTR
   \   000062   FA           MOV       R2,A
   \   000063   EC           MOV       A,R4
   \   000064   C3           CLR       C
   \   000065   9A           SUBB      A,R2
   \   000066   505A         JNC       ??bindFindExisting_3
   \   000068   EC           MOV       A,R4
   \   000069   75F00E       MOV       B,#0xe
   \   00006C   A4           MUL       AB
   \   00006D   FA           MOV       R2,A
   \   00006E   ADF0         MOV       R5,B
   \   000070   ED           MOV       A,R5
   \   000071   FB           MOV       R3,A
   \   000072   74..         MOV       A,#BindingTable & 0xff
   \   000074   2A           ADD       A,R2
   \   000075   F582         MOV       DPL,A
   \   000077   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000079   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00007C   65..         XRL       A,?V0
   \   00007E   70DC         JNZ       ??bindFindExisting_6
   \   000080   8E82         MOV       DPL,R6
   \   000082   8F83         MOV       DPH,R7
   \   000084   A3           INC       DPTR
   \   000085   A3           INC       DPTR
   \   000086   A3           INC       DPTR
   \   000087   A3           INC       DPTR
   \   000088   A3           INC       DPTR
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   A3           INC       DPTR
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   6401         XRL       A,#0x1
   \   00008F   60B2         JZ        ??bindFindExisting_5
   \   000091   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000094   70C6         JNZ       ??bindFindExisting_6
   \   000096   74..         MOV       A,#(BindingTable + 2) & 0xff
   \   000098   2A           ADD       A,R2
   \   000099   F582         MOV       DPL,A
   \   00009B   74..         MOV       A,#((BindingTable + 2) >> 8) & 0xff
   \   00009D   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000A0   68           XRL       A,R0
   \   0000A1   7003         JNZ       ??bindFindExisting_9
   \   0000A3   A3           INC       DPTR
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   69           XRL       A,R1
   \                     ??bindFindExisting_9:
   \   0000A6   70B4         JNZ       ??bindFindExisting_6
   \   0000A8   74..         MOV       A,#(BindingTable + 4) & 0xff
   \   0000AA   2A           ADD       A,R2
   \   0000AB   F582         MOV       DPL,A
   \   0000AD   74..         MOV       A,#((BindingTable + 4) >> 8) & 0xff
   \   0000AF   12....       LCALL     ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000B2   65..         XRL       A,?V1
   \   0000B4   70A6         JNZ       ??bindFindExisting_6
    515                {
    516                  return ( &BindingTable[x] );
   \                     ??bindFindExisting_8:
   \   0000B6   ED           MOV       A,R5
   \   0000B7   F9           MOV       R1,A
   \   0000B8   74..         MOV       A,#BindingTable & 0xff
   \   0000BA   2A           ADD       A,R2
   \   0000BB   FA           MOV       R2,A
   \   0000BC   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   0000BE   39           ADDC      A,R1
   \   0000BF   FB           MOV       R3,A
   \   0000C0   8004         SJMP      ??bindFindExisting_10
    517                }
    518              }
    519            }
    520          
    521            return ( (BindingEntry_t *)NULL );
   \                     ??bindFindExisting_3:
   \   0000C2   7A00         MOV       R2,#0x0
   \   0000C4   7B00         MOV       R3,#0x0
   \                     ??bindFindExisting_10:
   \   0000C6   80..         SJMP      ??Subroutine36_0
    522          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   74..         MOV       A,#(BindingTable + 1) & 0xff
   \   000002   2A           ADD       A,R2
   \   000003   F582         MOV       DPL,A
   \   000005   74..         MOV       A,#((BindingTable + 1) >> 8) & 0xff
   \   000007                REQUIRE ??Subroutine35_0
   \   000007                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    523          
    524          /*********************************************************************
    525           * @fn       bindRemoveDev()
    526           *
    527           * @brief
    528           *
    529           *   Remove all bind(s) entries associated to a device address (destination).
    530           *   Updates binding table.
    531           *
    532           * @param   Addr - address of device to be removed from Binding Table
    533           *
    534           * @return  none
    535           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    536          void bindRemoveDev( zAddrType_t *Addr )
   \                     bindRemoveDev:
    537          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    538            uint16 idx;
    539            bindTableIndex_t x;
    540          
    541            if ( Addr->addrMode == AddrGroup )
   \   000009   8E82         MOV       DPL,R6
   \   00000B   8F83         MOV       DPH,R7
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   6401         XRL       A,#0x1
   \   000018   700D         JNZ       ??bindRemoveDev_0
    542            {
    543              idx = Addr->addr.shortAddr;
   \   00001A   8E82         MOV       DPL,R6
   \   00001C   8F83         MOV       DPH,R7
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   F5..         MOV       ?V0,A
   \   000021   A3           INC       DPTR
   \   000022   E0           MOVX      A,@DPTR
   \   000023   F5..         MOV       ?V1,A
   \   000025   8007         SJMP      ??bindRemoveDev_1
    544            }
    545            else
    546            {
    547              idx = bindingAddrMgsHelperFind( Addr );
   \                     ??bindRemoveDev_0:
   \   000027                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000027   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   00002A   8A..         MOV       ?V0,R2
   \   00002C   8B..         MOV       ?V1,R3
    548            }
    549          
    550            if ( idx == INVALID_NODE_ADDR )
   \                     ??bindRemoveDev_1:
   \   00002E   74FE         MOV       A,#-0x2
   \   000030   65..         XRL       A,?V0
   \   000032   7004         JNZ       ??bindRemoveDev_2
   \   000034   74FF         MOV       A,#-0x1
   \   000036   65..         XRL       A,?V1
   \                     ??bindRemoveDev_2:
   \   000038   605E         JZ        ??bindRemoveDev_3
    551            {
    552              return;
    553            }
    554          
    555            // Removes all the entries that match the destination Address/Index
    556            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00003A   75..00       MOV       ?V2,#0x0
   \   00003D   8021         SJMP      ??bindRemoveDev_4
    557            {
    558              if ( ( (Addr->addrMode == AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
    559                                                   && (BindingTable[x].dstIdx == idx) ) ||
    560                   ( (Addr->addrMode != AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
    561                                                   && (BindingTable[x].dstIdx == idx) ) )
   \                     ??bindRemoveDev_5:
   \   00003F   E5..         MOV       A,?V2
   \   000041   75F00E       MOV       B,#0xe
   \   000044   A4           MUL       AB
   \   000045   F8           MOV       R0,A
   \   000046   A9F0         MOV       R1,B
   \   000048   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00004B   7011         JNZ       ??bindRemoveDev_6
   \   00004D   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000050   7004         JNZ       ??bindRemoveDev_7
   \   000052   A3           INC       DPTR
   \   000053   E0           MOVX      A,@DPTR
   \   000054   65..         XRL       A,?V1
   \                     ??bindRemoveDev_7:
   \   000056   7006         JNZ       ??bindRemoveDev_6
    562              {
    563                bindRemoveEntry( &BindingTable[x] );
   \                     ??bindRemoveDev_8:
   \   000058                ; Setup parameters for call to function bindRemoveEntry
   \   000058   12....       LCALL     ?Subroutine14 & 0xFFFF
    564              }
   \                     ??CrossCallReturnLabel_19:
   \   00005B   12....       LCALL     `??bindRemoveEntry::?relay`; Banked call to: bindRemoveEntry
   \                     ??bindRemoveDev_6:
   \   00005E   05..         INC       ?V2
   \                     ??bindRemoveDev_4:
   \   000060   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000063   E4           CLR       A
   \   000064   93           MOVC      A,@A+DPTR
   \   000065   F8           MOV       R0,A
   \   000066   E5..         MOV       A,?V2
   \   000068   C3           CLR       C
   \   000069   98           SUBB      A,R0
   \   00006A   5025         JNC       ??bindRemoveDev_9
   \   00006C   8E82         MOV       DPL,R6
   \   00006E   8F83         MOV       DPH,R7
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   E0           MOVX      A,@DPTR
   \   000079   6401         XRL       A,#0x1
   \   00007B   70C2         JNZ       ??bindRemoveDev_5
   \   00007D   E5..         MOV       A,?V2
   \   00007F   12....       LCALL     ?Subroutine11 & 0xFFFF
    565            }
   \                     ??CrossCallReturnLabel_11:
   \   000082   70DA         JNZ       ??bindRemoveDev_6
   \   000084   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000087   7004         JNZ       ??bindRemoveDev_10
   \   000089   A3           INC       DPTR
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   65..         XRL       A,?V1
   \                     ??bindRemoveDev_10:
   \   00008D   60C9         JZ        ??bindRemoveDev_8
   \   00008F   80CD         SJMP      ??bindRemoveDev_6
    566          
    567            // If this is the last Bind Entry for that idx then clear BINDING
    568            // user from Address Manager
    569            bindAddressClear( idx );
   \                     ??bindRemoveDev_9:
   \   000091                ; Setup parameters for call to function bindAddressClear
   \   000091   AA..         MOV       R2,?V0
   \   000093   AB..         MOV       R3,?V1
   \   000095   12....       LCALL     `??bindAddressClear::?relay`; Banked call to: bindAddressClear
    570          }
   \                     ??bindRemoveDev_3:
   \   000098   02....       LJMP      ??Subroutine36_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000003   65..         XRL       A,?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00000A   6401         XRL       A,#0x1
   \   00000C   22           RET
    571          
    572          /*********************************************************************
    573           * @fn       bindRemoveSrcDev()
    574           *
    575           * @brief
    576           *
    577           *   Remove binds(s) associated to device address (source).
    578           *   Updates binding table.
    579           *
    580           * @param   ep - endpoint to remove, 0xFF is all endpoints
    581           *
    582           * @return  none
    583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    584          void bindRemoveSrcDev( uint8 ep )
   \                     bindRemoveSrcDev:
    585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V1,R1
    586            bindTableIndex_t x;
    587          
    588            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000007   75..00       MOV       ?V0,#0x0
   \   00000A   8032         SJMP      ??bindRemoveSrcDev_0
    589            {
    590              if ( (ep == 0xFF) || (ep == BindingTable[x].srcEP) )
   \                     ??bindRemoveSrcDev_1:
   \   00000C   74FF         MOV       A,#-0x1
   \   00000E   65..         XRL       A,?V1
   \   000010   6009         JZ        ??bindRemoveSrcDev_2
   \   000012   E5..         MOV       A,?V0
   \   000014   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000017   65..         XRL       A,?V1
   \   000019   7021         JNZ       ??bindRemoveSrcDev_3
    591              {
    592                uint16 idx = BindingTable[x].dstIdx;
   \                     ??bindRemoveSrcDev_2:
   \   00001B   E5..         MOV       A,?V0
   \   00001D   75F00E       MOV       B,#0xe
   \   000020   A4           MUL       AB
   \   000021   F8           MOV       R0,A
   \   000022   A9F0         MOV       R1,B
   \   000024   12....       LCALL     ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000027   8A82         MOV       DPL,R2
   \   000029   8B83         MOV       DPH,R3
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   FE           MOV       R6,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   FF           MOV       R7,A
    593          
    594                bindRemoveEntry( &BindingTable[x] );
   \   000032                ; Setup parameters for call to function bindRemoveEntry
   \   000032   12....       LCALL     `??bindRemoveEntry::?relay`; Banked call to: bindRemoveEntry
    595          
    596                // If this is the last Bind Entry for that idx then clear BINDING
    597                // user from Address Manager
    598                bindAddressClear( idx );
   \   000035                ; Setup parameters for call to function bindAddressClear
   \   000035   EE           MOV       A,R6
   \   000036   FA           MOV       R2,A
   \   000037   EF           MOV       A,R7
   \   000038   FB           MOV       R3,A
   \   000039   12....       LCALL     `??bindAddressClear::?relay`; Banked call to: bindAddressClear
    599              }
    600            }
   \                     ??bindRemoveSrcDev_3:
   \   00003C   05..         INC       ?V0
   \                     ??bindRemoveSrcDev_0:
   \   00003E   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000041   E4           CLR       A
   \   000042   93           MOVC      A,@A+DPTR
   \   000043   F8           MOV       R0,A
   \   000044   E5..         MOV       A,?V0
   \   000046   C3           CLR       C
   \   000047   98           SUBB      A,R0
   \   000048   40C2         JC        ??bindRemoveSrcDev_1
    601          }
   \   00004A   02....       LJMP      ??Subroutine33_0 & 0xFFFF
    602          
    603          /*********************************************************************
    604           * @fn          bindNumBoundTo
    605           *
    606           * @brief       Calculate the number items this device is bound to.
    607           *              When srcMode is set to TRUE, discard what value devAddr
    608           *              has, it returns number count bound to the local dev.
    609           *
    610           * @param       devAddr - device Address
    611           * @param       devEP - endpoint
    612           * @param       srcMode - TRUE - assume devHandle is a source address
    613           *                        FALSE - destination address
    614           *
    615           * @return      status
    616           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    617          byte bindNumBoundTo( zAddrType_t *devAddr, byte devEpInt, byte srcMode )
   \                     bindNumBoundTo:
    618          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   89..         MOV       ?V1,R1
   \   00000B   8C..         MOV       ?V2,R4
    619            BindingEntry_t *pBind;
    620            uint16 idx;
    621            byte   num;
    622            bindTableIndex_t x;
    623          
    624            // Init
    625            num = 0;
   \   00000D   75..00       MOV       ?V0,#0x0
    626          
    627            if ( devAddr->addrMode == AddrGroup )
   \   000010   8E82         MOV       DPL,R6
   \   000012   8F83         MOV       DPH,R7
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   6401         XRL       A,#0x1
   \   00001F   7009         JNZ       ??bindNumBoundTo_0
    628            {
    629              idx = devAddr->addr.shortAddr;
   \   000021   8E82         MOV       DPL,R6
   \   000023   8F83         MOV       DPH,R7
   \   000025   12....       LCALL     ??Subroutine42_0 & 0xFFFF
    630            }
   \                     ??CrossCallReturnLabel_73:
   \   000028   8003         SJMP      ??bindNumBoundTo_1
    631            else
    632            {
    633              idx = bindingAddrMgsHelperFind( devAddr );
   \                     ??bindNumBoundTo_0:
   \   00002A                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   00002A   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
    634            }
    635          
    636            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \                     ??bindNumBoundTo_1:
   \   00002D   7C00         MOV       R4,#0x0
   \   00002F   8022         SJMP      ??bindNumBoundTo_2
    637            {
    638              pBind = &BindingTable[x];
    639              if ( srcMode )
    640              {
    641                if ( pBind->srcEP == devEpInt )
    642                {
    643                  num++;
    644                }
    645              }
    646              else
    647              {
    648                if ( ((devAddr->addrMode == AddrGroup)
    649                        && (pBind->dstGroupMode == DSTGROUPMODE_GROUP) && (pBind->dstIdx == idx))
    650                    || ((devAddr->addrMode != AddrGroup) && (pBind->dstGroupMode == DSTGROUPMODE_ADDR)
    651                                          && (pBind->dstIdx == idx) && (pBind->dstEP == devEpInt)) )
   \                     ??bindNumBoundTo_3:
   \   000031   E0           MOVX      A,@DPTR
   \   000032   701E         JNZ       ??bindNumBoundTo_4
   \   000034   8882         MOV       DPL,R0
   \   000036   8983         MOV       DPH,R1
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   6A           XRL       A,R2
   \   00003C   7003         JNZ       ??bindNumBoundTo_5
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   6B           XRL       A,R3
   \                     ??bindNumBoundTo_5:
   \   000041   700F         JNZ       ??bindNumBoundTo_4
   \   000043   8882         MOV       DPL,R0
   \   000045   8983         MOV       DPH,R1
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   65..         XRL       A,?V1
   \   00004E   7002         JNZ       ??bindNumBoundTo_4
    652                {
    653                  num++;
   \                     ??bindNumBoundTo_6:
   \   000050   05..         INC       ?V0
    654                }
   \                     ??bindNumBoundTo_4:
   \   000052   0C           INC       R4
   \                     ??bindNumBoundTo_2:
   \   000053   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000056   E4           CLR       A
   \   000057   93           MOVC      A,@A+DPTR
   \   000058   F8           MOV       R0,A
   \   000059   EC           MOV       A,R4
   \   00005A   C3           CLR       C
   \   00005B   98           SUBB      A,R0
   \   00005C   503F         JNC       ??bindNumBoundTo_7
   \   00005E   EC           MOV       A,R4
   \   00005F   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000062   E5..         MOV       A,?V2
   \   000064   600B         JZ        ??bindNumBoundTo_8
   \   000066   8882         MOV       DPL,R0
   \   000068   8983         MOV       DPH,R1
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   65..         XRL       A,?V1
   \   00006D   70E3         JNZ       ??bindNumBoundTo_4
   \   00006F   80DF         SJMP      ??bindNumBoundTo_6
   \                     ??bindNumBoundTo_8:
   \   000071   8E82         MOV       DPL,R6
   \   000073   8F83         MOV       DPH,R7
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   A3           INC       DPTR
   \   000079   A3           INC       DPTR
   \   00007A   A3           INC       DPTR
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   6401         XRL       A,#0x1
   \   000080   8882         MOV       DPL,R0
   \   000082   8983         MOV       DPH,R1
   \   000084   A3           INC       DPTR
   \   000085   70AA         JNZ       ??bindNumBoundTo_3
   \   000087   E0           MOVX      A,@DPTR
   \   000088   6401         XRL       A,#0x1
   \   00008A   70C6         JNZ       ??bindNumBoundTo_4
   \   00008C   8882         MOV       DPL,R0
   \   00008E   8983         MOV       DPH,R1
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   E0           MOVX      A,@DPTR
   \   000093   6A           XRL       A,R2
   \   000094   7003         JNZ       ??bindNumBoundTo_9
   \   000096   A3           INC       DPTR
   \   000097   E0           MOVX      A,@DPTR
   \   000098   6B           XRL       A,R3
   \                     ??bindNumBoundTo_9:
   \   000099   60B5         JZ        ??bindNumBoundTo_6
   \   00009B   80B5         SJMP      ??bindNumBoundTo_4
    655              }
    656            }
    657          
    658            return num;
   \                     ??bindNumBoundTo_7:
   \   00009D   A9..         MOV       R1,?V0
   \   00009F   80..         SJMP      ??Subroutine38_0
    659          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   75F00E       MOV       B,#0xe
   \   000003   A4           MUL       AB
   \   000004   F8           MOV       R0,A
   \   000005   A9F0         MOV       R1,B
   \   000007                REQUIRE ??Subroutine37_0
   \   000007                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   74..         MOV       A,#BindingTable & 0xff
   \   000002   28           ADD       A,R0
   \   000003   F8           MOV       R0,A
   \   000004   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000006   39           ADDC      A,R1
   \   000007   F9           MOV       R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET
    660          
    661          /*********************************************************************
    662           * @fn          bindNumReflections
    663           *
    664           * @brief       Counts the number of reflections needed for a
    665           *              endpoint and cluster ID combo.
    666           *
    667           * @param       ep - source endpoint
    668           * @param       clusterID - matching clusterID
    669           *
    670           * @return      number of reflections needed.
    671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    672          uint16 bindNumReflections( uint8 ep, uint16 clusterID )
   \                     bindNumReflections:
    673          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V3,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
    674            bindTableIndex_t x;
    675            BindingEntry_t *pBind;
    676            uint16 cnt = 0;
   \   00000B   7E00         MOV       R6,#0x0
   \   00000D   7F00         MOV       R7,#0x0
    677            uint8 bindEP;
    678          
    679            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00000F   75..00       MOV       ?V2,#0x0
   \   000012   801E         SJMP      ??bindNumReflections_0
    680            {
    681              pBind = &BindingTable[x];
   \                     ??bindNumReflections_1:
   \   000014   E5..         MOV       A,?V2
   \   000016   12....       LCALL     ?Subroutine10 & 0xFFFF
    682              bindEP = pBind->srcEP;
    683          
    684              if ( (bindEP == ep) && (bindIsClusterIDinList( pBind, clusterID )) )
   \                     ??CrossCallReturnLabel_8:
   \   000019   65..         XRL       A,?V3
   \   00001B   7013         JNZ       ??bindNumReflections_2
   \   00001D                ; Setup parameters for call to function bindIsClusterIDinList
   \   00001D   AC..         MOV       R4,?V0
   \   00001F   AD..         MOV       R5,?V1
   \   000021   AA82         MOV       R2,DPL
   \   000023   AB83         MOV       R3,DPH
   \   000025   12....       LCALL     `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   000028   E9           MOV       A,R1
   \   000029   6005         JZ        ??bindNumReflections_2
    685              {
    686                cnt++;
   \   00002B   0E           INC       R6
   \   00002C   EE           MOV       A,R6
   \   00002D   7001         JNZ       ??bindNumReflections_2
   \   00002F   0F           INC       R7
    687              }
    688            }
   \                     ??bindNumReflections_2:
   \   000030   05..         INC       ?V2
   \                     ??bindNumReflections_0:
   \   000032   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000035   E4           CLR       A
   \   000036   93           MOVC      A,@A+DPTR
   \   000037   F8           MOV       R0,A
   \   000038   E5..         MOV       A,?V2
   \   00003A   C3           CLR       C
   \   00003B   98           SUBB      A,R0
   \   00003C   40D6         JC        ??bindNumReflections_1
    689          
    690            return ( cnt );
   \   00003E   EE           MOV       A,R6
   \   00003F   FA           MOV       R2,A
   \   000040   EF           MOV       A,R7
   \   000041   FB           MOV       R3,A
   \   000042   02....       LJMP      ??Subroutine36_0 & 0xFFFF
    691          }
    692          
    693          /*********************************************************************
    694           * @fn          bindFind
    695           *
    696           * @brief       Finds the binding entry for the source address, endpoint
    697           *              and cluster ID passed in as a parameter.
    698           *
    699           * @param       ep - source endpoint
    700           * @param       clusterID - matching clusterID
    701           * @param       skip - number of matches to skip before returning
    702           *
    703           * @return      pointer to the binding table entry, NULL if not found
    704           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    705          BindingEntry_t *bindFind( uint8 ep, uint16 clusterID, uint8 skipping )
   \                     bindFind:
    706          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V0,R2
   \   000009   8B..         MOV       ?V1,R3
   \   00000B   8C..         MOV       ?V5,R4
    707            BindingEntry_t *pBind;
    708            byte skipped = 0;
   \   00000D   75..00       MOV       ?V2,#0x0
    709            bindTableIndex_t x;
    710          
    711            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000010   75..00       MOV       ?V3,#0x0
   \   000013   8004         SJMP      ??bindFind_0
    712            {
    713              pBind = &BindingTable[x];
    714          
    715              if ( ( pBind->srcEP == ep) && bindIsClusterIDinList( pBind, clusterID ))
    716              {
    717                if ( skipped < skipping )
    718                {
    719                  skipped++;
   \                     ??bindFind_1:
   \   000015   05..         INC       ?V2
    720                }
   \                     ??bindFind_2:
   \   000017   05..         INC       ?V3
   \                     ??bindFind_0:
   \   000019   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00001C   E4           CLR       A
   \   00001D   93           MOVC      A,@A+DPTR
   \   00001E   F8           MOV       R0,A
   \   00001F   E5..         MOV       A,?V3
   \   000021   C3           CLR       C
   \   000022   98           SUBB      A,R0
   \   000023   5035         JNC       ??bindFind_3
   \   000025   E5..         MOV       A,?V3
   \   000027   75F00E       MOV       B,#0xe
   \   00002A   A4           MUL       AB
   \   00002B   F8           MOV       R0,A
   \   00002C   A9F0         MOV       R1,B
   \   00002E   74..         MOV       A,#BindingTable & 0xff
   \   000030   28           ADD       A,R0
   \   000031   FE           MOV       R6,A
   \   000032   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000034   39           ADDC      A,R1
   \   000035   FF           MOV       R7,A
   \   000036   8E82         MOV       DPL,R6
   \   000038   8F83         MOV       DPH,R7
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   65..         XRL       A,?V4
   \   00003D   70D8         JNZ       ??bindFind_2
   \   00003F                ; Setup parameters for call to function bindIsClusterIDinList
   \   00003F   AC..         MOV       R4,?V0
   \   000041   AD..         MOV       R5,?V1
   \   000043   EE           MOV       A,R6
   \   000044   FA           MOV       R2,A
   \   000045   EF           MOV       A,R7
   \   000046   FB           MOV       R3,A
   \   000047   12....       LCALL     `??bindIsClusterIDinList::?relay`; Banked call to: bindIsClusterIDinList
   \   00004A   E9           MOV       A,R1
   \   00004B   60CA         JZ        ??bindFind_2
   \   00004D   E5..         MOV       A,?V2
   \   00004F   C3           CLR       C
   \   000050   95..         SUBB      A,?V5
   \   000052   40C1         JC        ??bindFind_1
    721                else
    722                {
    723                  return ( pBind );
   \   000054   EE           MOV       A,R6
   \   000055   FA           MOV       R2,A
   \   000056   EF           MOV       A,R7
   \   000057   FB           MOV       R3,A
   \   000058   8004         SJMP      ??bindFind_4
    724                }
    725              }
    726            }
    727          
    728            return ( (BindingEntry_t *)NULL );
   \                     ??bindFind_3:
   \   00005A   7A00         MOV       R2,#0x0
   \   00005C   7B00         MOV       R3,#0x0
   \                     ??bindFind_4:
   \   00005E   02....       LJMP      ??Subroutine38_0 & 0xFFFF
    729          }
    730          
    731          /*********************************************************************
    732           * @fn      bindAddressClear
    733           *
    734           * @brief   Lookup a binding entry by specific Idx, if none is found
    735           *          clears the BINDING user from Address Manager.
    736           *
    737           * @param   dstIdx - Source Address Manager Index
    738           *
    739           * @return  none
    740           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    741          void bindAddressClear( uint16 dstIdx )
   \                     bindAddressClear:
    742          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    743            bindTableIndex_t i;
    744          
    745            if ( dstIdx != INVALID_NODE_ADDR )
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   6A           XRL       A,R2
   \   00000C   7003         JNZ       ??bindAddressClear_0
   \   00000E   74FF         MOV       A,#-0x1
   \   000010   6B           XRL       A,R3
   \                     ??bindAddressClear_0:
   \   000011   603D         JZ        ??bindAddressClear_1
    746            {
    747              // Looks for a specific Idx
    748              for ( i = 0; i < gNWK_MAX_BINDING_ENTRIES; i++ )
   \   000013   7C00         MOV       R4,#0x0
   \   000015   8015         SJMP      ??bindAddressClear_2
    749              {
    750                if ( ( BindingTable[i].dstGroupMode != AddrGroup ) &&
    751                     ( BindingTable[i].dstGroupMode == DSTGROUPMODE_ADDR ) &&
    752                     ( BindingTable[i].dstIdx == dstIdx ) )
   \                     ??bindAddressClear_3:
   \   000017   EC           MOV       A,R4
   \   000018   12....       LCALL     ?Subroutine11 & 0xFFFF
    753                {
    754                  break;  // found at least one
    755                }
    756              }
   \                     ??CrossCallReturnLabel_12:
   \   00001B   600E         JZ        ??bindAddressClear_4
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   700B         JNZ       ??bindAddressClear_4
   \   000020   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000023   6A           XRL       A,R2
   \   000024   7003         JNZ       ??bindAddressClear_5
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6B           XRL       A,R3
   \                     ??bindAddressClear_5:
   \   000029   6025         JZ        ??bindAddressClear_1
   \                     ??bindAddressClear_4:
   \   00002B   0C           INC       R4
   \                     ??bindAddressClear_2:
   \   00002C   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00002F   E4           CLR       A
   \   000030   93           MOVC      A,@A+DPTR
   \   000031   F8           MOV       R0,A
   \   000032   EC           MOV       A,R4
   \   000033   C3           CLR       C
   \   000034   98           SUBB      A,R0
   \   000035   40E0         JC        ??bindAddressClear_3
    757          
    758              if ( i == gNWK_MAX_BINDING_ENTRIES )
   \   000037   E4           CLR       A
   \   000038   93           MOVC      A,@A+DPTR
   \   000039   6C           XRL       A,R4
   \   00003A   7014         JNZ       ??bindAddressClear_1
    759              {
    760                // No binding entry is associated with dstIdx.
    761                // Remove user binding bit from the address manager entry corresponding to dstIdx.
    762                AddrMgrEntry_t addrEntry;
    763          
    764                addrEntry.user = ADDRMGR_USER_BINDING;
   \   00003C   85..82       MOV       DPL,?XSP + 0
   \   00003F   85..83       MOV       DPH,?XSP + 1
   \   000042   7404         MOV       A,#0x4
   \   000044   F0           MOVX      @DPTR,A
    765                addrEntry.index = dstIdx;
   \   000045   740B         MOV       A,#0xb
   \   000047   12....       LCALL     ?XSTACK_DISP0_8
   \   00004A   12....       LCALL     ?Subroutine18 & 0xFFFF
    766          
    767                AddrMgrEntryRelease( &addrEntry );
    768              }
    769            }
   \                     ??CrossCallReturnLabel_25:
   \   00004D   12....       LCALL     `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
    770          }
   \                     ??bindAddressClear_1:
   \   000050   80..         SJMP      ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   740D         MOV       A,#0xd
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine41_0
   \   000005                ; // Fall through to label ??Subroutine41_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000005                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000005                ; Setup parameters for call to function AddrMgrEntryGet
   \   000005                ; Setup parameters for call to function AddrMgrEntryGet
   \   000005   AA..         MOV       R2,?XSP + 0
   \   000007   AB..         MOV       R3,?XSP + 1
   \   000009   22           RET
    771          
    772          /*********************************************************************
    773           * @fn          bindUpdateAddr
    774           *
    775           * @brief       Update the network address in the binding table.
    776           *
    777           * @param       oldAddr - old network address
    778           * @param       newAddr - new network address
    779           *
    780           * @return      none
    781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine36_0
   \   000003                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    782          void bindUpdateAddr( uint16 oldAddr, uint16 newAddr )
   \                     bindUpdateAddr:
    783          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    784            uint16 oldIdx;
    785            uint16 newIdx;
    786            zAddrType_t addr;
    787            bindTableIndex_t x;
    788            BindingEntry_t *pBind;
    789          
    790            addr.addrMode = Addr16Bit;
   \   00000E   7408         MOV       A,#0x8
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7402         MOV       A,#0x2
   \   000015   F0           MOVX      @DPTR,A
    791            addr.addr.shortAddr = oldAddr;
   \   000016   85..82       MOV       DPL,?XSP + 0
   \   000019   85..83       MOV       DPH,?XSP + 1
   \   00001C   12....       LCALL     ?Subroutine18 & 0xFFFF
    792            oldIdx = bindingAddrMgsHelperFind( &addr );
   \                     ??CrossCallReturnLabel_26:
   \   00001F   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000022   8A..         MOV       ?V0,R2
   \   000024   8B..         MOV       ?V1,R3
    793            addr.addr.shortAddr = newAddr;
   \   000026   85..82       MOV       DPL,?XSP + 0
   \   000029   85..83       MOV       DPH,?XSP + 1
   \   00002C   EE           MOV       A,R6
   \   00002D   F0           MOVX      @DPTR,A
   \   00002E   A3           INC       DPTR
   \   00002F   EF           MOV       A,R7
   \   000030   F0           MOVX      @DPTR,A
    794            newIdx = bindingAddrMgsHelperFind( &addr );
   \   000031                ; Setup parameters for call to function bindingAddrMgsHelperFind
   \   000031   AA..         MOV       R2,?XSP + 0
   \   000033   AB..         MOV       R3,?XSP + 1
   \   000035   12....       LCALL     `??bindingAddrMgsHelperFind::?relay`; Banked call to: bindingAddrMgsHelperFind
   \   000038   8A..         MOV       ?V2,R2
    795          
    796            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   00003A   7A00         MOV       R2,#0x0
   \   00003C   8022         SJMP      ??bindUpdateAddr_0
    797            {
    798              pBind = &BindingTable[x];
   \                     ??bindUpdateAddr_1:
   \   00003E   EA           MOV       A,R2
   \   00003F   12....       LCALL     ?Subroutine17 & 0xFFFF
    799          
    800              if ( pBind->dstIdx == oldIdx )
   \                     ??CrossCallReturnLabel_72:
   \   000042   8882         MOV       DPL,R0
   \   000044   8983         MOV       DPH,R1
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   65..         XRL       A,?V0
   \   00004B   7004         JNZ       ??bindUpdateAddr_2
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   65..         XRL       A,?V1
   \                     ??bindUpdateAddr_2:
   \   000051   700C         JNZ       ??bindUpdateAddr_3
    801              {
    802                pBind->dstIdx = newIdx;
   \   000053   8882         MOV       DPL,R0
   \   000055   8983         MOV       DPH,R1
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   E5..         MOV       A,?V2
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   EB           MOV       A,R3
   \   00005E   F0           MOVX      @DPTR,A
    803              }
    804            }
   \                     ??bindUpdateAddr_3:
   \   00005F   0A           INC       R2
   \                     ??bindUpdateAddr_0:
   \   000060   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000063   E4           CLR       A
   \   000064   93           MOVC      A,@A+DPTR
   \   000065   F8           MOV       R0,A
   \   000066   EA           MOV       A,R2
   \   000067   C3           CLR       C
   \   000068   98           SUBB      A,R0
   \   000069   40D3         JC        ??bindUpdateAddr_1
    805          }
   \   00006B   7409         MOV       A,#0x9
   \   00006D   02....       LJMP      ?Subroutine3 & 0xFFFF
    806          
    807          /*********************************************************************
    808           * @fn      bindingAddrMgsHelperFind
    809           *
    810           * @brief   Turns an zAddrType_t to an Addr Manager index
    811           *
    812           * @param   addr - zAddrType_t
    813           *
    814           * @return  INVALID_NODE_ADDR if not found, otherwise an index
    815           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   740B         MOV       A,#0xb
   \   000002                REQUIRE ??Subroutine39_0
   \   000002                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   12....       LCALL     ?XSTACK_DISP0_8
   \   000003   12....       LCALL     ??Subroutine42_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000006                REQUIRE ??Subroutine40_0
   \   000006                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    816          uint16 bindingAddrMgsHelperFind( zAddrType_t *addr )
   \                     bindingAddrMgsHelperFind:
    817          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    818            AddrMgrEntry_t entry;
    819          
    820            // Resolve addresses with the address manager
    821            entry.user = ADDRMGR_USER_BINDING;
   \   000009   12....       LCALL     ?Subroutine19 & 0xFFFF
    822            if ( addr->addrMode == Addr16Bit )
   \                     ??CrossCallReturnLabel_29:
   \   00000C   7012         JNZ       ??bindingAddrMgsHelperFind_0
    823            {
    824              entry.nwkAddr = addr->addr.shortAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   12....       LCALL     ?Subroutine21 & 0xFFFF
    825              AddrMgrEntryLookupNwk( &entry );
    826            }
   \                     ??CrossCallReturnLabel_33:
   \   000015   12....       LCALL     ?XSTACK_DISP0_8
   \   000018   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00001B   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00001E   8017         SJMP      ??bindingAddrMgsHelperFind_1
    827            else
    828            {
    829              AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
   \                     ??bindingAddrMgsHelperFind_0:
   \   000020                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000020   EA           MOV       A,R2
   \   000021   FC           MOV       R4,A
   \   000022   EB           MOV       A,R3
   \   000023   FD           MOV       R5,A
   \   000024   7403         MOV       A,#0x3
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   AA82         MOV       R2,DPL
   \   00002B   AB83         MOV       R3,DPH
   \   00002D   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    830              AddrMgrEntryLookupExt( &entry );
   \   000030                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000030   AA..         MOV       R2,?XSP + 0
   \   000032   AB..         MOV       R3,?XSP + 1
   \   000034   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
    831            }
    832          
    833            return ( entry.index );
   \                     ??bindingAddrMgsHelperFind_1:
   \   000037   02....       LJMP      ?Subroutine1 & 0xFFFF
    834          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   7401         MOV       A,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000005                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000005   AA..         MOV       R2,?XSP + 0
   \   000007   AB..         MOV       R3,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   7404         MOV       A,#0x4
   \   000008   F0           MOVX      @DPTR,A
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   6402         XRL       A,#0x2
   \   000018   22           RET
    835          
    836          /*********************************************************************
    837           * @fn      bindingAddrMgsHelperConvert
    838           *
    839           * @brief   Convert an index into an zAddrType_t
    840           *
    841           * @param   idx -
    842           * @param   addr - zAddrType_t
    843           *
    844           * @return  TRUE if found, FALSE if not
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr )
   \                     bindingAddrMgsHelperConvert:
    847          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    848            AddrMgrEntry_t entry;
    849            uint8 stat;
    850          
    851            // Resolve addresses with the address manager
    852            entry.user = ADDRMGR_USER_BINDING;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7404         MOV       A,#0x4
   \   000016   F0           MOVX      @DPTR,A
    853            entry.index = idx;
   \   000017   740B         MOV       A,#0xb
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ?Subroutine18 & 0xFFFF
    854            stat = AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_27:
   \   00001F   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   \   000022   E9           MOV       A,R1
   \   000023   F5..         MOV       ?V0,A
    855            if ( stat )
   \   000025   601D         JZ        ??bindingAddrMgsHelperConvert_0
    856            {
    857              addr->addrMode = Addr64Bit;
   \   000027   8E82         MOV       DPL,R6
   \   000029   8F83         MOV       DPH,R7
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   7403         MOV       A,#0x3
   \   000035   F0           MOVX      @DPTR,A
    858              osal_cpyExtAddr( addr->addr.extAddr, entry.extAddr );
   \   000036                ; Setup parameters for call to function sAddrExtCpy
   \   000036   12....       LCALL     ?XSTACK_DISP0_8
   \   000039   AC82         MOV       R4,DPL
   \   00003B   AD83         MOV       R5,DPH
   \   00003D   EE           MOV       A,R6
   \   00003E   FA           MOV       R2,A
   \   00003F   EF           MOV       A,R7
   \   000040   FB           MOV       R3,A
   \   000041   12....       LCALL     `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
    859            }
    860          
    861            return ( stat );
   \                     ??bindingAddrMgsHelperConvert_0:
   \   000044   A9..         MOV       R1,?V0
   \   000046   740D         MOV       A,#0xd
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004B   02....       LJMP      ?Subroutine2 & 0xFFFF
    862          }
    863          
    864          /*********************************************************************
    865           * @fn      bindingAddrMgsHelperConvertShort
    866           *
    867           * @brief   Convert an index into a short address
    868           *
    869           * @param   idx -
    870           *
    871           * @return  INVALID_NODE_ADDR if not available, otherwise the short address
    872           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    873          uint16 bindingAddrMgsHelperConvertShort( uint16 idx )
   \                     bindingAddrMgsHelperConvertShort:
    874          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    875            AddrMgrEntry_t entry;
    876          
    877            // Resolve addresses with the address manager
    878            entry.user = ADDRMGR_USER_BINDING;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   7404         MOV       A,#0x4
   \   000011   F0           MOVX      @DPTR,A
    879            entry.index = idx;
   \   000012   740B         MOV       A,#0xb
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine18 & 0xFFFF
    880            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_28:
   \   00001A   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
    881          
    882            return ( entry.nwkAddr );
   \   00001D   7401         MOV       A,#0x1
   \   00001F   02....       LJMP      ??Subroutine39_0 & 0xFFFF
    883          }
    884          
    885          /*********************************************************************
    886           * @fn      bindAddrMgrLocalLoad
    887           *
    888           * @brief   Load local(self and parent) address information into
    889           *          Address Manager
    890           *
    891           * @param   none
    892           *
    893           * @return  none
    894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine33_0
   \   000003                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    895          void bindAddrMgrLocalLoad( void )
   \                     bindAddrMgrLocalLoad:
    896          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    897            AddrMgrEntry_t entry;
    898            uint16         parent;
    899          
    900            // add "local"(self and parent) address informtion into the Address
    901            // Manager
    902            if ( bindAddrMgrLocalLoaded == FALSE )
   \   00000A   90....       MOV       DPTR,#bindAddrMgrLocalLoaded
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   707B         JNZ       ??bindAddrMgrLocalLoad_0
    903            {
    904              // add the device's address information
    905              entry.user    = ADDRMGR_USER_BINDING;
   \   000010   85..82       MOV       DPL,?XSP + 0
   \   000013   85..83       MOV       DPH,?XSP + 1
   \   000016   7404         MOV       A,#0x4
   \   000018   F0           MOVX      @DPTR,A
    906              entry.nwkAddr = _NIB.nwkDevAddress;
   \   000019   90....       MOV       DPTR,#_NIB + 20
   \   00001C   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   E8           MOV       A,R0
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   E9           MOV       A,R1
   \   000026   F0           MOVX      @DPTR,A
    907              AddrMgrExtAddrSet( entry.extAddr, NLME_GetExtAddr() );
   \   000027                ; Setup parameters for call to function NLME_GetExtAddr
   \   000027   12....       LCALL     `??NLME_GetExtAddr::?relay`; Banked call to: NLME_GetExtAddr
   \   00002A   8A..         MOV       ?V0,R2
   \   00002C   8B..         MOV       ?V1,R3
   \   00002E   AC..         MOV       R4,?V0
   \   000030   AD..         MOV       R5,?V1
   \   000032                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000032   7403         MOV       A,#0x3
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   AA82         MOV       R2,DPL
   \   000039   AB83         MOV       R3,DPH
   \   00003B   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    908              AddrMgrEntryUpdate( &entry );
   \   00003E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003E   AA..         MOV       R2,?XSP + 0
   \   000040   AB..         MOV       R3,?XSP + 1
   \   000042   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
    909          
    910              // make sure parent address is valid
    911              parent = NLME_GetCoordShortAddr();
   \   000045                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000045   12....       LCALL     `??NLME_GetCoordShortAddr::?relay`; Banked call to: NLME_GetCoordShortAddr
   \   000048   8A..         MOV       ?V0,R2
   \   00004A   8B..         MOV       ?V1,R3
   \   00004C   A8..         MOV       R0,?V0
   \   00004E   A9..         MOV       R1,?V1
    912              if ( ( parent != entry.nwkAddr     ) &&
    913                   ( parent != INVALID_NODE_ADDR )    )
   \   000050   7401         MOV       A,#0x1
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   E0           MOVX      A,@DPTR
   \   000056   68           XRL       A,R0
   \   000057   7003         JNZ       ??bindAddrMgrLocalLoad_1
   \   000059   A3           INC       DPTR
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   69           XRL       A,R1
   \                     ??bindAddrMgrLocalLoad_1:
   \   00005C   6027         JZ        ??bindAddrMgrLocalLoad_2
   \   00005E   74FE         MOV       A,#-0x2
   \   000060   68           XRL       A,R0
   \   000061   7003         JNZ       ??bindAddrMgrLocalLoad_3
   \   000063   74FF         MOV       A,#-0x1
   \   000065   69           XRL       A,R1
   \                     ??bindAddrMgrLocalLoad_3:
   \   000066   601D         JZ        ??bindAddrMgrLocalLoad_2
    914              {
    915                // add the parent's address information
    916                entry.nwkAddr = parent;
   \   000068   7401         MOV       A,#0x1
   \   00006A   12....       LCALL     ?XSTACK_DISP0_8
   \   00006D   E8           MOV       A,R0
   \   00006E   F0           MOVX      @DPTR,A
   \   00006F   A3           INC       DPTR
   \   000070   E9           MOV       A,R1
   \   000071   F0           MOVX      @DPTR,A
    917                NLME_GetCoordExtAddr( entry.extAddr );
   \   000072                ; Setup parameters for call to function NLME_GetCoordExtAddr
   \   000072   7403         MOV       A,#0x3
   \   000074   12....       LCALL     ?XSTACK_DISP0_8
   \   000077   AA82         MOV       R2,DPL
   \   000079   AB83         MOV       R3,DPH
   \   00007B   12....       LCALL     `??NLME_GetCoordExtAddr::?relay`; Banked call to: NLME_GetCoordExtAddr
    918                AddrMgrEntryUpdate( &entry );
   \   00007E                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00007E   AA..         MOV       R2,?XSP + 0
   \   000080   AB..         MOV       R3,?XSP + 1
   \   000082   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
    919              }
    920          
    921              bindAddrMgrLocalLoaded = TRUE;
   \                     ??bindAddrMgrLocalLoad_2:
   \   000085   90....       MOV       DPTR,#bindAddrMgrLocalLoaded
   \   000088   7401         MOV       A,#0x1
   \   00008A   F0           MOVX      @DPTR,A
    922            }
    923          }
   \                     ??bindAddrMgrLocalLoad_0:
   \   00008B   740D         MOV       A,#0xd
   \   00008D   02....       LJMP      ?Subroutine0 & 0xFFFF
    924          
    925          /*********************************************************************
    926           * @fn      bindAddrIndexGet
    927           *
    928           * @brief   Get bind address index.
    929           *
    930           * @param   addr - <zAddrType_t>
    931           *
    932           * @return  (uint16) address index
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          uint16 bindAddrIndexGet( zAddrType_t* addr )
   \                     bindAddrIndexGet:
    935          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 13
   \   000004   74F3         MOV       A,#-0xd
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    936            AddrMgrEntry_t entry;
    937            uint8          update;
    938          
    939            update = FALSE;
    940          
    941            // sync binding addresses with the address manager
    942            entry.user = ADDRMGR_USER_BINDING;
   \   000009   12....       LCALL     ?Subroutine19 & 0xFFFF
    943          
    944            if ( addr->addrMode == Addr16Bit )
   \                     ??CrossCallReturnLabel_30:
   \   00000C   8A82         MOV       DPL,R2
   \   00000E   8B83         MOV       DPH,R3
   \   000010   7011         JNZ       ??bindAddrIndexGet_0
    945            {
    946              entry.nwkAddr = addr->addr.shortAddr;
   \   000012   12....       LCALL     ?Subroutine21 & 0xFFFF
    947          
    948              if ( AddrMgrEntryLookupNwk( &entry ) == FALSE )
    949              {
    950                update = TRUE;
    951              }
    952            }
   \                     ??CrossCallReturnLabel_35:
   \   000015   12....       LCALL     ?XSTACK_DISP0_8
   \   000018   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00001B   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00001E   E9           MOV       A,R1
   \   00001F   7060         JNZ       ??bindAddrIndexGet_1
   \   000021   8027         SJMP      ??bindAddrIndexGet_2
    953            else if ( addr->addrMode == Addr64Bit )
   \                     ??bindAddrIndexGet_0:
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   6403         XRL       A,#0x3
   \   00002E   7023         JNZ       ??bindAddrIndexGet_3
    954            {
    955              AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
   \   000030                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000030   EA           MOV       A,R2
   \   000031   FC           MOV       R4,A
   \   000032   EB           MOV       A,R3
   \   000033   FD           MOV       R5,A
   \   000034   7403         MOV       A,#0x3
   \   000036   12....       LCALL     ?XSTACK_DISP0_8
   \   000039   AA82         MOV       R2,DPL
   \   00003B   AB83         MOV       R3,DPH
   \   00003D   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    956          
    957              if ( AddrMgrEntryLookupExt( &entry ) == FALSE )
   \   000040                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000040   AA..         MOV       R2,?XSP + 0
   \   000042   AB..         MOV       R3,?XSP + 1
   \   000044   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   000047   E9           MOV       A,R1
   \   000048   7037         JNZ       ??bindAddrIndexGet_1
    958              {
    959                update = TRUE;
    960              }
    961            }
    962            else if ( addr->addrMode == AddrGroup )
    963            {
    964              entry.index = addr->addr.shortAddr;
    965            }
    966            else
    967            {
    968              entry.index = INVALID_NODE_ADDR;
    969            }
    970          
    971            if ( update )
    972            {
    973              AddrMgrEntryUpdate( &entry );
   \                     ??bindAddrIndexGet_2:
   \   00004A                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00004A   AA..         MOV       R2,?XSP + 0
   \   00004C   AB..         MOV       R3,?XSP + 1
   \   00004E   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000051   802E         SJMP      ??bindAddrIndexGet_1
    974            }
   \                     ??bindAddrIndexGet_3:
   \   000053   8A82         MOV       DPL,R2
   \   000055   8B83         MOV       DPH,R3
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   A3           INC       DPTR
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   6401         XRL       A,#0x1
   \   000062   7012         JNZ       ??bindAddrIndexGet_4
   \   000064   8A82         MOV       DPL,R2
   \   000066   8B83         MOV       DPH,R3
   \   000068   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00006B   740B         MOV       A,#0xb
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   E8           MOV       A,R0
   \   000071   F0           MOVX      @DPTR,A
   \   000072   A3           INC       DPTR
   \   000073   E9           MOV       A,R1
   \   000074   800A         SJMP      ??bindAddrIndexGet_5
   \                     ??bindAddrIndexGet_4:
   \   000076   740B         MOV       A,#0xb
   \   000078   12....       LCALL     ?XSTACK_DISP0_8
   \   00007B   74FE         MOV       A,#-0x2
   \   00007D   F0           MOVX      @DPTR,A
   \   00007E   A3           INC       DPTR
   \   00007F   04           INC       A
   \                     ??bindAddrIndexGet_5:
   \   000080   F0           MOVX      @DPTR,A
    975          
    976            return entry.index;
   \                     ??bindAddrIndexGet_1:
   \   000081   02....       LJMP      ?Subroutine1 & 0xFFFF
    977          }
    978          
    979          /*********************************************************************
    980           * @fn      GetBindingTableEntry
    981           *
    982           * @brief   Get a pointer to the Nth valid binding table entry.
    983           *
    984           * @param   Nth valid entry being requested.
    985           *
    986           * @return  The Nth valid binding table entry.
    987           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    988          BindingEntry_t *GetBindingTableEntry( uint16 Nth )
   \                     GetBindingTableEntry:
    989          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    990            BindingEntry_t *rtrn = NULL;
   \   000005   7800         MOV       R0,#0x0
   \   000007   7900         MOV       R1,#0x0
    991          
    992          #if defined ( REFLECTOR )
    993            bindTableIndex_t idx, cnt = 0;
   \   000009   7C00         MOV       R4,#0x0
    994          
    995            for ( idx = 0; idx < gNWK_MAX_BINDING_ENTRIES; idx++ )
   \   00000B   7D00         MOV       R5,#0x0
   \   00000D   8001         SJMP      ??GetBindingTableEntry_0
   \                     ??GetBindingTableEntry_1:
   \   00000F   0D           INC       R5
   \                     ??GetBindingTableEntry_0:
   \   000010   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000013   E4           CLR       A
   \   000014   93           MOVC      A,@A+DPTR
   \   000015   FE           MOV       R6,A
   \   000016   ED           MOV       A,R5
   \   000017   C3           CLR       C
   \   000018   9E           SUBB      A,R6
   \   000019   5031         JNC       ??CrossCallReturnLabel_70
    996            {
    997              if ( BindingTable[idx].srcEP != NV_BIND_EMPTY )
   \   00001B   ED           MOV       A,R5
   \   00001C   75F00E       MOV       B,#0xe
   \   00001F   A4           MUL       AB
   \   000020   FE           MOV       R6,A
   \   000021   85F0..       MOV       ?V0,B
   \   000024   AF..         MOV       R7,?V0
   \   000026   74..         MOV       A,#BindingTable & 0xff
   \   000028   2E           ADD       A,R6
   \   000029   F582         MOV       DPL,A
   \   00002B   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   00002D   3F           ADDC      A,R7
   \   00002E   F583         MOV       DPH,A
   \   000030   E0           MOVX      A,@DPTR
   \   000031   F4           CPL       A
   \   000032   60DB         JZ        ??GetBindingTableEntry_1
    998              {
    999                if ( cnt++ == Nth )
   \   000034   8C..         MOV       ?V0,R4
   \   000036   7401         MOV       A,#0x1
   \   000038   2C           ADD       A,R4
   \   000039   FC           MOV       R4,A
   \   00003A   AE..         MOV       R6,?V0
   \   00003C   EA           MOV       A,R2
   \   00003D   6E           XRL       A,R6
   \   00003E   4B           ORL       A,R3
   \   00003F   70CE         JNZ       ??GetBindingTableEntry_1
   1000                {
   1001                  rtrn = BindingTable+idx;
   \   000041   ED           MOV       A,R5
   \   000042   75F00E       MOV       B,#0xe
   \   000045   A4           MUL       AB
   \   000046   F8           MOV       R0,A
   \   000047   EF           MOV       A,R7
   \   000048   F9           MOV       R1,A
   \   000049   12....       LCALL     ??Subroutine37_0 & 0xFFFF
   1002                  break;
   1003                }
   1004              }
   1005            }
   1006          #else
   1007            (void)Nth;
   1008          #endif
   1009          
   1010            return rtrn;
   \                     ??CrossCallReturnLabel_70:
   \   00004C   E8           MOV       A,R0
   \   00004D   FA           MOV       R2,A
   \   00004E   E9           MOV       A,R1
   \   00004F   FB           MOV       R3,A
   \   000050   02....       LJMP      ?Subroutine2 & 0xFFFF
   1011          }
   1012          
   1013          #if !defined ( BINDINGTABLE_NV_SINGLES )
   1014          /*********************************************************************
   1015           * @fn          BindInitNV
   1016           *
   1017           * @brief       Initialize the Binding NV Item
   1018           *
   1019           * @param       none
   1020           *
   1021           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1022           *              exist in NV, NV_OPER_FAILED if failure.
   1023           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1024          byte BindInitNV( void )
   \                     BindInitNV:
   1025          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1026            byte ret;
   1027          
   1028            // Initialize the device list
   1029            ret = osal_nv_item_init( ZCD_NV_BINDING_TABLE,
   1030                            (uint16)( sizeof( nvBindingHdr_t ) + NV_BIND_ITEM_SIZE ), NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   E4           CLR       A
   \   000006   F5..         MOV       ?V0,A
   \   000008   F5..         MOV       ?V1,A
   \   00000A   78..         MOV       R0,#?V0
   \   00000C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00000F   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000012   12....       LCALL     ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000015   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000018   7402         MOV       A,#0x2
   \   00001A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00001D   E9           MOV       A,R1
   \   00001E   FE           MOV       R6,A
   1031          
   1032            if ( ret != ZSUCCESS )
   \   00001F   6003         JZ        ??BindInitNV_0
   1033            {
   1034              BindSetDefaultNV();
   \   000021                ; Setup parameters for call to function BindSetDefaultNV
   \   000021   12....       LCALL     `??BindSetDefaultNV::?relay`; Banked call to: BindSetDefaultNV
   1035            }
   1036          
   1037            return ( ret );
   \                     ??BindInitNV_0:
   \   000024   EE           MOV       A,R6
   \   000025   F9           MOV       R1,A
   \   000026   02....       LJMP      ??Subroutine33_0 & 0xFFFF
   1038          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   F8           MOV       R0,A
   \   000006   7401         MOV       A,#0x1
   \   000008   93           MOVC      A,@A+DPTR
   \   000009   F9           MOV       R1,A
   \   00000A   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   00000D   E4           CLR       A
   \   00000E   93           MOVC      A,@A+DPTR
   \   00000F   F5..         MOV       ?V0,A
   \   000011   E8           MOV       A,R0
   \   000012   85..F0       MOV       B,?V0
   \   000015   A4           MUL       AB
   \   000016   F8           MOV       R0,A
   \   000017   AAF0         MOV       R2,B
   \   000019   85..F0       MOV       B,?V0
   \   00001C   E9           MOV       A,R1
   \   00001D   A4           MUL       AB
   \   00001E   2A           ADD       A,R2
   \   00001F   F9           MOV       R1,A
   \   000020   E8           MOV       A,R0
   \   000021   2402         ADD       A,#0x2
   \   000023   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   FC           MOV       R4,A
   \   000001   E4           CLR       A
   \   000002   39           ADDC      A,R1
   \   000003   FD           MOV       R5,A
   \   000004   7A41         MOV       R2,#0x41
   \   000006   7B00         MOV       R3,#0x0
   \   000008   22           RET
   1039          
   1040          /*********************************************************************
   1041           * @fn          BindSetDefaultNV
   1042           *
   1043           * @brief       Write the defaults to NV
   1044           *
   1045           * @param       none
   1046           *
   1047           * @return      none
   1048           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1049          void BindSetDefaultNV( void )
   \                     BindSetDefaultNV:
   1050          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1051            nvBindingHdr_t hdr;
   1052          
   1053            // Initialize the header
   1054            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   1055          
   1056            // Save off the header
   1057            osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof( nvBindingHdr_t ), &hdr );
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V0,R0
   \   00001A   89..         MOV       ?V1,R1
   \   00001C   78..         MOV       R0,#?V0
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV       ?V0,#0x2
   \   000024   75..00       MOV       ?V1,#0x0
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   7C00         MOV       R4,#0x0
   \   00002E   7D00         MOV       R5,#0x0
   \   000030   7A41         MOV       R2,#0x41
   \   000032   7B00         MOV       R3,#0x0
   \   000034   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000037   7404         MOV       A,#0x4
   \   000039   12....       LCALL     ?DEALLOC_XSTACK8
   1058          }
   \   00003C   7402         MOV       A,#0x2
   \   00003E   02....       LJMP      ?Subroutine0 & 0xFFFF
   1059          
   1060          #if !defined ( DONT_UPGRADE_BIND )
   1061          /*********************************************************************
   1062           * @fn          BindCopyBackupToNewNV
   1063           *
   1064           * @brief       Creates the New NV item, copies the backup data into
   1065           *              the New NV ID, and Deletes the duplicate NV item.
   1066           *
   1067           * @param       dupLen - NV item length of the old Binding table.
   1068           * @param       newLen - NV item length of the new Binding table to be created.
   1069           *
   1070           * @return      ZSuccess - All the actions were successful.
   1071           *              ZFailure - Any of the actions failed.
   1072           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine38_0
   \   000003                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1073          static uint8 BindCopyBackupToNewNV( uint16 dupLen, uint16 newLen )
   \                     BindCopyBackupToNewNV:
   1074          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   1075            uint8 status = ZSuccess;
   \   000012   75..00       MOV       ?V2,#0x0
   1076            uint16 bindLen;
   1077          
   1078            bindLen = osal_nv_item_len( ZCD_NV_BINDING_TABLE );
   \   000015                ; Setup parameters for call to function osal_nv_item_len
   \   000015   7A41         MOV       R2,#0x41
   \   000017   7B00         MOV       R3,#0x0
   \   000019   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   00001C   8A..         MOV       ?V4,R2
   \   00001E   8B..         MOV       ?V5,R3
   \   000020   AC..         MOV       R4,?V4
   \   000022   AD..         MOV       R5,?V5
   1079          
   1080          
   1081            if ( ( bindLen > 0 ) && ( bindLen != newLen ) )
   \   000024   EC           MOV       A,R4
   \   000025   4D           ORL       A,R5
   \   000026   6011         JZ        ??BindCopyBackupToNewNV_0
   \   000028   E5..         MOV       A,?V0
   \   00002A   6C           XRL       A,R4
   \   00002B   7003         JNZ       ??BindCopyBackupToNewNV_1
   \   00002D   E5..         MOV       A,?V1
   \   00002F   6D           XRL       A,R5
   \                     ??BindCopyBackupToNewNV_1:
   \   000030   6007         JZ        ??BindCopyBackupToNewNV_0
   1082            {
   1083              // The existing item does not match the New length
   1084              osal_nv_delete( ZCD_NV_BINDING_TABLE, bindLen );
   \   000032                ; Setup parameters for call to function osal_nv_delete
   \   000032   7A41         MOV       R2,#0x41
   \   000034   7B00         MOV       R3,#0x0
   \   000036   12....       LCALL     `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   1085            }
   1086          
   1087            // Create Binding Table NV item with the NEW legth
   1088            if ( osal_nv_item_init( ZCD_NV_BINDING_TABLE, newLen, NULL ) != NV_OPER_FAILED )
   \                     ??BindCopyBackupToNewNV_0:
   \   000039                ; Setup parameters for call to function osal_nv_item_init
   \   000039   E4           CLR       A
   \   00003A   F5..         MOV       ?V4,A
   \   00003C   F5..         MOV       ?V5,A
   \   00003E   78..         MOV       R0,#?V4
   \   000040   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000043   AC..         MOV       R4,?V0
   \   000045   AD..         MOV       R5,?V1
   \   000047   7A41         MOV       R2,#0x41
   \   000049   7B00         MOV       R3,#0x0
   \   00004B   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00004E   7402         MOV       A,#0x2
   \   000050   12....       LCALL     ?DEALLOC_XSTACK8
   \   000053   E9           MOV       A,R1
   \   000054   640A         XRL       A,#0xa
   \   000056   7003         JNZ       $+5
   \   000058   02....       LJMP      ??BindCopyBackupToNewNV_2 & 0xFFFF
   1089            {
   1090              nvBindingHdr_t hdrBackup;
   1091          
   1092              // Copy ONLY the valid records from the duplicate NV table into the new table
   1093              // at the end of this process the table content will be compacted
   1094              if ( osal_nv_read( ZCD_NV_DUPLICATE_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdrBackup ) == ZSuccess )
   \   00005B                ; Setup parameters for call to function osal_nv_read
   \   00005B   7402         MOV       A,#0x2
   \   00005D   12....       LCALL     ?XSTACK_DISP100_8
   \   000060   88..         MOV       ?V0,R0
   \   000062   89..         MOV       ?V1,R1
   \   000064   78..         MOV       R0,#?V0
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000069   75..02       MOV       ?V0,#0x2
   \   00006C   75..00       MOV       ?V1,#0x0
   \   00006F   78..         MOV       R0,#?V0
   \   000071   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000074   7C00         MOV       R4,#0x0
   \   000076   7D00         MOV       R5,#0x0
   \   000078   7A00         MOV       R2,#0x0
   \   00007A   7B03         MOV       R3,#0x3
   \   00007C   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00007F   7404         MOV       A,#0x4
   \   000081   12....       LCALL     ?DEALLOC_XSTACK8
   \   000084   E9           MOV       A,R1
   \   000085   6003         JZ        $+5
   \   000087   02....       LJMP      ??BindCopyBackupToNewNV_2 & 0xFFFF
   1095              {
   1096                bindTableIndex_t i;
   1097                uint16 validBackupRecs = 0;
   \   00008A   85..82       MOV       DPL,?XSP + 0
   \   00008D   85..83       MOV       DPH,?XSP + 1
   \   000090   E4           CLR       A
   \   000091   F0           MOVX      @DPTR,A
   \   000092   A3           INC       DPTR
   \   000093   F0           MOVX      @DPTR,A
   1098                BindingEntry_t backupRec;
   1099          
   1100                // Read in the device list. This loop will stop when:
   1101                // The total number of valid records has been reached either because:
   1102                //          The new table is full of valid records OR
   1103                //          The old table has less valid records than the size of the table
   1104                for ( i = 0; ( validBackupRecs < gNWK_MAX_BINDING_ENTRIES ) && ( validBackupRecs < hdrBackup.numRecs ); i++ )
   \   000094   75..00       MOV       ?V0,#0x0
   \   000097   8073         SJMP      ??BindCopyBackupToNewNV_3
   1105                {
   1106                  if ( osal_nv_read( ZCD_NV_DUPLICATE_BINDING_TABLE,
   1107                                    (uint16)(sizeof(nvBindingHdr_t) + (i * NV_BIND_REC_SIZE)),
   1108                                    NV_BIND_REC_SIZE, &backupRec ) == ZSuccess )
   \                     ??BindCopyBackupToNewNV_4:
   \   000099                ; Setup parameters for call to function osal_nv_read
   \   000099   7404         MOV       A,#0x4
   \   00009B   12....       LCALL     ?XSTACK_DISP100_8
   \   00009E   88..         MOV       ?V4,R0
   \   0000A0   89..         MOV       ?V5,R1
   \   0000A2   78..         MOV       R0,#?V4
   \   0000A4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A7   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   0000AA   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   0000AD   A8..         MOV       R0,?V0
   \   0000AF   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000B2   F9           MOV       R1,A
   \   0000B3   E8           MOV       A,R0
   \   0000B4   2402         ADD       A,#0x2
   \   0000B6   FC           MOV       R4,A
   \   0000B7   E4           CLR       A
   \   0000B8   39           ADDC      A,R1
   \   0000B9   FD           MOV       R5,A
   \   0000BA   7A00         MOV       R2,#0x0
   \   0000BC   7B03         MOV       R3,#0x3
   \   0000BE   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000C1   7404         MOV       A,#0x4
   \   0000C3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C6   E9           MOV       A,R1
   \   0000C7   6003         JZ        $+5
   \   0000C9   02....       LJMP      ??BindCopyBackupToNewNV_2 & 0xFFFF
   1109                  {
   1110                    if ( backupRec.srcEP != NV_BIND_EMPTY )
   \   0000CC   7404         MOV       A,#0x4
   \   0000CE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D1   E0           MOVX      A,@DPTR
   \   0000D2   F4           CPL       A
   \   0000D3   6035         JZ        ??CrossCallReturnLabel_41
   1111                    {
   1112                      // Save the valid record into the NEW NV table.
   1113                      if ( osal_nv_write( ZCD_NV_BINDING_TABLE,
   1114                                          (uint16)((sizeof(nvBindingHdr_t)) + (validBackupRecs * NV_BIND_REC_SIZE)),
   1115                                          NV_BIND_REC_SIZE, &backupRec ) != ZSuccess )
   \   0000D5                ; Setup parameters for call to function osal_nv_write
   \   0000D5   7404         MOV       A,#0x4
   \   0000D7   12....       LCALL     ?XSTACK_DISP100_8
   \   0000DA   88..         MOV       ?V4,R0
   \   0000DC   89..         MOV       ?V5,R1
   \   0000DE   78..         MOV       R0,#?V4
   \   0000E0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000E3   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   0000E6   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   0000E9   7404         MOV       A,#0x4
   \   0000EB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EE   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000F1   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000F4   FA           MOV       R2,A
   \   0000F5   85..F0       MOV       B,?V4
   \   0000F8   E9           MOV       A,R1
   \   0000F9   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0000FC   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000FF   7404         MOV       A,#0x4
   \   000101   12....       LCALL     ?DEALLOC_XSTACK8
   \   000104   E9           MOV       A,R1
   \   000105   707C         JNZ       ??BindCopyBackupToNewNV_2
   1116                      {
   1117                         status = ZFailure;
   1118                         break; // Terminate the loop as soon as a problem with NV is detected
   1119                      }
   1120          
   1121                      validBackupRecs++;
   \   000107   12....       LCALL     ?Subroutine24 & 0xFFFF
   1122                    }
   1123                  }
   1124                  else
   1125                  {
   1126                     status = ZFailure;
   1127                     break; // Terminate the loop as soon as a problem with NV is detected
   1128                  }
   1129                }
   \                     ??CrossCallReturnLabel_41:
   \   00010A   05..         INC       ?V0
   \                     ??BindCopyBackupToNewNV_3:
   \   00010C   85..82       MOV       DPL,?XSP + 0
   \   00010F   85..83       MOV       DPH,?XSP + 1
   \   000112   C082         PUSH      DPL
   \   000114   C083         PUSH      DPH
   \   000116   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000119   E4           CLR       A
   \   00011A   93           MOVC      A,@A+DPTR
   \   00011B   F8           MOV       R0,A
   \   00011C   D083         POP       DPH
   \   00011E   D082         POP       DPL
   \   000120   C3           CLR       C
   \   000121   E0           MOVX      A,@DPTR
   \   000122   98           SUBB      A,R0
   \   000123   A3           INC       DPTR
   \   000124   E0           MOVX      A,@DPTR
   \   000125   9400         SUBB      A,#0x0
   \   000127   5021         JNC       ??BindCopyBackupToNewNV_5
   \   000129   85..82       MOV       DPL,?XSP + 0
   \   00012C   85..83       MOV       DPH,?XSP + 1
   \   00012F   C082         PUSH      DPL
   \   000131   C083         PUSH      DPH
   \   000133   7402         MOV       A,#0x2
   \   000135   12....       LCALL     ?XSTACK_DISP0_8
   \   000138   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00013B   D083         POP       DPH
   \   00013D   D082         POP       DPL
   \   00013F   C3           CLR       C
   \   000140   E0           MOVX      A,@DPTR
   \   000141   98           SUBB      A,R0
   \   000142   A3           INC       DPTR
   \   000143   E0           MOVX      A,@DPTR
   \   000144   99           SUBB      A,R1
   \   000145   5003         JNC       $+5
   \   000147   02....       LJMP      ??BindCopyBackupToNewNV_4 & 0xFFFF
   1130          
   1131                // Only save the header and delete the duplicate element if the previous
   1132                // process was successful
   1133                if ( status == ZSuccess )
   1134                {
   1135                  // Save off the header
   1136                  if ( osal_nv_write( ZCD_NV_BINDING_TABLE, 0,
   1137                                      sizeof(nvBindingHdr_t), &validBackupRecs ) == ZSuccess )
   \                     ??BindCopyBackupToNewNV_5:
   \   00014A                ; Setup parameters for call to function osal_nv_write
   \   00014A   A8..         MOV       R0,?XSP + 0
   \   00014C   A9..         MOV       R1,?XSP + 1
   \   00014E   88..         MOV       ?V0,R0
   \   000150   89..         MOV       ?V1,R1
   \   000152   78..         MOV       R0,#?V0
   \   000154   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000157   75..02       MOV       ?V0,#0x2
   \   00015A   75..00       MOV       ?V1,#0x0
   \   00015D   78..         MOV       R0,#?V0
   \   00015F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000162   7C00         MOV       R4,#0x0
   \   000164   7D00         MOV       R5,#0x0
   \   000166   7A41         MOV       R2,#0x41
   \   000168   7B00         MOV       R3,#0x0
   \   00016A   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00016D   7404         MOV       A,#0x4
   \   00016F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000172   E9           MOV       A,R1
   \   000173   700E         JNZ       ??BindCopyBackupToNewNV_2
   1138                  {
   1139                    // Delete the duplicate NV Item, once the data has been stored in the NEW table
   1140                    if ( osal_nv_delete( ZCD_NV_DUPLICATE_BINDING_TABLE, dupLen ) != ZSuccess )
   \   000175                ; Setup parameters for call to function osal_nv_delete
   \   000175   EE           MOV       A,R6
   \   000176   FC           MOV       R4,A
   \   000177   EF           MOV       A,R7
   \   000178   FD           MOV       R5,A
   \   000179   7A00         MOV       R2,#0x0
   \   00017B   7B03         MOV       R3,#0x3
   \   00017D   12....       LCALL     `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   \   000180   E9           MOV       A,R1
   \   000181   6003         JZ        ??BindCopyBackupToNewNV_6
   1141                    {
   1142                      status = ZFailure;
   1143                    }
   1144                  }
   1145                  else
   1146                  {
   1147                    status = ZFailure;
   1148                  }
   1149                }
   1150              }
   1151              else
   1152              {
   1153                status = ZFailure;
   1154              }
   1155            }
   1156            else
   1157            {
   1158              status = ZFailure;
   \                     ??BindCopyBackupToNewNV_2:
   \   000183   75..01       MOV       ?V2,#0x1
   1159            }
   1160          
   1161            return ( status );
   \                     ??BindCopyBackupToNewNV_6:
   \   000186   A9..         MOV       R1,?V2
   \   000188   7412         MOV       A,#0x12
   \   00018A   02....       LJMP      ?Subroutine4 & 0xFFFF
   1162          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   F5..         MOV       ?V4,A
   \   000007   7401         MOV       A,#0x1
   \   000009   93           MOVC      A,@A+DPTR
   \   00000A   F5..         MOV       ?V5,A
   \   00000C   E8           MOV       A,R0
   \   00000D   85..F0       MOV       B,?V4
   \   000010   A4           MUL       AB
   \   000011   C8           XCH       A,R0
   \   000012   AAF0         MOV       R2,B
   \   000014   85..F0       MOV       B,?V5
   \   000017   A4           MUL       AB
   \   000018   2A           ADD       A,R2
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   E0           MOVX      A,@DPTR
   \   000007   2401         ADD       A,#0x1
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   3400         ADDC      A,#0x0
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   A4           MUL       AB
   \   000001   2A           ADD       A,R2
   \   000002   F9           MOV       R1,A
   \   000003   E8           MOV       A,R0
   \   000004   2402         ADD       A,#0x2
   \   000006                REQUIRE ??Subroutine43_0
   \   000006                ; // Fall through to label ??Subroutine43_0
   1163          #endif // !DONT_UPGRADE_BIND
   1164          
   1165          #if !defined ( DONT_UPGRADE_BIND )
   1166          /*********************************************************************
   1167           * @fn          BindUpgradeTableInNV
   1168           *
   1169           * @brief       Verifies if the existing table in NV has different size
   1170           *              than the table defined by parameters in the current code.
   1171           *              If different, creates a backup table, deletes the existing
   1172           *              table and creates the new table with the new size. After
   1173           *              this process is done ZCD_NV_BINDING_TABLE NV item contains
   1174           *              only valid records retrieved from the original table, up to
   1175           *              the maximum number of records defined by gNWK_MAX_BINDING_ENTRIES
   1176           *
   1177           * @param       none
   1178           *
   1179           * @return      ZSuccess - the Update process was sucessful.
   1180           *              ZFailure - otherwise.
   1181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1182          static uint8 BindUpgradeTableInNV( void )
   \                     BindUpgradeTableInNV:
   1183          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1184            uint8 status = ZSuccess;
   \   00000A   75..00       MOV       ?V2,#0x0
   1185            nvBindingHdr_t hdr;
   1186            uint16 dupLen;
   1187            uint16 bindLen;
   1188            uint16 newLen;
   1189            bool duplicateReady = FALSE;
   1190          
   1191            // Size of the Binding table based on current paramenters in the code
   1192            newLen = sizeof(nvBindingHdr_t) + NV_BIND_ITEM_SIZE;
   \   00000D   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000010   F5..         MOV       ?V0,A
   \   000012   E4           CLR       A
   \   000013   39           ADDC      A,R1
   \   000014   F5..         MOV       ?V1,A
   1193          
   1194            // Size of the Binding table NV item, this is the whole size of the item,
   1195            // it could inculde invalid records also
   1196            bindLen = osal_nv_item_len( ZCD_NV_BINDING_TABLE );
   \   000016                ; Setup parameters for call to function osal_nv_item_len
   \   000016   7A41         MOV       R2,#0x41
   \   000018   7B00         MOV       R3,#0x0
   \   00001A   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   00001D   8A..         MOV       ?V4,R2
   \   00001F   8B..         MOV       ?V5,R3
   \   000021   AE..         MOV       R6,?V4
   \   000023   AF..         MOV       R7,?V5
   1197          
   1198            // Get the number of valid records from the Binding table
   1199            osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
   \   000025                ; Setup parameters for call to function osal_nv_read
   \   000025   A8..         MOV       R0,?XSP + 0
   \   000027   A9..         MOV       R1,?XSP + 1
   \   000029   88..         MOV       ?V4,R0
   \   00002B   89..         MOV       ?V5,R1
   \   00002D   78..         MOV       R0,#?V4
   \   00002F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV       ?V4,#0x2
   \   000035   75..00       MOV       ?V5,#0x0
   \   000038   78..         MOV       R0,#?V4
   \   00003A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003D   7C00         MOV       R4,#0x0
   \   00003F   7D00         MOV       R5,#0x0
   \   000041   7A41         MOV       R2,#0x41
   \   000043   7B00         MOV       R3,#0x0
   \   000045   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000048   7404         MOV       A,#0x4
   \   00004A   12....       LCALL     ?DEALLOC_XSTACK8
   1200          
   1201            // Identify if there is a duplicate NV item, if it is there, that means an
   1202            // Upgrade process did not finish properly last time
   1203            // The length function will return 0 if the Backup NV ID does not exist.
   1204            dupLen = osal_nv_item_len( ZCD_NV_DUPLICATE_BINDING_TABLE );
   \   00004D                ; Setup parameters for call to function osal_nv_item_len
   \   00004D   7A00         MOV       R2,#0x0
   \   00004F   7B03         MOV       R3,#0x3
   \   000051   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000054   8A..         MOV       ?V4,R2
   \   000056   8B..         MOV       ?V5,R3
   \   000058   A8..         MOV       R0,?V4
   \   00005A   A9..         MOV       R1,?V5
   1205          
   1206            // A duplicate of the original Binding item will be done if:
   1207            // 1) A duplicate NV item DOES NOT exist AND the size of the original Binding
   1208            //    item in NV is different (larger/smaller) than the the length calculated
   1209            //    from the parameters in the code. If they are the same there is no need
   1210            //    to do the Upgrade process.
   1211            // 2) A duplicate NV item exists (probably because the previous upgrade
   1212            //    process was interrupted) and [the original Binding NV items exists AND
   1213            //    has valid recods (it is important to make sure that valid records exist
   1214            //    in the binding table because it is possible that the item was created
   1215            //    but the data was not copied in the previous upgrade process).
   1216            if ( ( ( dupLen == 0 ) && ( bindLen != newLen ) ) ||
   1217                 ( ( dupLen > 0 ) && ( bindLen > 0 ) && ( hdr.numRecs > 0 ) ) )
   \   00005C   E8           MOV       A,R0
   \   00005D   49           ORL       A,R1
   \   00005E   700C         JNZ       ??BindUpgradeTableInNV_0
   \   000060   E5..         MOV       A,?V0
   \   000062   6E           XRL       A,R6
   \   000063   7003         JNZ       ??BindUpgradeTableInNV_1
   \   000065   E5..         MOV       A,?V1
   \   000067   6F           XRL       A,R7
   \                     ??BindUpgradeTableInNV_1:
   \   000068   700D         JNZ       ??BindUpgradeTableInNV_2
   \   00006A   8041         SJMP      ??BindUpgradeTableInNV_3
   \                     ??BindUpgradeTableInNV_0:
   \   00006C   EE           MOV       A,R6
   \   00006D   4F           ORL       A,R7
   \   00006E   602B         JZ        ??BindUpgradeTableInNV_4
   \   000070   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000073   EA           MOV       A,R2
   \   000074   4B           ORL       A,R3
   \   000075   6024         JZ        ??BindUpgradeTableInNV_4
   1218            {
   1219              // Create a copy from original NV item into a duplicate NV item
   1220              if ( ( status = nwkCreateDuplicateNV( ZCD_NV_BINDING_TABLE,
   1221                                                    ZCD_NV_DUPLICATE_BINDING_TABLE ) ) == ZSuccess )
   \                     ??BindUpgradeTableInNV_2:
   \   000077                ; Setup parameters for call to function nwkCreateDuplicateNV
   \   000077   7C00         MOV       R4,#0x0
   \   000079   7D03         MOV       R5,#0x3
   \   00007B   7A41         MOV       R2,#0x41
   \   00007D   7B00         MOV       R3,#0x0
   \   00007F   12....       LCALL     `??nwkCreateDuplicateNV::?relay`; Banked call to: nwkCreateDuplicateNV
   \   000082   E9           MOV       A,R1
   \   000083   F8           MOV       R0,A
   \   000084   88..         MOV       ?V2,R0
   \   000086   7025         JNZ       ??BindUpgradeTableInNV_3
   1222              {
   1223                // Delete the original NV item once the duplicate is ready
   1224                if ( osal_nv_delete( ZCD_NV_BINDING_TABLE, bindLen ) != ZSuccess )
   \   000088                ; Setup parameters for call to function osal_nv_delete
   \   000088   EE           MOV       A,R6
   \   000089   FC           MOV       R4,A
   \   00008A   EF           MOV       A,R7
   \   00008B   FD           MOV       R5,A
   \   00008C   7A41         MOV       R2,#0x41
   \   00008E   7B00         MOV       R3,#0x0
   \   000090   12....       LCALL     `??osal_nv_delete::?relay`; Banked call to: osal_nv_delete
   \   000093   E9           MOV       A,R1
   \   000094   6009         JZ        ??BindUpgradeTableInNV_5
   1225                {
   1226                  status = ZFailure;
   \   000096   75..01       MOV       ?V2,#0x1
   \   000099   8012         SJMP      ??BindUpgradeTableInNV_3
   1227                }
   1228                else
   1229                {
   1230                  duplicateReady = TRUE;
   1231                }
   1232              }
   1233            }
   1234            else if ( ( ( dupLen > 0 ) && ( bindLen == 0 ) ) ||
   1235                      ( ( dupLen > 0 ) && ( bindLen > 0 ) && ( hdr.numRecs == 0 ) ) )
   1236            {
   1237              // If for some reason a duplicate NV item was left in the system from a
   1238              // previous upgrade process and:
   1239              // 1) The original Binding NV item DOES NOT exist OR
   1240              // 2) The original Binding NV item exist, but has no valid records.
   1241              // it is necessary to rely in the data in the Duplicate item to create
   1242              // the Binding table
   1243              bindLen = dupLen;
   \                     ??BindUpgradeTableInNV_4:
   \   00009B   E8           MOV       A,R0
   \   00009C   FE           MOV       R6,A
   \   00009D   E9           MOV       A,R1
   \   00009E   FF           MOV       R7,A
   1244          
   1245              duplicateReady = TRUE;
   1246            }
   1247          
   1248            if ( duplicateReady == TRUE )
   1249            {
   1250              // Creates the New Binding table, Copy data from backup and Delete backup NV ID
   1251              status = BindCopyBackupToNewNV( bindLen, newLen );
   \                     ??BindUpgradeTableInNV_5:
   \   00009F                ; Setup parameters for call to function BindCopyBackupToNewNV
   \   00009F   AC..         MOV       R4,?V0
   \   0000A1   AD..         MOV       R5,?V1
   \   0000A3   EE           MOV       A,R6
   \   0000A4   FA           MOV       R2,A
   \   0000A5   EF           MOV       A,R7
   \   0000A6   FB           MOV       R3,A
   \   0000A7   12....       LCALL     `??BindCopyBackupToNewNV::?relay`; Banked call to: BindCopyBackupToNewNV
   \   0000AA   E9           MOV       A,R1
   \   0000AB   F5..         MOV       ?V2,A
   1252            }
   1253            return ( status );
   \                     ??BindUpgradeTableInNV_3:
   \   0000AD   A9..         MOV       R1,?V2
   \   0000AF   7402         MOV       A,#0x2
   \   0000B1   02....       LJMP      ?Subroutine4 & 0xFFFF
   1254          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine42_0
   \   000006                ; // Fall through to label ??Subroutine42_0
   1255          #endif // !DONT_UPGRADE_BIND
   1256          
   1257          /*********************************************************************
   1258           * @fn          BindRestoreFromNV
   1259           *
   1260           * @brief       Restore the binding table from NV
   1261           *
   1262           * @param       none
   1263           *
   1264           * @return      Number of entries restored
   1265           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1266          uint16 BindRestoreFromNV( void )
   \                     BindRestoreFromNV:
   1267          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1268            nvBindingHdr_t hdr;
   1269          
   1270            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   1271          
   1272          #if !defined ( DONT_UPGRADE_BIND )
   1273            if ( BindUpgradeTableInNV() == ZSuccess )
   \   000014                ; Setup parameters for call to function BindUpgradeTableInNV
   \   000014   12....       LCALL     `??BindUpgradeTableInNV::?relay`; Banked call to: BindUpgradeTableInNV
   \   000017   E9           MOV       A,R1
   \   000018   6003         JZ        $+5
   \   00001A   02....       LJMP      ??BindRestoreFromNV_0 & 0xFFFF
   1274          #endif
   1275            {
   1276              if ( osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr ) == ZSuccess )
   \   00001D                ; Setup parameters for call to function osal_nv_read
   \   00001D   A8..         MOV       R0,?XSP + 0
   \   00001F   A9..         MOV       R1,?XSP + 1
   \   000021   88..         MOV       ?V0,R0
   \   000023   89..         MOV       ?V1,R1
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV       ?V0,#0x2
   \   00002D   75..00       MOV       ?V1,#0x0
   \   000030   78..         MOV       R0,#?V0
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   7C00         MOV       R4,#0x0
   \   000037   7D00         MOV       R5,#0x0
   \   000039   7A41         MOV       R2,#0x41
   \   00003B   7B00         MOV       R3,#0x0
   \   00003D   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000040   7404         MOV       A,#0x4
   \   000042   12....       LCALL     ?DEALLOC_XSTACK8
   \   000045   E9           MOV       A,R1
   \   000046   7061         JNZ       ??BindRestoreFromNV_0
   1277              {
   1278                bindTableIndex_t x;
   1279                uint16 validRecsCount = 0;
   \   000048   7E00         MOV       R6,#0x0
   \   00004A   7F00         MOV       R7,#0x0
   1280          
   1281                // Read in the device list
   1282                for ( x = 0; ( x < gNWK_MAX_BINDING_ENTRIES ) && ( validRecsCount < hdr.numRecs ); x++ )
   \   00004C   75..00       MOV       ?V0,#0x0
   \   00004F   803C         SJMP      ??BindRestoreFromNV_1
   1283                {
   1284                  if ( osal_nv_read( ZCD_NV_BINDING_TABLE,
   1285                                     (uint16)(sizeof(nvBindingHdr_t) + (x * NV_BIND_REC_SIZE)),
   1286                                     NV_BIND_REC_SIZE, &BindingTable[x] ) == ZSUCCESS )
   \                     ??BindRestoreFromNV_2:
   \   000051                ; Setup parameters for call to function osal_nv_read
   \   000051   E5..         MOV       A,?V0
   \   000053   75F00E       MOV       B,#0xe
   \   000056   A4           MUL       AB
   \   000057   F8           MOV       R0,A
   \   000058   A9F0         MOV       R1,B
   \   00005A   74..         MOV       A,#BindingTable & 0xff
   \   00005C   28           ADD       A,R0
   \   00005D   F5..         MOV       ?V2,A
   \   00005F   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000061   39           ADDC      A,R1
   \   000062   F5..         MOV       ?V3,A
   \   000064   78..         MOV       R0,#?V2
   \   000066   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000069   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   00006C   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   00006F   A8..         MOV       R0,?V0
   \   000071   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000074   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000077   7404         MOV       A,#0x4
   \   000079   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007C   E9           MOV       A,R1
   \   00007D   700C         JNZ       ??BindRestoreFromNV_3
   1287                  {
   1288                    if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   \   00007F   E5..         MOV       A,?V0
   \   000081   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000084   6005         JZ        ??BindRestoreFromNV_3
   1289                    {
   1290                      validRecsCount++;
   \   000086   0E           INC       R6
   \   000087   EE           MOV       A,R6
   \   000088   7001         JNZ       ??BindRestoreFromNV_3
   \   00008A   0F           INC       R7
   1291                    }
   1292                  }
   1293                }
   \                     ??BindRestoreFromNV_3:
   \   00008B   05..         INC       ?V0
   \                     ??BindRestoreFromNV_1:
   \   00008D   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000090   E4           CLR       A
   \   000091   93           MOVC      A,@A+DPTR
   \   000092   F8           MOV       R0,A
   \   000093   E5..         MOV       A,?V0
   \   000095   C3           CLR       C
   \   000096   98           SUBB      A,R0
   \   000097   5010         JNC       ??BindRestoreFromNV_0
   \   000099   85..82       MOV       DPL,?XSP + 0
   \   00009C   85..83       MOV       DPH,?XSP + 1
   \   00009F   12....       LCALL     ?Subroutine22 & 0xFFFF
   1294              }
   1295            }
   \                     ??CrossCallReturnLabel_40:
   \   0000A2   C3           CLR       C
   \   0000A3   EE           MOV       A,R6
   \   0000A4   98           SUBB      A,R0
   \   0000A5   EF           MOV       A,R7
   \   0000A6   99           SUBB      A,R1
   \   0000A7   40A8         JC        ??BindRestoreFromNV_2
   1296            return ( hdr.numRecs );
   \                     ??BindRestoreFromNV_0:
   \   0000A9   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0000AC   7402         MOV       A,#0x2
   \   0000AE   02....       LJMP      ?Subroutine3 & 0xFFFF
   1297          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000003   E4           CLR       A
   \   000004   93           MOVC      A,@A+DPTR
   \   000005   F5..         MOV       ?V2,A
   \   000007   7401         MOV       A,#0x1
   \   000009   93           MOVC      A,@A+DPTR
   \   00000A   F5..         MOV       ?V3,A
   \   00000C   E8           MOV       A,R0
   \   00000D   85..F0       MOV       B,?V2
   \   000010   A4           MUL       AB
   \   000011   C8           XCH       A,R0
   \   000012   AAF0         MOV       R2,B
   \   000014   85..F0       MOV       B,?V3
   \   000017   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00001A   22           RET
   1298          
   1299          /*********************************************************************
   1300           * @fn          BindWriteNV
   1301           *
   1302           * @brief       Save the Binding Table in NV
   1303           *
   1304           * @param       none
   1305           *
   1306           * @return      none
   1307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1308          void BindWriteNV( void )
   \                     BindWriteNV:
   1309          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1310            BindingEntry_t *pBind;
   1311            BindingEntry_t bind;
   1312            nvBindingHdr_t hdr;
   1313            bindTableIndex_t x;
   1314          
   1315            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   1316          
   1317            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   \   000014   7E00         MOV       R6,#0x0
   \   000016   805E         SJMP      ??BindWriteNV_0
   1318            {
   1319              pBind = &BindingTable[x];
   \                     ??BindWriteNV_1:
   \   000018   EE           MOV       A,R6
   \   000019   75F00E       MOV       B,#0xe
   \   00001C   A4           MUL       AB
   \   00001D   F8           MOV       R0,A
   \   00001E   A9F0         MOV       R1,B
   \   000020   74..         MOV       A,#BindingTable & 0xff
   \   000022   28           ADD       A,R0
   \   000023   F5..         MOV       ?V0,A
   \   000025   74..         MOV       A,#(BindingTable >> 8) & 0xff
   \   000027   39           ADDC      A,R1
   \   000028   F5..         MOV       ?V1,A
   1320          
   1321              osal_memcpy( &bind, pBind, gBIND_REC_SIZE );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   85....       MOV       ?V4,?V0
   \   00002D   F5..         MOV       ?V5,A
   \   00002F   75..00       MOV       ?V6,#0x0
   \   000032   78..         MOV       R0,#?V4
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000037   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00003A   7405         MOV       A,#0x5
   \   00003C   12....       LCALL     ?XSTACK_DISP101_8
   \   00003F   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000042   7403         MOV       A,#0x3
   \   000044   12....       LCALL     ?DEALLOC_XSTACK8
   1322          
   1323              // Save the record to NV
   1324              osal_nv_write( ZCD_NV_BINDING_TABLE,
   1325                             (uint16)((sizeof(nvBindingHdr_t)) + (x * NV_BIND_REC_SIZE)),
   1326                             NV_BIND_REC_SIZE, &bind );
   \   000047                ; Setup parameters for call to function osal_nv_write
   \   000047   7402         MOV       A,#0x2
   \   000049   12....       LCALL     ?XSTACK_DISP100_8
   \   00004C   88..         MOV       ?V2,R0
   \   00004E   89..         MOV       ?V3,R1
   \   000050   78..         MOV       R0,#?V2
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000055   90....       MOV       DPTR,#gBIND_REC_SIZE
   \   000058   12....       LCALL     ?PUSH_XSTACK8_C_TWO
   \   00005B   EE           MOV       A,R6
   \   00005C   F8           MOV       R0,A
   \   00005D   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000060   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000063   7404         MOV       A,#0x4
   \   000065   12....       LCALL     ?DEALLOC_XSTACK8
   1327          
   1328              if ( pBind->srcEP != NV_BIND_EMPTY )
   \   000068   85..82       MOV       DPL,?V0
   \   00006B   85..83       MOV       DPH,?V1
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   F4           CPL       A
   \   000070   6003         JZ        ??CrossCallReturnLabel_42
   1329              {
   1330                hdr.numRecs++;
   \   000072   12....       LCALL     ?Subroutine24 & 0xFFFF
   1331              }
   1332            }
   \                     ??CrossCallReturnLabel_42:
   \   000075   0E           INC       R6
   \                     ??BindWriteNV_0:
   \   000076   90....       MOV       DPTR,#gNWK_MAX_BINDING_ENTRIES
   \   000079   E4           CLR       A
   \   00007A   93           MOVC      A,@A+DPTR
   \   00007B   F8           MOV       R0,A
   \   00007C   EE           MOV       A,R6
   \   00007D   C3           CLR       C
   \   00007E   98           SUBB      A,R0
   \   00007F   4097         JC        ??BindWriteNV_1
   1333          
   1334            // Save off the header
   1335            osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
   \   000081                ; Setup parameters for call to function osal_nv_write
   \   000081   A8..         MOV       R0,?XSP + 0
   \   000083   A9..         MOV       R1,?XSP + 1
   \   000085   88..         MOV       ?V0,R0
   \   000087   89..         MOV       ?V1,R1
   \   000089   78..         MOV       R0,#?V0
   \   00008B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008E   75..02       MOV       ?V0,#0x2
   \   000091   75..00       MOV       ?V1,#0x0
   \   000094   78..         MOV       R0,#?V0
   \   000096   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000099   7C00         MOV       R4,#0x0
   \   00009B   7D00         MOV       R5,#0x0
   \   00009D   7A41         MOV       R2,#0x41
   \   00009F   7B00         MOV       R3,#0x0
   \   0000A1   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000A4   7404         MOV       A,#0x4
   \   0000A6   12....       LCALL     ?DEALLOC_XSTACK8
   1336          }
   \   0000A9   7410         MOV       A,#0x10
   \   0000AB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000AE   7F07         MOV       R7,#0x7
   \   0000B0   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??InitBindingTable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    InitBindingTable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindFindEmpty::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindFindEmpty

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindNumOfEntries::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindNumOfEntries

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindCapacity::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindCapacity

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindIsClusterIDinList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindIsClusterIDinList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveClusterIdFromList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveClusterIdFromList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddClusterIdToList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddClusterIdToList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindFindExisting::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindFindExisting

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveDev::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveDev

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindRemoveSrcDev::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindRemoveSrcDev

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindNumBoundTo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindNumBoundTo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindNumReflections::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindNumReflections

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindFind::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindFind

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddressClear::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddressClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindUpdateAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindUpdateAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindingAddrMgsHelperFind::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindingAddrMgsHelperFind

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindingAddrMgsHelperConvert::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindingAddrMgsHelperConvert

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindingAddrMgsHelperConvertShort::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindingAddrMgsHelperConvertShort

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddrMgrLocalLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddrMgrLocalLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bindAddrIndexGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bindAddrIndexGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??GetBindingTableEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GetBindingTableEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindInitNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindCopyBackupToNewNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindCopyBackupToNewNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindUpgradeTableInNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindUpgradeTableInNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindRestoreFromNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BindWriteNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BindWriteNV
   1337          
   1338          #else // !BINDINGTABLE_NV_SINGLES
   1339          /*********************************************************************
   1340           * @fn          BindInitNV
   1341           *
   1342           * @brief       Initialize the Binding NV Item
   1343           *
   1344           * @param       none
   1345           *
   1346           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1347           *              exist in NV, NV_OPER_FAILED if failure.
   1348           */
   1349          byte BindInitNV( void )
   1350          {
   1351            bindTableIndex_t x;
   1352          
   1353            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1354            {
   1355              // Initialize each binding record
   1356              osal_nv_item_init_ex( ZCD_NV_EX_BINDING_TABLE, x, NV_BIND_REC_SIZE, NULL );
   1357            }
   1358            return ( ZSUCCESS );
   1359          }
   1360          
   1361          /*********************************************************************
   1362           * @fn          BindSetDefaultNV
   1363           *
   1364           * @brief       Write the defaults to NV
   1365           *
   1366           * @param       none
   1367           *
   1368           * @return      none
   1369           */
   1370          void BindSetDefaultNV( void )
   1371          {
   1372            BindingEntry_t bind;
   1373            bindTableIndex_t x;
   1374          
   1375            // Initialize a binding record
   1376            osal_memset( &bind, 0xFF, sizeof ( BindingEntry_t ) );
   1377          
   1378            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1379            {
   1380              // Over write each binding record with an "empty" record
   1381              osal_nv_write_ex( ZCD_NV_EX_BINDING_TABLE, x, 0, NV_BIND_REC_SIZE, &bind );
   1382            }
   1383          }
   1384          
   1385          /*********************************************************************
   1386           * @fn          BindRestoreFromNV
   1387           *
   1388           * @brief       Restore the binding table from NV
   1389           *
   1390           * @param       none
   1391           *
   1392           * @return      Number of entries restored (non-emtpy)
   1393           */
   1394          uint16 BindRestoreFromNV( void )
   1395          {
   1396            bindTableIndex_t x;
   1397            uint16 validRecsCount = 0;
   1398          
   1399            // Read in the device list
   1400            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1401            {
   1402              if ( osal_nv_read_ex( ZCD_NV_EX_BINDING_TABLE, x, 0,
   1403                               (uint16)NV_BIND_REC_SIZE, &BindingTable[x] ) == ZSUCCESS )
   1404              {
   1405                // Check for non-empty record
   1406                if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
   1407                {
   1408                  // Count non-empty records
   1409                  validRecsCount++;
   1410                }
   1411              }
   1412            }
   1413            return ( validRecsCount );
   1414          }
   1415          
   1416          /*********************************************************************
   1417           * @fn          BindWriteNV
   1418           *
   1419           * @brief       Copy the Binding Table in NV
   1420           *
   1421           * @param       none
   1422           *
   1423           * @return      none
   1424           */
   1425          void BindWriteNV( void )
   1426          {
   1427            bindTableIndex_t x;
   1428          
   1429            for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
   1430            {
   1431              // Save the record to NV
   1432              osal_nv_write_ex( ZCD_NV_EX_BINDING_TABLE, x, 0,
   1433                               (uint16)NV_BIND_REC_SIZE, &BindingTable[x] );
   1434            }
   1435          }
   1436          #endif // BINDINGTABLE_NV_SINGLES
   1437          
   1438          /*********************************************************************
   1439          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     52   BindCopyBackupToNewNV
        0     32   -> osal_nv_delete
        0     34   -> osal_nv_item_init
        0     32   -> osal_nv_item_len
        0     36   -> osal_nv_read
        0     36   -> osal_nv_write
      0     12   BindInitNV
        0     10   -> BindSetDefaultNV
        0     12   -> osal_nv_item_init
      0     18   BindRestoreFromNV
        0     14   -> BindUpgradeTableInNV
        0     18   -> osal_nv_read
      0     26   BindSetDefaultNV
        0     16   -> osal_nv_write
      0     34   BindUpgradeTableInNV
        0     16   -> BindCopyBackupToNewNV
        0     16   -> nwkCreateDuplicateNV
        0     16   -> osal_nv_delete
        0     16   -> osal_nv_item_len
        0     20   -> osal_nv_read
      0     35   BindWriteNV
        0     34   -> osal_memcpy
        0     35   -> osal_nv_write
      0      9   GetBindingTableEntry
      0     10   InitBindingTable
        0     10   -> osal_memset
      0     29   bindAddClusterIdToList
      1     25   bindAddEntry
        0     20   -> bindAddClusterIdToList
        0     20   -> bindAddrIndexGet
        0     20   -> bindAddrMgrLocalLoad
        0     20   -> bindFindEmpty
        0     20   -> bindIsClusterIDinList
        0     23   -> osal_memcpy
      2     33   bindAddrIndexGet
        2     13   -> AddrMgrEntryLookupExt
        2     13   -> AddrMgrEntryLookupNwk
        2     13   -> AddrMgrEntryUpdate
        2     13   -> AddrMgrExtAddrSet
      0     43   bindAddrMgrLocalLoad
        0     23   -> AddrMgrEntryUpdate
        0     23   -> AddrMgrExtAddrSet
        0     23   -> NLME_GetCoordExtAddr
        0     23   -> NLME_GetCoordShortAddr
        0     23   -> NLME_GetExtAddr
      2     25   bindAddressClear
        2     13   -> AddrMgrEntryRelease
      0      9   bindCapacity
      0     14   bindFind
        0     14   -> bindIsClusterIDinList
      2     20   bindFindEmpty
      0     12   bindFindExisting
        0     12   -> bindingAddrMgsHelperFind
      0     29   bindIsClusterIDinList
      0     14   bindNumBoundTo
        0     14   -> bindingAddrMgsHelperFind
      2      0   bindNumOfEntries
      0     12   bindNumReflections
        0     12   -> bindIsClusterIDinList
      0     11   bindRemoveClusterIdFromList
      0     12   bindRemoveDev
        0     12   -> bindAddressClear
        0     12   -> bindRemoveEntry
        0     12   -> bindingAddrMgsHelperFind
      2     12   bindRemoveEntry
        2      0   -> osal_memset
      0     10   bindRemoveSrcDev
        0     10   -> bindAddressClear
        0     10   -> bindRemoveEntry
      0     21   bindUpdateAddr
        0     21   -> bindingAddrMgsHelperFind
      0     22   bindingAddrMgsHelperConvert
        0     22   -> AddrMgrEntryGet
        0     22   -> sAddrExtCpy
      2     13   bindingAddrMgsHelperConvertShort
        2     13   -> AddrMgrEntryGet
      2     34   bindingAddrMgsHelperFind
        2     13   -> AddrMgrEntryLookupExt
        2     13   -> AddrMgrEntryLookupNwk
        2     13   -> AddrMgrExtAddrSet


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine33_0
       5  ??Subroutine34_0
       5  ??Subroutine35_0
       5  ??Subroutine36_0
       9  ??Subroutine37_0
       5  ??Subroutine38_0
       6  ??Subroutine39_0
       5  ??Subroutine40_0
       7  ??Subroutine41_0
       6  ??Subroutine42_0
       9  ??Subroutine43_0
       3  ?Subroutine0
       2  ?Subroutine1
      11  ?Subroutine10
      13  ?Subroutine11
       6  ?Subroutine12
      11  ?Subroutine13
       9  ?Subroutine14
       4  ?Subroutine15
       4  ?Subroutine16
       7  ?Subroutine17
      10  ?Subroutine18
      25  ?Subroutine19
       5  ?Subroutine2
      10  ?Subroutine20
       8  ?Subroutine21
       6  ?Subroutine22
       6  ?Subroutine23
      16  ?Subroutine24
       5  ?Subroutine25
       7  ?Subroutine26
      11  ?Subroutine27
      11  ?Subroutine28
      11  ?Subroutine29
       3  ?Subroutine3
       6  ?Subroutine30
      15  ?Subroutine31
       5  ?Subroutine32
       3  ?Subroutine4
      27  ?Subroutine5
      36  ?Subroutine6
       7  ?Subroutine7
      27  ?Subroutine8
      26  ?Subroutine9
     397  BindCopyBackupToNewNV
       6  BindCopyBackupToNewNV::?relay
      41  BindInitNV
       6  BindInitNV::?relay
     177  BindRestoreFromNV
       6  BindRestoreFromNV::?relay
      65  BindSetDefaultNV
       6  BindSetDefaultNV::?relay
     180  BindUpgradeTableInNV
       6  BindUpgradeTableInNV::?relay
     179  BindWriteNV
       6  BindWriteNV::?relay
      83  GetBindingTableEntry
       6  GetBindingTableEntry::?relay
     116  InitBindingTable
       6  InitBindingTable::?relay
      68  bindAddClusterIdToList
       6  bindAddClusterIdToList::?relay
     320  bindAddEntry
       6  bindAddEntry::?relay
     132  bindAddrIndexGet
       6  bindAddrIndexGet::?relay
     144  bindAddrMgrLocalLoad
       6  bindAddrMgrLocalLoad::?relay
       1  bindAddrMgrLocalLoaded
      82  bindAddressClear
       6  bindAddressClear::?relay
      62  bindCapacity
       6  bindCapacity::?relay
      97  bindFind
       6  bindFind::?relay
      38  bindFindEmpty
       6  bindFindEmpty::?relay
     200  bindFindExisting
       6  bindFindExisting::?relay
      69  bindIsClusterIDinList
       6  bindIsClusterIDinList::?relay
     161  bindNumBoundTo
       6  bindNumBoundTo::?relay
      50  bindNumOfEntries
       6  bindNumOfEntries::?relay
      69  bindNumReflections
       6  bindNumReflections::?relay
     139  bindRemoveClusterIdFromList
       6  bindRemoveClusterIdFromList::?relay
     155  bindRemoveDev
       6  bindRemoveDev::?relay
      17  bindRemoveEntry
       6  bindRemoveEntry::?relay
      77  bindRemoveSrcDev
       6  bindRemoveSrcDev::?relay
     112  bindUpdateAddr
       6  bindUpdateAddr::?relay
      78  bindingAddrMgsHelperConvert
       6  bindingAddrMgsHelperConvert::?relay
      34  bindingAddrMgsHelperConvertShort
       6  bindingAddrMgsHelperConvertShort::?relay
      58  bindingAddrMgsHelperFind
       6  bindingAddrMgsHelperFind::?relay
       2  pBindInitNV
       2  pBindRestoreFromNV
       2  pBindSetDefaultNV
       2  pBindWriteNV
       2  pbindAddEntry
       2  pbindNumOfEntries
       2  pbindRemoveDev

 
 3 823 bytes in segment BANKED_CODE
   174 bytes in segment BANK_RELAYS
    15 bytes in segment XDATA_Z
 
   174 bytes of CODE     memory
 3 823 bytes of HUGECODE memory
    15 bytes of XDATA    memory

Errors: none
Warnings: none
