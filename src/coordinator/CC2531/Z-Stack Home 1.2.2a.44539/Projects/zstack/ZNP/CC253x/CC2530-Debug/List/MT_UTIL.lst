###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               16/Feb/2018  21:40:05
# Copyright 2004-2017 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 10.10
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Components\mt\MT_UTIL.c
#    Command line       =  
#        -f C:\Users\Oskar\AppData\Local\Temp\EW4CC.tmp ("C:\Texas
#        Instruments\Z-Stack Home 1.2.2a.44539\Components\mt\MT_UTIL.c" -D
#        FEATURE_SYSTEM_STATS -D POWER_SAVING -D xTC_LINKKEY_JOIN -lC "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\List" -lA
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\Source\znp.cfg"
#        (-DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        "-DZSTACK_DEVICE_BUILD=(DEVICE_BUILD_COORDINATOR | DEVICE_BUILD_ROUTER
#        | DEVICE_BUILD_ENDDEVICE)" -DNWK_AUTO_POLL -DZNP_RUN_WDOG=FALSE
#        -DZNP_UART_BAUD=HAL_UART_BR_115200 -DZIGBEEPRO -DZIGBEE_FRAGMENTATION
#        -DINTER_PAN -DOSAL_CLOCK -DOSAL_SAPI=FALSE -DSAPI_CB_FUNC=FALSE
#        -DHOLD_AUTO_START -DNV_RESTORE -DNV_INIT -DNUM_DISC_ATTEMPTS=0
#        -DMT_UTIL_FUNC -DMT_SYS_FUNC -DMT_AF_FUNC -DMT_SAPI_FUNC
#        -DMT_SAPI_CB_FUNC -DMT_ZDO_CB_FUNC -DMT_ZDO_FUNC -DMT_ZDO_MGMT
#        -DMT_ZDO_EXTENSIONS -DMT_APP_FUNC) -f "C:\Texas Instruments\Z-Stack
#        Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
#        -f "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\SE\Source\" -I "C:\Texas
#        Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\ZMain\TI2530ZNP\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\hal\target\CC2530ZNP\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\mt\" -I
#        "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary163\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\ecc\binary283\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  German_Germany.1252
#    List file          =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\List\MT_UTIL.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Home
#        1.2.2a.44539\Projects\zstack\ZNP\CC253x\CC2530-Debug\Obj\MT_UTIL.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Home 1.2.2a.44539\Components\mt\MT_UTIL.c
      1          /***************************************************************************************************
      2            Filename:       MT_UTIL.c
      3            Revised:        $Date: 2015-01-26 08:25:50 -0800 (Mon, 26 Jan 2015) $
      4            Revision:       $Revision: 42025 $
      5          
      6            Description:    MonitorTest Utility Functions
      7          
      8            Copyright 2007-2015 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License"). You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product. Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38           ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          
     45          #include "AddrMgr.h"
     46          
     47          #include "OnBoard.h"   /* This is here because of the key reading */

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     48          #include "hal_key.h"
     49          #include "hal_led.h"
     50          #include "OSAL_Nv.h"
     51          #include "osal.h"
     52          #include "NLMEDE.h"
     53          #include "MT.h"
     54          #include "MT_UTIL.h"
     55          #include "MT_MAC.h"
     56          #include "ssp.h"
     57          #if defined ZCL_KEY_ESTABLISH
     58          #include "zcl_key_establish.h"
     59          #include "zcl_se.h"
     60          #endif
     61          
     62          #if !defined NONWK
     63          #include "MT_ZDO.h"
     64          #include "MT_SAPI.h"
     65          #include "MT_NWK.h"
     66          #include "MT_AF.h"
     67          #include "AssocList.h"
     68          #include "ZDApp.h"
     69          #include "ZDSecMgr.h"
     70          #endif
     71          
     72          #if defined MT_SRNG
     73          #include "hal_srng.h"
     74          #endif
     75          
     76          #if defined FEATURE_DUAL_MAC
     77          #include "dmmgr.h"
     78          #endif
     79          
     80          /***************************************************************************************************
     81           * CONSTANTS
     82           ***************************************************************************************************/
     83          #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
     84          #define MT_UTIL_STATUS_LEN    1
     85          #define MT_UTIL_FRM_CTR_LEN   4
     86          // Status + LinkKeyDataLen + Tx+Rx Frame counter.
     87          #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
     88          // Status + NV id
     89          #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
     90          
     91          /***************************************************************************************************
     92           * LOCAL VARIABLES
     93           ***************************************************************************************************/
     94          #if defined ZCL_KEY_ESTABLISH
     95          uint8 zcl_key_establish_task_id;
     96          #endif
     97          
     98          #ifdef FEATURE_GET_PRIMARY_IEEE
     99          /* This feature is not compatible with MSP430 or ARM platforms. */
    100          __no_init const __xdata char ieeeMac[1] @ 0x780C;
    101          #endif
    102          
    103          /***************************************************************************************************
    104           * LOCAL FUNCTIONS
    105           ***************************************************************************************************/
    106          #ifdef AUTO_PEND
    107          static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
    108          static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
    109          #endif
    110          
    111          #if defined (MT_UTIL_FUNC)
    112          static void MT_UtilGetDeviceInfo(void);
    113          static void MT_UtilGetNvInfo(void);
    114          static void MT_UtilSetPanID(uint8 *pBuf);
    115          static void MT_UtilSetChannels(uint8 *pBuf);
    116          static void MT_UtilSetSecLevel(uint8 *pBuf);
    117          static void MT_UtilSetPreCfgKey(uint8 *pBuf);
    118          static void MT_UtilCallbackSub(uint8 *pData);
    119          static void MT_UtilTimeAlive(void);
    120          static void MT_UtilSrcMatchEnable (uint8 *pBuf);
    121          static void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
    122          static void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
    123          static void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
    124          static void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
    125          static void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
    126          
    127          static void MT_UtilGpioSetDirection(uint8 *pBuf);
    128          static void MT_UtilGpioRead(uint8 *pBuf);
    129          static void MT_UtilGpioWrite(uint8 *pBuf);
    130          
    131          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    132          static void MT_UtilKeyEvent(uint8 *pBuf);
    133          #endif
    134          
    135          #if (defined HAL_LED) && (HAL_LED == TRUE)
    136          static void MT_UtilLedControl(uint8 *pBuf);
    137          #endif
    138          
    139          #ifdef MT_SRNG
    140          static void MT_UtilSrngGen(void);
    141          #endif
    142          
    143          #ifdef FEATURE_GET_PRIMARY_IEEE
    144          static void MT_UtilGetPrimaryIEEE(void);
    145          #endif
    146          
    147          #if !defined NONWK
    148          static void MT_UtilDataReq(uint8 *pBuf);
    149          static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf);
    150          static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
    151          #if defined MT_SYS_KEY_MANAGEMENT
    152          static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
    153          static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
    154          #endif //MT_SYS_KEY_MANAGEMENT
    155          static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
    156          static void MT_UtilAssocCount(uint8 *pBuf);
    157          static void MT_UtilAssocFindDevice(uint8 *pBuf);
    158          static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
    159          static void MT_UtilBindAddEntry(uint8 *pBuf);
    160          static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
    161          static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind);
    162          #if defined ZCL_KEY_ESTABLISH
    163          static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
    164          static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
    165          #endif // ZCL_KEY_ESTABLISH
    166          static void MT_UtilSync(void);
    167          #endif // !defined NONWK
    168          #endif // MT_UTIL_FUNC
    169          
    170          #if defined (MT_UTIL_FUNC)
    171          /***************************************************************************************************
    172          * @fn      MT_UtilProcessing
    173          *
    174          * @brief   Process all the DEBUG commands that are issued by test tool
    175          *
    176          * @param   pBuf  - pointer to received SPI data message
    177          *
    178          * @return  status
    179          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          uint8 MT_UtilCommandProcessing(uint8 *pBuf)
   \                     MT_UtilCommandProcessing:
    181          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 62
   \   000005   74C2         MOV       A,#-0x3e
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
    182            uint8 status = MT_RPC_SUCCESS;
   \   00000E   7F00         MOV       R7,#0x0
    183          
    184            switch (pBuf[MT_RPC_POS_CMD1])
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   7003         JNZ       $+5
   \   000019   02....       LJMP      ??MT_UtilCommandProcessing_0 & 0xFFFF
   \   00001C   14           DEC       A
   \   00001D   7003         JNZ       $+5
   \   00001F   02....       LJMP      ??MT_UtilCommandProcessing_1 & 0xFFFF
   \   000022   14           DEC       A
   \   000023   7003         JNZ       $+5
   \   000025   02....       LJMP      ??MT_UtilCommandProcessing_2 & 0xFFFF
   \   000028   14           DEC       A
   \   000029   7003         JNZ       $+5
   \   00002B   02....       LJMP      ??MT_UtilCommandProcessing_3 & 0xFFFF
   \   00002E   14           DEC       A
   \   00002F   7003         JNZ       $+5
   \   000031   02....       LJMP      ??MT_UtilCommandProcessing_4 & 0xFFFF
   \   000034   14           DEC       A
   \   000035   7003         JNZ       $+5
   \   000037   02....       LJMP      ??MT_UtilCommandProcessing_5 & 0xFFFF
   \   00003A   14           DEC       A
   \   00003B   7003         JNZ       $+5
   \   00003D   02....       LJMP      ??MT_UtilCommandProcessing_6 & 0xFFFF
   \   000040   14           DEC       A
   \   000041   7003         JNZ       $+5
   \   000043   02....       LJMP      ??MT_UtilCommandProcessing_7 & 0xFFFF
   \   000046   24FE         ADD       A,#-0x2
   \   000048   7003         JNZ       $+5
   \   00004A   02....       LJMP      ??MT_UtilCommandProcessing_8 & 0xFFFF
   \   00004D   14           DEC       A
   \   00004E   7003         JNZ       $+5
   \   000050   02....       LJMP      ??MT_UtilCommandProcessing_7 & 0xFFFF
   \   000053   24FA         ADD       A,#-0x6
   \   000055   7003         JNZ       $+5
   \   000057   02....       LJMP      ??MT_UtilCommandProcessing_9 & 0xFFFF
   \   00005A   14           DEC       A
   \   00005B   7003         JNZ       $+5
   \   00005D   02....       LJMP      ??MT_UtilCommandProcessing_10 & 0xFFFF
   \   000060   24FD         ADD       A,#-0x3
   \   000062   7003         JNZ       $+5
   \   000064   02....       LJMP      ??MT_UtilCommandProcessing_11 & 0xFFFF
   \   000067   14           DEC       A
   \   000068   7003         JNZ       $+5
   \   00006A   02....       LJMP      ??MT_UtilCommandProcessing_12 & 0xFFFF
   \   00006D   14           DEC       A
   \   00006E   7003         JNZ       $+5
   \   000070   02....       LJMP      ??MT_UtilCommandProcessing_13 & 0xFFFF
   \   000073   24F6         ADD       A,#-0xa
   \   000075   7003         JNZ       $+5
   \   000077   02....       LJMP      ??MT_UtilCommandProcessing_14 & 0xFFFF
   \   00007A   14           DEC       A
   \   00007B   7003         JNZ       $+5
   \   00007D   02....       LJMP      ??MT_UtilCommandProcessing_14 & 0xFFFF
   \   000080   14           DEC       A
   \   000081   7003         JNZ       $+5
   \   000083   02....       LJMP      ??MT_UtilCommandProcessing_14 & 0xFFFF
   \   000086   14           DEC       A
   \   000087   7003         JNZ       $+5
   \   000089   02....       LJMP      ??MT_UtilCommandProcessing_15 & 0xFFFF
   \   00008C   14           DEC       A
   \   00008D   7003         JNZ       $+5
   \   00008F   02....       LJMP      ??MT_UtilCommandProcessing_14 & 0xFFFF
   \   000092   14           DEC       A
   \   000093   7003         JNZ       $+5
   \   000095   02....       LJMP      ??MT_UtilCommandProcessing_16 & 0xFFFF
   \   000098   24E5         ADD       A,#-0x1b
   \   00009A   7003         JNZ       $+5
   \   00009C   02....       LJMP      ??MT_UtilCommandProcessing_17 & 0xFFFF
   \   00009F   14           DEC       A
   \   0000A0   7003         JNZ       $+5
   \   0000A2   02....       LJMP      ??MT_UtilCommandProcessing_18 & 0xFFFF
   \   0000A5   24F9         ADD       A,#-0x7
   \   0000A7   7003         JNZ       $+5
   \   0000A9   02....       LJMP      ??MT_UtilCommandProcessing_19 & 0xFFFF
   \   0000AC   14           DEC       A
   \   0000AD   7003         JNZ       $+5
   \   0000AF   02....       LJMP      ??MT_UtilCommandProcessing_20 & 0xFFFF
   \   0000B2   14           DEC       A
   \   0000B3   7003         JNZ       $+5
   \   0000B5   02....       LJMP      ??MT_UtilCommandProcessing_21 & 0xFFFF
   \   0000B8   14           DEC       A
   \   0000B9   7003         JNZ       $+5
   \   0000BB   02....       LJMP      ??MT_UtilCommandProcessing_22 & 0xFFFF
   \   0000BE   24FE         ADD       A,#-0x2
   \   0000C0   7003         JNZ       $+5
   \   0000C2   02....       LJMP      ??MT_UtilCommandProcessing_23 & 0xFFFF
   \   0000C5   246D         ADD       A,#0x6d
   \   0000C7   7003         JNZ       $+5
   \   0000C9   02....       LJMP      ??MT_UtilCommandProcessing_24 & 0xFFFF
   \   0000CC   02....       LJMP      ??MT_UtilCommandProcessing_25 & 0xFFFF
    185            {
    186              // CC253X MAC Network Processor does not have NV support
    187          #if !defined(CC253X_MACNP)
    188            case MT_UTIL_GET_DEVICE_INFO:
    189              MT_UtilGetDeviceInfo();
   \                     ??MT_UtilCommandProcessing_0:
   \   0000CF                ; Setup parameters for call to function MT_UtilGetDeviceInfo
   \   0000CF   12....       LCALL     `??MT_UtilGetDeviceInfo::?relay`; Banked call to: MT_UtilGetDeviceInfo
    190              break;
   \   0000D2   02....       LJMP      ??MT_UtilCommandProcessing_7 & 0xFFFF
    191          
    192            case MT_UTIL_GET_NV_INFO:
    193              MT_UtilGetNvInfo();
   \                     ??MT_UtilCommandProcessing_1:
   \   0000D5                ; Setup parameters for call to function MT_UtilGetNvInfo
   \   0000D5   12....       LCALL     `??MT_UtilGetNvInfo::?relay`; Banked call to: MT_UtilGetNvInfo
    194              break;
   \   0000D8   02....       LJMP      ??MT_UtilCommandProcessing_7 & 0xFFFF
    195          
    196            case MT_UTIL_SET_PANID:
    197              MT_UtilSetPanID(pBuf);
   \                     ??MT_UtilCommandProcessing_2:
   \   0000DB   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   0000DE   12....       LCALL     `??osal_build_uint16::?relay`; Banked call to: osal_build_uint16
   \   0000E1   7401         MOV       A,#0x1
   \   0000E3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E6   EA           MOV       A,R2
   \   0000E7   F0           MOVX      @DPTR,A
   \   0000E8   A3           INC       DPTR
   \   0000E9   EB           MOV       A,R3
   \   0000EA   F0           MOVX      @DPTR,A
   \   0000EB                ; Setup parameters for call to function osal_nv_item_len
   \   0000EB   7A83         MOV       R2,#-0x7d
   \   0000ED   7B00         MOV       R3,#0x0
   \   0000EF   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   0000F2   8A..         MOV       ?V0,R2
   \   0000F4   8B..         MOV       ?V1,R3
   \   0000F6                ; Setup parameters for call to function osal_nv_write
   \   0000F6   7401         MOV       A,#0x1
   \   0000F8   12....       LCALL     ?XSTACK_DISP100_8
   \   0000FB   88..         MOV       ?V2,R0
   \   0000FD   89..         MOV       ?V3,R1
   \   0000FF   78..         MOV       R0,#?V2
   \   000101   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000104   78..         MOV       R0,#?V0
   \   000106   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000109   7C00         MOV       R4,#0x0
   \   00010B   7D00         MOV       R5,#0x0
   \   00010D   7A83         MOV       R2,#-0x7d
   \   00010F   02....       LJMP      ??MT_UtilCommandProcessing_26 & 0xFFFF
    198              break;
    199          
    200            case MT_UTIL_SET_CHANNELS:
    201              MT_UtilSetChannels(pBuf);
   \                     ??MT_UtilCommandProcessing_3:
   \   000112   8A82         MOV       DPL,R2
   \   000114   8B83         MOV       DPH,R3
   \   000116   A3           INC       DPTR
   \   000117   A3           INC       DPTR
   \   000118   E0           MOVX      A,@DPTR
   \   000119   FE           MOV       R6,A
   \   00011A                ; Setup parameters for call to function osal_build_uint32
   \   00011A   7904         MOV       R1,#0x4
   \   00011C   12....       LCALL     ??Subroutine26_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00011F   12....       LCALL     `??osal_build_uint32::?relay`; Banked call to: osal_build_uint32
   \   000122   EA           MOV       A,R2
   \   000123   F8           MOV       R0,A
   \   000124   EB           MOV       A,R3
   \   000125   F9           MOV       R1,A
   \   000126   EC           MOV       A,R4
   \   000127   FA           MOV       R2,A
   \   000128   ED           MOV       A,R5
   \   000129   FB           MOV       R3,A
   \   00012A   7403         MOV       A,#0x3
   \   00012C   12....       LCALL     ?XSTACK_DISP0_8
   \   00012F   12....       LCALL     ?XSTORE_R0123
   \   000132                ; Setup parameters for call to function osal_nv_item_len
   \   000132   7A84         MOV       R2,#-0x7c
   \   000134   7B00         MOV       R3,#0x0
   \   000136   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000139   8A..         MOV       ?V0,R2
   \   00013B   8B..         MOV       ?V1,R3
   \   00013D                ; Setup parameters for call to function osal_nv_write
   \   00013D   7403         MOV       A,#0x3
   \   00013F   12....       LCALL     ?XSTACK_DISP100_8
   \   000142   88..         MOV       ?V2,R0
   \   000144   89..         MOV       ?V3,R1
   \   000146   78..         MOV       R0,#?V2
   \   000148   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014B   78..         MOV       R0,#?V0
   \   00014D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000150   7C00         MOV       R4,#0x0
   \   000152   7D00         MOV       R5,#0x0
   \   000154   7A84         MOV       R2,#-0x7c
   \   000156   805C         SJMP      ??MT_UtilCommandProcessing_26
    202              break;
    203          
    204            case MT_UTIL_SET_SECLEVEL:
    205              MT_UtilSetSecLevel(pBuf);
   \                     ??MT_UtilCommandProcessing_4:
   \   000158   8A82         MOV       DPL,R2
   \   00015A   8B83         MOV       DPH,R3
   \   00015C   A3           INC       DPTR
   \   00015D   A3           INC       DPTR
   \   00015E   E0           MOVX      A,@DPTR
   \   00015F   FE           MOV       R6,A
   \   000160                ; Setup parameters for call to function osal_nv_item_len
   \   000160   7A61         MOV       R2,#0x61
   \   000162   7B00         MOV       R3,#0x0
   \   000164   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000167   8A..         MOV       ?V2,R2
   \   000169   8B..         MOV       ?V3,R3
   \   00016B                ; Setup parameters for call to function osal_nv_write
   \   00016B   E5..         MOV       A,?V0
   \   00016D   2403         ADD       A,#0x3
   \   00016F   F5..         MOV       ?V0,A
   \   000171   5002         JNC       ??MT_UtilCommandProcessing_27
   \   000173   05..         INC       ?V1
   \                     ??MT_UtilCommandProcessing_27:
   \   000175   78..         MOV       R0,#?V0
   \   000177   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00017A   78..         MOV       R0,#?V2
   \   00017C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00017F   7C00         MOV       R4,#0x0
   \   000181   7D00         MOV       R5,#0x0
   \   000183   7A61         MOV       R2,#0x61
   \   000185   802D         SJMP      ??MT_UtilCommandProcessing_26
    206              break;
    207          
    208            case MT_UTIL_SET_PRECFGKEY:
    209              MT_UtilSetPreCfgKey(pBuf);
   \                     ??MT_UtilCommandProcessing_5:
   \   000187   8A82         MOV       DPL,R2
   \   000189   8B83         MOV       DPH,R3
   \   00018B   A3           INC       DPTR
   \   00018C   A3           INC       DPTR
   \   00018D   E0           MOVX      A,@DPTR
   \   00018E   FE           MOV       R6,A
   \   00018F                ; Setup parameters for call to function osal_nv_item_len
   \   00018F   7A62         MOV       R2,#0x62
   \   000191   7B00         MOV       R3,#0x0
   \   000193   12....       LCALL     `??osal_nv_item_len::?relay`; Banked call to: osal_nv_item_len
   \   000196   8A..         MOV       ?V2,R2
   \   000198   8B..         MOV       ?V3,R3
   \   00019A                ; Setup parameters for call to function osal_nv_write
   \   00019A   E5..         MOV       A,?V0
   \   00019C   2403         ADD       A,#0x3
   \   00019E   F5..         MOV       ?V0,A
   \   0001A0   5002         JNC       ??MT_UtilCommandProcessing_28
   \   0001A2   05..         INC       ?V1
   \                     ??MT_UtilCommandProcessing_28:
   \   0001A4   78..         MOV       R0,#?V0
   \   0001A6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001A9   78..         MOV       R0,#?V2
   \   0001AB   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001AE   7C00         MOV       R4,#0x0
   \   0001B0   7D00         MOV       R5,#0x0
   \   0001B2   7A62         MOV       R2,#0x62
   \                     ??MT_UtilCommandProcessing_26:
   \   0001B4   7B00         MOV       R3,#0x0
   \   0001B6   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0001B9   7404         MOV       A,#0x4
   \   0001BB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001BE   02....       LJMP      ??MT_UtilCommandProcessing_29 & 0xFFFF
    210              break;
    211          #endif
    212          
    213          #ifdef FEATURE_GET_PRIMARY_IEEE
    214            case MT_UTIL_GET_PRIMARY_IEEE:
    215              MT_UtilGetPrimaryIEEE();
    216              break;
    217          #endif
    218          
    219            case MT_UTIL_CALLBACK_SUB_CMD:
    220              MT_UtilCallbackSub(pBuf);
   \                     ??MT_UtilCommandProcessing_6:
   \   0001C1   8A82         MOV       DPL,R2
   \   0001C3   8B83         MOV       DPH,R3
   \   0001C5   A3           INC       DPTR
   \   0001C6   A3           INC       DPTR
   \   0001C7   E0           MOVX      A,@DPTR
   \   0001C8   FE           MOV       R6,A
   \   0001C9   85..82       MOV       DPL,?XSP + 0
   \   0001CC   85..83       MOV       DPH,?XSP + 1
   \   0001CF   E4           CLR       A
   \   0001D0   F0           MOVX      @DPTR,A
   \   0001D1   EA           MOV       A,R2
   \   0001D2   2403         ADD       A,#0x3
   \   0001D4   F5..         MOV       ?V0,A
   \   0001D6   5002         JNC       ??MT_UtilCommandProcessing_30
   \   0001D8   05..         INC       ?V1
   \                     ??MT_UtilCommandProcessing_30:
   \   0001DA                ; Setup parameters for call to function osal_build_uint16
   \   0001DA   0A           INC       R2
   \   0001DB   0A           INC       R2
   \   0001DC   0A           INC       R2
   \   0001DD   AB..         MOV       R3,?V1
   \   0001DF   12....       LCALL     `??osal_build_uint16::?relay`; Banked call to: osal_build_uint16
   \   0001E2   8A..         MOV       ?V2,R2
   \   0001E4   8B..         MOV       ?V3,R3
   \   0001E6   A8..         MOV       R0,?V2
   \   0001E8   A9..         MOV       R1,?V3
   \   0001EA   E9           MOV       A,R1
   \   0001EB   541F         ANL       A,#0x1f
   \   0001ED   FA           MOV       R2,A
   \   0001EE   85..82       MOV       DPL,?V0
   \   0001F1   85..83       MOV       DPH,?V1
   \   0001F4   A3           INC       DPTR
   \   0001F5   A3           INC       DPTR
   \   0001F6   E0           MOVX      A,@DPTR
   \   0001F7   6031         JZ        ??MT_UtilCommandProcessing_31
   \   0001F9   7405         MOV       A,#0x5
   \   0001FB   6A           XRL       A,R2
   \   0001FC   600A         JZ        ??MT_UtilCommandProcessing_32
   \   0001FE   74FF         MOV       A,#-0x1
   \   000200   68           XRL       A,R0
   \   000201   7003         JNZ       ??MT_UtilCommandProcessing_33
   \   000203   74FF         MOV       A,#-0x1
   \   000205   69           XRL       A,R1
   \                     ??MT_UtilCommandProcessing_33:
   \   000206   700C         JNZ       ??MT_UtilCommandProcessing_34
   \                     ??MT_UtilCommandProcessing_32:
   \   000208   90....       MOV       DPTR,#_zdoCallbackSub
   \   00020B   74FF         MOV       A,#-0x1
   \   00020D   F0           MOVX      @DPTR,A
   \   00020E   A3           INC       DPTR
   \   00020F   F0           MOVX      @DPTR,A
   \   000210   A3           INC       DPTR
   \   000211   F0           MOVX      @DPTR,A
   \   000212   A3           INC       DPTR
   \   000213   F0           MOVX      @DPTR,A
   \                     ??MT_UtilCommandProcessing_34:
   \   000214   7406         MOV       A,#0x6
   \   000216   6A           XRL       A,R2
   \   000217   600A         JZ        ??MT_UtilCommandProcessing_35
   \   000219   74FF         MOV       A,#-0x1
   \   00021B   68           XRL       A,R0
   \   00021C   7003         JNZ       ??MT_UtilCommandProcessing_36
   \   00021E   74FF         MOV       A,#-0x1
   \   000220   69           XRL       A,R1
   \                     ??MT_UtilCommandProcessing_36:
   \   000221   7037         JNZ       ??MT_UtilCommandProcessing_37
   \                     ??MT_UtilCommandProcessing_35:
   \   000223   90....       MOV       DPTR,#_sapiCallbackSub
   \   000226   74FF         MOV       A,#-0x1
   \   000228   802D         SJMP      ??MT_UtilCommandProcessing_38
   \                     ??MT_UtilCommandProcessing_31:
   \   00022A   7405         MOV       A,#0x5
   \   00022C   6A           XRL       A,R2
   \   00022D   600A         JZ        ??MT_UtilCommandProcessing_39
   \   00022F   74FF         MOV       A,#-0x1
   \   000231   68           XRL       A,R0
   \   000232   7003         JNZ       ??MT_UtilCommandProcessing_40
   \   000234   74FF         MOV       A,#-0x1
   \   000236   69           XRL       A,R1
   \                     ??MT_UtilCommandProcessing_40:
   \   000237   700B         JNZ       ??MT_UtilCommandProcessing_41
   \                     ??MT_UtilCommandProcessing_39:
   \   000239   90....       MOV       DPTR,#_zdoCallbackSub
   \   00023C   E4           CLR       A
   \   00023D   F0           MOVX      @DPTR,A
   \   00023E   A3           INC       DPTR
   \   00023F   F0           MOVX      @DPTR,A
   \   000240   A3           INC       DPTR
   \   000241   F0           MOVX      @DPTR,A
   \   000242   A3           INC       DPTR
   \   000243   F0           MOVX      @DPTR,A
   \                     ??MT_UtilCommandProcessing_41:
   \   000244   7406         MOV       A,#0x6
   \   000246   6A           XRL       A,R2
   \   000247   600A         JZ        ??MT_UtilCommandProcessing_42
   \   000249   74FF         MOV       A,#-0x1
   \   00024B   68           XRL       A,R0
   \   00024C   7003         JNZ       ??MT_UtilCommandProcessing_43
   \   00024E   74FF         MOV       A,#-0x1
   \   000250   69           XRL       A,R1
   \                     ??MT_UtilCommandProcessing_43:
   \   000251   7007         JNZ       ??MT_UtilCommandProcessing_37
   \                     ??MT_UtilCommandProcessing_42:
   \   000253   90....       MOV       DPTR,#_sapiCallbackSub
   \   000256   E4           CLR       A
   \                     ??MT_UtilCommandProcessing_38:
   \   000257   F0           MOVX      @DPTR,A
   \   000258   A3           INC       DPTR
   \   000259   F0           MOVX      @DPTR,A
   \                     ??MT_UtilCommandProcessing_37:
   \   00025A                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   00025A   02....       LJMP      ??MT_UtilCommandProcessing_44 & 0xFFFF
    221              break;
    222          
    223            case MT_UTIL_KEY_EVENT:
    224          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    225              MT_UtilKeyEvent(pBuf);
    226          #endif
    227              break;
    228          
    229            case MT_UTIL_TIME_ALIVE:
    230              MT_UtilTimeAlive();
   \                     ??MT_UtilCommandProcessing_8:
   \   00025D                ; Setup parameters for call to function osal_GetSystemClock
   \   00025D   12....       LCALL     `??osal_GetSystemClock::?relay`; Banked call to: osal_GetSystemClock
   \   000260   8A..         MOV       ?V0,R2
   \   000262   8B..         MOV       ?V1,R3
   \   000264   8C..         MOV       ?V2,R4
   \   000266   8D..         MOV       ?V3,R5
   \   000268                ; Setup parameters for call to function osal_buffer_uint32
   \   000268   90....       MOV       DPTR,#__Constant_3e8
   \   00026B   78..         MOV       R0,#?V4
   \   00026D   12....       LCALL     ?L_MOV_X
   \   000270   78..         MOV       R0,#?V0
   \   000272   79..         MOV       R1,#?V4
   \   000274   12....       LCALL     ?UL_DIV_MOD
   \   000277   78..         MOV       R0,#?V0
   \   000279   12....       LCALL     ?PUSH_XSTACK_I_FOUR
   \   00027C   7407         MOV       A,#0x7
   \   00027E   12....       LCALL     ?XSTACK_DISP101_8
   \   000281   12....       LCALL     `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   000284   7404         MOV       A,#0x4
   \   000286   12....       LCALL     ?DEALLOC_XSTACK8
   \   000289                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000289   7403         MOV       A,#0x3
   \   00028B   12....       LCALL     ?XSTACK_DISP102_8
   \   00028E   7B04         MOV       R3,#0x4
   \   000290   7A09         MOV       R2,#0x9
   \   000292   02....       LJMP      ??MT_UtilCommandProcessing_45 & 0xFFFF
    231              break;
    232          
    233            case MT_UTIL_LED_CONTROL:
    234          #if (defined HAL_LED) && (HAL_LED == TRUE)
    235              MT_UtilLedControl(pBuf);
    236          #endif
    237              break;
    238          
    239            case MT_UTIL_SRC_MATCH_ENABLE:
    240              MT_UtilSrcMatchEnable(pBuf);
    241              break;
    242          
    243            case MT_UTIL_SRC_MATCH_ADD_ENTRY:
    244              MT_UtilSrcMatchAddEntry(pBuf);
    245              break;
    246          
    247            case MT_UTIL_SRC_MATCH_DEL_ENTRY:
    248              MT_UtilSrcMatchDeleteEntry(pBuf);
    249              break;
    250          
    251            case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
    252              MT_UtilSrcMatchCheckSrcAddr(pBuf);
   \                     ??MT_UtilCommandProcessing_15:
   \   000295   8A82         MOV       DPL,R2
   \   000297   8B83         MOV       DPH,R3
   \   000299   A3           INC       DPTR
   \   00029A   A3           INC       DPTR
   \   00029B   E0           MOVX      A,@DPTR
   \   00029C   FA           MOV       R2,A
   \   00029D   7401         MOV       A,#0x1
   \   00029F   12....       LCALL     ?XSTACK_DISP0_8
   \   0002A2   74F5         MOV       A,#-0xb
   \   0002A4   F0           MOVX      @DPTR,A
   \   0002A5   7402         MOV       A,#0x2
   \   0002A7   12....       LCALL     ?XSTACK_DISP0_8
   \   0002AA   74FF         MOV       A,#-0x1
   \   0002AC   F0           MOVX      @DPTR,A
   \   0002AD                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0002AD   7401         MOV       A,#0x1
   \   0002AF   8030         SJMP      ??MT_UtilCommandProcessing_46
    253              break;
    254          
    255            case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
    256              MT_UtilSrcMatchAckAllPending(pBuf);
   \                     ??MT_UtilCommandProcessing_14:
   \   0002B1   8A82         MOV       DPL,R2
   \   0002B3   8B83         MOV       DPH,R3
   \   0002B5   A3           INC       DPTR
   \   0002B6   A3           INC       DPTR
   \   0002B7   E0           MOVX      A,@DPTR
   \   0002B8   FA           MOV       R2,A
   \   0002B9   85..82       MOV       DPL,?XSP + 0
   \   0002BC   85..83       MOV       DPH,?XSP + 1
   \   0002BF   74F5         MOV       A,#-0xb
   \   0002C1   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   0002C4   7B01         MOV       R3,#0x1
   \   0002C6   02....       LJMP      ??MT_UtilCommandProcessing_45 & 0xFFFF
    257              break;
    258          
    259            case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
    260              MT_UtilSrcMatchCheckAllPending(pBuf);
   \                     ??MT_UtilCommandProcessing_16:
   \   0002C9   8A82         MOV       DPL,R2
   \   0002CB   8B83         MOV       DPH,R3
   \   0002CD   A3           INC       DPTR
   \   0002CE   A3           INC       DPTR
   \   0002CF   E0           MOVX      A,@DPTR
   \   0002D0   FA           MOV       R2,A
   \   0002D1   7401         MOV       A,#0x1
   \   0002D3   12....       LCALL     ?XSTACK_DISP0_8
   \   0002D6   74F5         MOV       A,#-0xb
   \   0002D8   F0           MOVX      @DPTR,A
   \   0002D9   7402         MOV       A,#0x2
   \   0002DB   12....       LCALL     ?XSTACK_DISP0_8
   \   0002DE   E4           CLR       A
   \   0002DF   F0           MOVX      @DPTR,A
   \   0002E0                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0002E0   04           INC       A
   \                     ??MT_UtilCommandProcessing_46:
   \   0002E1   12....       LCALL     ?XSTACK_DISP102_8
   \   0002E4   7B02         MOV       R3,#0x2
   \   0002E6   02....       LJMP      ??MT_UtilCommandProcessing_45 & 0xFFFF
    261              break;
    262          
    263            case MT_UTIL_TEST_LOOPBACK:
    264              MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
    265                                           pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
   \                     ??MT_UtilCommandProcessing_9:
   \   0002E9                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0002E9   EA           MOV       A,R2
   \   0002EA   2403         ADD       A,#0x3
   \   0002EC   FC           MOV       R4,A
   \   0002ED   E4           CLR       A
   \   0002EE   35..         ADDC      A,?V1
   \   0002F0   FD           MOV       R5,A
   \   0002F1   8A82         MOV       DPL,R2
   \   0002F3   8B83         MOV       DPH,R3
   \   0002F5   E0           MOVX      A,@DPTR
   \   0002F6   FB           MOV       R3,A
   \   0002F7   7A10         MOV       R2,#0x10
   \   0002F9   02....       LJMP      ??MT_UtilCommandProcessing_45 & 0xFFFF
    266              break;
    267          
    268            case MT_UTIL_GPIO_SET_DIRECTION:
    269              MT_UtilGpioSetDirection(pBuf);
   \                     ??MT_UtilCommandProcessing_11:
   \   0002FC                ; Setup parameters for call to function MT_UtilGpioSetDirection
   \   0002FC   12....       LCALL     `??MT_UtilGpioSetDirection::?relay`; Banked call to: MT_UtilGpioSetDirection
    270              break;
   \   0002FF   02....       LJMP      ??MT_UtilCommandProcessing_7 & 0xFFFF
    271          
    272            case MT_UTIL_GPIO_READ:
    273              MT_UtilGpioRead(pBuf);
   \                     ??MT_UtilCommandProcessing_12:
   \   000302   E580         MOV       A,0x80
   \   000304   C0E0         PUSH      A
   \   000306   7407         MOV       A,#0x7
   \   000308   12....       LCALL     ?XSTACK_DISP0_8
   \   00030B   D0E0         POP       A
   \   00030D   F0           MOVX      @DPTR,A
   \   00030E   E590         MOV       A,0x90
   \   000310   C0E0         PUSH      A
   \   000312   7408         MOV       A,#0x8
   \   000314   12....       LCALL     ?XSTACK_DISP0_8
   \   000317   D0E0         POP       A
   \   000319   F0           MOVX      @DPTR,A
   \   00031A   E5A0         MOV       A,0xa0
   \   00031C   C0E0         PUSH      A
   \   00031E   7409         MOV       A,#0x9
   \   000320   12....       LCALL     ?XSTACK_DISP0_8
   \   000323   D0E0         POP       A
   \   000325   F0           MOVX      @DPTR,A
   \   000326   E5FD         MOV       A,0xfd
   \   000328   C0E0         PUSH      A
   \   00032A   740A         MOV       A,#0xa
   \   00032C   12....       LCALL     ?XSTACK_DISP0_8
   \   00032F   D0E0         POP       A
   \   000331   F0           MOVX      @DPTR,A
   \   000332   E5FE         MOV       A,0xfe
   \   000334   C0E0         PUSH      A
   \   000336   740B         MOV       A,#0xb
   \   000338   12....       LCALL     ?XSTACK_DISP0_8
   \   00033B   D0E0         POP       A
   \   00033D   F0           MOVX      @DPTR,A
   \   00033E   E5FF         MOV       A,0xff
   \   000340   C0E0         PUSH      A
   \   000342   740C         MOV       A,#0xc
   \   000344   12....       LCALL     ?XSTACK_DISP0_8
   \   000347   D0E0         POP       A
   \   000349   F0           MOVX      @DPTR,A
   \   00034A                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   00034A   7407         MOV       A,#0x7
   \   00034C   12....       LCALL     ?XSTACK_DISP102_8
   \   00034F   7B06         MOV       R3,#0x6
   \   000351   7A15         MOV       R2,#0x15
   \   000353   02....       LJMP      ??MT_UtilCommandProcessing_45 & 0xFFFF
    274              break;
    275          
    276            case MT_UTIL_GPIO_WRITE:
    277              MT_UtilGpioWrite(pBuf);
   \                     ??MT_UtilCommandProcessing_13:
   \   000356                ; Setup parameters for call to function MT_UtilGpioWrite
   \   000356   12....       LCALL     `??MT_UtilGpioWrite::?relay`; Banked call to: MT_UtilGpioWrite
    278              break;
   \   000359   02....       LJMP      ??MT_UtilCommandProcessing_7 & 0xFFFF
    279          
    280          #if !defined NONWK
    281            case MT_UTIL_DATA_REQ:
    282              MT_UtilDataReq(pBuf);
   \                     ??MT_UtilCommandProcessing_10:
   \   00035C                ; Setup parameters for call to function NwkPollReq
   \   00035C   8A82         MOV       DPL,R2
   \   00035E   8B83         MOV       DPH,R3
   \   000360   A3           INC       DPTR
   \   000361   A3           INC       DPTR
   \   000362   A3           INC       DPTR
   \   000363   E0           MOVX      A,@DPTR
   \   000364   F9           MOV       R1,A
   \   000365   12....       LCALL     `??NwkPollReq::?relay`; Banked call to: NwkPollReq
   \   000368   E9           MOV       A,R1
   \   000369   85..82       MOV       DPL,?XSP + 0
   \   00036C   85..83       MOV       DPH,?XSP + 1
   \   00036F   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000372   7B01         MOV       R3,#0x1
   \   000374   7A11         MOV       R2,#0x11
   \   000376   02....       LJMP      ??MT_UtilCommandProcessing_45 & 0xFFFF
    283              break;
    284          
    285            case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
    286              MT_UtilAddrMgrEntryLookupExt(pBuf);
   \                     ??MT_UtilCommandProcessing_17:
   \   000379   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00037C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00037F   7C08         MOV       R4,#0x8
   \   000381   7D00         MOV       R5,#0x0
   \   000383   7413         MOV       A,#0x13
   \   000385   12....       LCALL     ?XSTACK_DISP0_8
   \   000388   AA82         MOV       R2,DPL
   \   00038A   AB83         MOV       R3,DPH
   \   00038C   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00038F   7403         MOV       A,#0x3
   \   000391   12....       LCALL     ?DEALLOC_XSTACK8
   \   000394                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000394   740D         MOV       A,#0xd
   \   000396   12....       LCALL     ?XSTACK_DISP101_8
   \   000399   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00039C   740E         MOV       A,#0xe
   \   00039E   12....       LCALL     ?XSTACK_DISP0_8
   \   0003A1   E0           MOVX      A,@DPTR
   \   0003A2   F8           MOV       R0,A
   \   0003A3   A3           INC       DPTR
   \   0003A4   E0           MOVX      A,@DPTR
   \   0003A5   F9           MOV       R1,A
   \   0003A6   7401         MOV       A,#0x1
   \   0003A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0003AB   E8           MOV       A,R0
   \   0003AC   F0           MOVX      @DPTR,A
   \   0003AD   7402         MOV       A,#0x2
   \   0003AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0003B2   E9           MOV       A,R1
   \   0003B3   F0           MOVX      @DPTR,A
   \   0003B4                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0003B4   7401         MOV       A,#0x1
   \   0003B6   12....       LCALL     ?XSTACK_DISP102_8
   \   0003B9   02....       LJMP      ??MT_UtilCommandProcessing_47 & 0xFFFF
    287              break;
    288          
    289            case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
    290              MT_UtilAddrMgrEntryLookupNwk(pBuf);
   \                     ??MT_UtilCommandProcessing_18:
   \   0003BC   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0003BF   12....       LCALL     `??osal_build_uint16::?relay`; Banked call to: osal_build_uint16
   \   0003C2   740E         MOV       A,#0xe
   \   0003C4   12....       LCALL     ?XSTACK_DISP0_8
   \   0003C7   EA           MOV       A,R2
   \   0003C8   F0           MOVX      @DPTR,A
   \   0003C9   A3           INC       DPTR
   \   0003CA   EB           MOV       A,R3
   \   0003CB   F0           MOVX      @DPTR,A
   \   0003CC                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   0003CC   740D         MOV       A,#0xd
   \   0003CE   12....       LCALL     ?XSTACK_DISP101_8
   \   0003D1   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   0003D4                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0003D4   7410         MOV       A,#0x10
   \   0003D6   12....       LCALL     ?XSTACK_DISP0_8
   \   0003D9   AC82         MOV       R4,DPL
   \   0003DB   AD83         MOV       R5,DPH
   \   0003DD   7B08         MOV       R3,#0x8
   \   0003DF   02....       LJMP      ??MT_UtilCommandProcessing_48 & 0xFFFF
    291              break;
    292          
    293          #if defined MT_SYS_KEY_MANAGEMENT
    294            case MT_UTIL_APSME_LINK_KEY_DATA_GET:
    295              MT_UtilAPSME_LinkKeyDataGet(pBuf);
    296              break;
    297          
    298            case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
    299              MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
    300              break;
    301          #endif // MT_SYS_KEY_MANAGEMENT
    302          
    303            case MT_UTIL_APSME_REQUEST_KEY_CMD:
    304              MT_UtilAPSME_RequestKeyCmd(pBuf);
   \                     ??MT_UtilCommandProcessing_22:
   \   0003E2   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0003E5   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0003E8   7C08         MOV       R4,#0x8
   \   0003EA   7D00         MOV       R5,#0x0
   \   0003EC   741D         MOV       A,#0x1d
   \   0003EE   12....       LCALL     ?XSTACK_DISP101_8
   \   0003F1   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0003F4   7403         MOV       A,#0x3
   \   0003F6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0003F9                ; Setup parameters for call to function ZDSecMgrRequestAppKey
   \   0003F9   741A         MOV       A,#0x1a
   \   0003FB   12....       LCALL     ?XSTACK_DISP101_8
   \   0003FE   12....       LCALL     `??ZDSecMgrRequestAppKey::?relay`; Banked call to: ZDSecMgrRequestAppKey
   \                     ??MT_UtilCommandProcessing_29:
   \   000401   E9           MOV       A,R1
   \   000402   85..82       MOV       DPL,?XSP + 0
   \   000405   85..83       MOV       DPH,?XSP + 1
   \   000408   F0           MOVX      @DPTR,A
   \   000409                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \                     ??MT_UtilCommandProcessing_44:
   \   000409   AC..         MOV       R4,?XSP + 0
   \   00040B   AD..         MOV       R5,?XSP + 1
   \   00040D   7B01         MOV       R3,#0x1
   \   00040F   02....       LJMP      ??MT_UtilCommandProcessing_48 & 0xFFFF
    305              break;
    306          
    307            case MT_UTIL_ASSOC_COUNT:
    308              MT_UtilAssocCount(pBuf);
   \                     ??MT_UtilCommandProcessing_19:
   \   000412   8A82         MOV       DPL,R2
   \   000414   8B83         MOV       DPH,R3
   \   000416   A3           INC       DPTR
   \   000417   A3           INC       DPTR
   \   000418   E0           MOVX      A,@DPTR
   \   000419   FE           MOV       R6,A
   \   00041A   EA           MOV       A,R2
   \   00041B   2403         ADD       A,#0x3
   \   00041D   F5..         MOV       ?V0,A
   \   00041F   5002         JNC       ??MT_UtilCommandProcessing_49
   \   000421   05..         INC       ?V1
   \                     ??MT_UtilCommandProcessing_49:
   \   000423   F582         MOV       DPL,A
   \   000425   85..83       MOV       DPH,?V1
   \   000428   A3           INC       DPTR
   \   000429   8582..       MOV       ?V2,DPL
   \   00042C   8583..       MOV       ?V3,DPH
   \   00042F                ; Setup parameters for call to function AssocCount
   \   00042F   E0           MOVX      A,@DPTR
   \   000430   FA           MOV       R2,A
   \   000431   85..82       MOV       DPL,?V0
   \   000434   85..83       MOV       DPH,?V1
   \   000437   E0           MOVX      A,@DPTR
   \   000438   F9           MOV       R1,A
   \   000439   12....       LCALL     `??AssocCount::?relay`; Banked call to: AssocCount
   \   00043C   85..82       MOV       DPL,?V0
   \   00043F   85..83       MOV       DPH,?V1
   \   000442   EA           MOV       A,R2
   \   000443   F0           MOVX      @DPTR,A
   \   000444   85..82       MOV       DPL,?V2
   \   000447   85..83       MOV       DPH,?V3
   \   00044A   EB           MOV       A,R3
   \   00044B   F0           MOVX      @DPTR,A
   \   00044C                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   00044C   AC..         MOV       R4,?V0
   \   00044E   AD..         MOV       R5,?V1
   \                     ??MT_UtilCommandProcessing_47:
   \   000450   7B02         MOV       R3,#0x2
   \   000452   8072         SJMP      ??MT_UtilCommandProcessing_48
    309              break;
    310          
    311            case MT_UTIL_ASSOC_FIND_DEVICE:
    312              MT_UtilAssocFindDevice(pBuf);
   \                     ??MT_UtilCommandProcessing_20:
   \   000454   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000457   E0           MOVX      A,@DPTR
   \   000458   FA           MOV       R2,A
   \   000459   7B00         MOV       R3,#0x0
   \   00045B   12....       LCALL     `??AssocFindDevice::?relay`; Banked call to: AssocFindDevice
   \   00045E   804F         SJMP      ??MT_UtilCommandProcessing_50
    313              break;
    314          
    315            case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
    316              MT_UtilAssocGetWithAddress(pBuf);
   \                     ??MT_UtilCommandProcessing_21:
   \   000460   8A82         MOV       DPL,R2
   \   000462   8B83         MOV       DPH,R3
   \   000464   A3           INC       DPTR
   \   000465   A3           INC       DPTR
   \   000466   E0           MOVX      A,@DPTR
   \   000467   FE           MOV       R6,A
   \   000468   EA           MOV       A,R2
   \   000469   2403         ADD       A,#0x3
   \   00046B   F5..         MOV       ?V0,A
   \   00046D   5002         JNC       ??MT_UtilCommandProcessing_51
   \   00046F   05..         INC       ?V1
   \                     ??MT_UtilCommandProcessing_51:
   \   000471                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000471   0A           INC       R2
   \   000472   0A           INC       R2
   \   000473   0A           INC       R2
   \   000474   AB..         MOV       R3,?V1
   \   000476   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000479   E9           MOV       A,R1
   \   00047A   6006         JZ        ??MT_UtilCommandProcessing_52
   \   00047C   AA..         MOV       R2,?V0
   \   00047E   AB..         MOV       R3,?V1
   \   000480   8004         SJMP      ??MT_UtilCommandProcessing_53
   \                     ??MT_UtilCommandProcessing_52:
   \   000482   7A00         MOV       R2,#0x0
   \   000484   7B00         MOV       R3,#0x0
   \                     ??MT_UtilCommandProcessing_53:
   \   000486                ; Setup parameters for call to function AssocGetWithAddress
   \   000486   85..82       MOV       DPL,?V0
   \   000489   85..83       MOV       DPH,?V1
   \   00048C   A3           INC       DPTR
   \   00048D   A3           INC       DPTR
   \   00048E   A3           INC       DPTR
   \   00048F   A3           INC       DPTR
   \   000490   A3           INC       DPTR
   \   000491   A3           INC       DPTR
   \   000492   A3           INC       DPTR
   \   000493   A3           INC       DPTR
   \   000494   E0           MOVX      A,@DPTR
   \   000495   FC           MOV       R4,A
   \   000496   85..82       MOV       DPL,?V0
   \   000499   85..83       MOV       DPH,?V1
   \   00049C   A3           INC       DPTR
   \   00049D   A3           INC       DPTR
   \   00049E   A3           INC       DPTR
   \   00049F   A3           INC       DPTR
   \   0004A0   A3           INC       DPTR
   \   0004A1   A3           INC       DPTR
   \   0004A2   A3           INC       DPTR
   \   0004A3   A3           INC       DPTR
   \   0004A4   A3           INC       DPTR
   \   0004A5   E0           MOVX      A,@DPTR
   \   0004A6   F9           MOV       R1,A
   \   0004A7   EC           MOV       A,R4
   \   0004A8   2F           ADD       A,R7
   \   0004A9   E4           CLR       A
   \   0004AA   39           ADDC      A,R1
   \   0004AB   FD           MOV       R5,A
   \   0004AC   12....       LCALL     `??AssocGetWithAddress::?relay`; Banked call to: AssocGetWithAddress
   \                     ??MT_UtilCommandProcessing_50:
   \   0004AF   8A..         MOV       ?V0,R2
   \   0004B1   8B..         MOV       ?V1,R3
   \   0004B3   AC..         MOV       R4,?V0
   \   0004B5   AD..         MOV       R5,?V1
   \   0004B7                ; Setup parameters for call to function packDev_t
   \   0004B7   7422         MOV       A,#0x22
   \   0004B9   12....       LCALL     ?XSTACK_DISP101_8
   \   0004BC   12....       LCALL     `??packDev_t::?relay`; Banked call to: packDev_t
   \   0004BF                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0004BF   7422         MOV       A,#0x22
   \   0004C1   12....       LCALL     ?XSTACK_DISP102_8
   \   0004C4   7B1C         MOV       R3,#0x1c
   \                     ??MT_UtilCommandProcessing_48:
   \   0004C6   EE           MOV       A,R6
   \   0004C7   FA           MOV       R2,A
   \                     ??MT_UtilCommandProcessing_45:
   \   0004C8   7967         MOV       R1,#0x67
   \   0004CA   800F         SJMP      ??MT_UtilCommandProcessing_54
    317              break;
    318          
    319            case MT_UTIL_BIND_ADD_ENTRY:
    320              MT_UtilBindAddEntry(pBuf);
   \                     ??MT_UtilCommandProcessing_23:
   \   0004CC                ; Setup parameters for call to function MT_UtilBindAddEntry
   \   0004CC   12....       LCALL     `??MT_UtilBindAddEntry::?relay`; Banked call to: MT_UtilBindAddEntry
    321              break;
   \   0004CF   8011         SJMP      ??MT_UtilCommandProcessing_7
    322          
    323          #if defined ZCL_KEY_ESTABLISH
    324            case MT_UTIL_ZCL_KEY_EST_INIT_EST:
    325              MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
    326              break;
    327          
    328            case MT_UTIL_ZCL_KEY_EST_SIGN:
    329              MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
    330              break;
    331          #endif
    332          
    333            case MT_UTIL_SYNC_REQ:
    334              MT_UtilSync();
   \                     ??MT_UtilCommandProcessing_24:
   \   0004D1                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0004D1   7C00         MOV       R4,#0x0
   \   0004D3   7D00         MOV       R5,#0x0
   \   0004D5   7B00         MOV       R3,#0x0
   \   0004D7   7AE0         MOV       R2,#-0x20
   \   0004D9   7947         MOV       R1,#0x47
   \                     ??MT_UtilCommandProcessing_54:
   \   0004DB   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    335              break;
   \   0004DE   8002         SJMP      ??MT_UtilCommandProcessing_7
    336          #endif /* !defined NONWK */
    337          
    338          #ifdef MT_SRNG
    339            case MT_UTIL_SRNG_GENERATE:
    340              MT_UtilSrngGen();
    341              break;
    342          #endif
    343          
    344            default:
    345              status = MT_RPC_ERR_COMMAND_ID;
   \                     ??MT_UtilCommandProcessing_25:
   \   0004E0   7F02         MOV       R7,#0x2
    346              break;
    347            }
    348          
    349            return status;
   \                     ??MT_UtilCommandProcessing_7:
   \   0004E2   EF           MOV       A,R7
   \   0004E3   F9           MOV       R1,A
   \   0004E4   743E         MOV       A,#0x3e
   \   0004E6                REQUIRE ?Subroutine0
   \   0004E6                REQUIRE _A_P0
   \   0004E6                REQUIRE _A_P1
   \   0004E6                REQUIRE _A_P2
   \   0004E6                REQUIRE P0DIR
   \   0004E6                REQUIRE P1DIR
   \   0004E6                REQUIRE P2DIR
   \   0004E6                ; // Fall through to label ?Subroutine0
    350          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F08         MOV       R7,#0x8
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA
    351          
    352          /***************************************************************************************************
    353          * @fn      MT_UtilGetDeviceInfo
    354          *
    355          * @brief   The Get Device Info serial message.
    356          *
    357          * @param   None.
    358          *
    359          * @return  void
    360          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    361          static void MT_UtilGetDeviceInfo(void)
   \                     MT_UtilGetDeviceInfo:
    362          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    363            uint8  *buf;
    364            uint8  *pBuf;
    365            uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
   \   00000A   75..0E       MOV       ?V2,#0xe
    366            uint16 *assocList = NULL;
   \   00000D   7E00         MOV       R6,#0x0
   \   00000F   7F00         MOV       R7,#0x0
    367          
    368          #if !defined NONWK
    369            uint8  assocCnt = 0;
   \   000011   85..82       MOV       DPL,?XSP + 0
   \   000014   85..83       MOV       DPH,?XSP + 1
   \   000017   E4           CLR       A
   \   000018   F0           MOVX      @DPTR,A
    370          
    371            if (ZG_DEVICE_RTR_TYPE)
   \   000019   90....       MOV       DPTR,#zgDeviceLogicalType
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   6004         JZ        ??MT_UtilGetDeviceInfo_0
   \   00001F   6401         XRL       A,#0x1
   \   000021   701C         JNZ       ??MT_UtilGetDeviceInfo_1
    372            {
    373              assocList = AssocMakeList( &assocCnt );
   \                     ??MT_UtilGetDeviceInfo_0:
   \   000023                ; Setup parameters for call to function AssocMakeList
   \   000023   AA..         MOV       R2,?XSP + 0
   \   000025   AB..         MOV       R3,?XSP + 1
   \   000027   12....       LCALL     `??AssocMakeList::?relay`; Banked call to: AssocMakeList
   \   00002A   8A..         MOV       ?V0,R2
   \   00002C   8B..         MOV       ?V1,R3
   \   00002E   AE..         MOV       R6,?V0
   \   000030   AF..         MOV       R7,?V1
    374              bufLen += (assocCnt * sizeof(uint16));
   \   000032   85..82       MOV       DPL,?XSP + 0
   \   000035   85..83       MOV       DPH,?XSP + 1
   \   000038   E0           MOVX      A,@DPTR
   \   000039   C3           CLR       C
   \   00003A   33           RLC       A
   \   00003B   240E         ADD       A,#0xe
   \   00003D   F5..         MOV       ?V2,A
    375            }
    376          #endif
    377          
    378            buf = osal_mem_alloc( bufLen );
   \                     ??MT_UtilGetDeviceInfo_1:
   \   00003F                ; Setup parameters for call to function osal_mem_alloc
   \   00003F   AA..         MOV       R2,?V2
   \   000041   7B00         MOV       R3,#0x0
   \   000043   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000046   8A..         MOV       ?V0,R2
   \   000048   8B..         MOV       ?V1,R3
    379            if ( buf )
   \   00004A   EA           MOV       A,R2
   \   00004B   45..         ORL       A,?V1
   \   00004D   7003         JNZ       $+5
   \   00004F   02....       LJMP      ??MT_UtilGetDeviceInfo_2 & 0xFFFF
    380            {
    381              pBuf = buf;
    382          
    383              *pBuf++ = ZSUCCESS; // Status
   \   000052   8A82         MOV       DPL,R2
   \   000054   8B83         MOV       DPH,R3
   \   000056   E4           CLR       A
   \   000057   F0           MOVX      @DPTR,A
   \   000058   A3           INC       DPTR
   \   000059   8582..       MOV       ?V4,DPL
   \   00005C   8583..       MOV       ?V5,DPH
    384          
    385              osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
   \   00005F                ; Setup parameters for call to function osal_nv_read
   \   00005F   78..         MOV       R0,#?V4
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000064   75..08       MOV       ?V6,#0x8
   \   000067   75..00       MOV       ?V7,#0x0
   \   00006A   78..         MOV       R0,#?V6
   \   00006C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006F   7C00         MOV       R4,#0x0
   \   000071   7D00         MOV       R5,#0x0
   \   000073   7A01         MOV       R2,#0x1
   \   000075   7B00         MOV       R3,#0x0
   \   000077   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00007A   7404         MOV       A,#0x4
   \   00007C   12....       LCALL     ?DEALLOC_XSTACK8
    386              pBuf += Z_EXTADDR_LEN;
    387          
    388          #if defined NONWK
    389              // Skip past ZStack only parameters for NONWK
    390              *pBuf++ = 0;
    391              *pBuf++ = 0;
    392              *pBuf++ = 0;
    393              *pBuf++ = 0;
    394              *pBuf = 0;
    395          #else
    396              {
    397                uint16 shortAddr = NLME_GetShortAddr();
   \   00007F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007F   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
    398                *pBuf++ = LO_UINT16( shortAddr );
   \   000082   85..82       MOV       DPL,?V4
   \   000085   85..83       MOV       DPH,?V5
   \   000088   A3           INC       DPTR
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   A3           INC       DPTR
   \   00008C   A3           INC       DPTR
   \   00008D   A3           INC       DPTR
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   EA           MOV       A,R2
   \   000091   12....       LCALL     ?Subroutine12 & 0xFFFF
    399                *pBuf++ = HI_UINT16( shortAddr );
    400              }
   \                     ??CrossCallReturnLabel_16:
   \   000094   EB           MOV       A,R3
   \   000095   12....       LCALL     ?Subroutine12 & 0xFFFF
    401          
    402              /* Return device type */
    403              *pBuf++ = ZSTACK_DEVICE_BUILD;
   \                     ??CrossCallReturnLabel_17:
   \   000098   A3           INC       DPTR
   \   000099   7407         MOV       A,#0x7
   \   00009B   F0           MOVX      @DPTR,A
    404          
    405              /*Return device state */
    406              *pBuf++ = (uint8)devState;
   \   00009C   90....       MOV       DPTR,#devState
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   C0E0         PUSH      A
   \   0000A2   E5..         MOV       A,?V4
   \   0000A4   240B         ADD       A,#0xb
   \   0000A6   F582         MOV       DPL,A
   \   0000A8   E4           CLR       A
   \   0000A9   35..         ADDC      A,?V5
   \   0000AB   F583         MOV       DPH,A
   \   0000AD   D0E0         POP       A
   \   0000AF   F0           MOVX      @DPTR,A
    407          
    408              if (ZG_DEVICE_RTR_TYPE)
   \   0000B0   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   6004         JZ        ??MT_UtilGetDeviceInfo_3
   \   0000B6   6401         XRL       A,#0x1
   \   0000B8   7061         JNZ       ??MT_UtilGetDeviceInfo_4
    409              {
    410                *pBuf++ = assocCnt;
   \                     ??MT_UtilGetDeviceInfo_3:
   \   0000BA   85..82       MOV       DPL,?XSP + 0
   \   0000BD   85..83       MOV       DPH,?XSP + 1
   \   0000C0   E0           MOVX      A,@DPTR
   \   0000C1   C0E0         PUSH      A
   \   0000C3   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000C6   D0E0         POP       A
   \   0000C8   F0           MOVX      @DPTR,A
   \   0000C9   E5..         MOV       A,?V4
   \   0000CB   240D         ADD       A,#0xd
   \   0000CD   F5..         MOV       ?V4,A
   \   0000CF   5002         JNC       ??MT_UtilGetDeviceInfo_5
   \   0000D1   05..         INC       ?V5
    411          
    412                if ( assocCnt )
   \                     ??MT_UtilGetDeviceInfo_5:
   \   0000D3   85..82       MOV       DPL,?XSP + 0
   \   0000D6   85..83       MOV       DPH,?XSP + 1
   \   0000D9   E0           MOVX      A,@DPTR
   \   0000DA   6048         JZ        ??MT_UtilGetDeviceInfo_6
    413                {
    414                  uint8 x;
    415                  uint16 *puint16 = assocList;
   \   0000DC   EE           MOV       A,R6
   \   0000DD   F8           MOV       R0,A
   \   0000DE   EF           MOV       A,R7
   \   0000DF   F9           MOV       R1,A
    416          
    417                  for ( x = 0; x < assocCnt; x++, puint16++ )
   \   0000E0   7C00         MOV       R4,#0x0
   \                     ??MT_UtilGetDeviceInfo_7:
   \   0000E2   85..82       MOV       DPL,?XSP + 0
   \   0000E5   85..83       MOV       DPH,?XSP + 1
   \   0000E8   E0           MOVX      A,@DPTR
   \   0000E9   FA           MOV       R2,A
   \   0000EA   EC           MOV       A,R4
   \   0000EB   C3           CLR       C
   \   0000EC   9A           SUBB      A,R2
   \   0000ED   5035         JNC       ??MT_UtilGetDeviceInfo_6
    418                  {
    419                    *pBuf++ = LO_UINT16( *puint16 );
   \   0000EF   8882         MOV       DPL,R0
   \   0000F1   8983         MOV       DPH,R1
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   85..82       MOV       DPL,?V4
   \   0000F7   85..83       MOV       DPH,?V5
   \   0000FA   12....       LCALL     ??Subroutine29_0 & 0xFFFF
    420                    *pBuf++ = HI_UINT16( *puint16 );
    421                  }
   \                     ??CrossCallReturnLabel_56:
   \   0000FD   A3           INC       DPTR
   \   0000FE   E0           MOVX      A,@DPTR
   \   0000FF   85..82       MOV       DPL,?V4
   \   000102   85..83       MOV       DPH,?V5
   \   000105   A3           INC       DPTR
   \   000106   F0           MOVX      @DPTR,A
   \   000107   E5..         MOV       A,?V4
   \   000109   2402         ADD       A,#0x2
   \   00010B   F5..         MOV       ?V4,A
   \   00010D   5002         JNC       ??MT_UtilGetDeviceInfo_8
   \   00010F   05..         INC       ?V5
   \                     ??MT_UtilGetDeviceInfo_8:
   \   000111   0C           INC       R4
   \   000112   E8           MOV       A,R0
   \   000113   2402         ADD       A,#0x2
   \   000115   F8           MOV       R0,A
   \   000116   50CA         JNC       ??MT_UtilGetDeviceInfo_7
   \   000118   09           INC       R1
   \   000119   80C7         SJMP      ??MT_UtilGetDeviceInfo_7
    422                }
    423              }
    424              else
    425              {
    426                *pBuf++ = 0;
   \                     ??MT_UtilGetDeviceInfo_4:
   \   00011B   12....       LCALL     ?Subroutine19 & 0xFFFF
    427              }
   \                     ??CrossCallReturnLabel_31:
   \   00011E   E4           CLR       A
   \   00011F   F0           MOVX      @DPTR,A
   \   000120   E5..         MOV       A,?V4
   \   000122   240D         ADD       A,#0xd
    428          #endif
    429          
    430              MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    431                                           MT_UTIL_GET_DEVICE_INFO,
    432                                           bufLen, buf );
   \                     ??MT_UtilGetDeviceInfo_6:
   \   000124                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000124   AC..         MOV       R4,?V0
   \   000126   AD..         MOV       R5,?V1
   \   000128   AB..         MOV       R3,?V2
   \   00012A   7A00         MOV       R2,#0x0
   \   00012C   7967         MOV       R1,#0x67
   \   00012E   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    433          
    434              osal_mem_free( buf );
   \   000131                ; Setup parameters for call to function osal_mem_free
   \   000131   AA..         MOV       R2,?V0
   \   000133   AB..         MOV       R3,?V1
   \   000135   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    435            }
    436          
    437            if ( assocList )
   \                     ??MT_UtilGetDeviceInfo_2:
   \   000138   EE           MOV       A,R6
   \   000139   4F           ORL       A,R7
   \   00013A   6007         JZ        ??MT_UtilGetDeviceInfo_9
    438            {
    439              osal_mem_free( assocList );
   \   00013C                ; Setup parameters for call to function osal_mem_free
   \   00013C   EE           MOV       A,R6
   \   00013D   FA           MOV       R2,A
   \   00013E   EF           MOV       A,R7
   \   00013F   FB           MOV       R3,A
   \   000140   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    440            }
    441          }
   \                     ??MT_UtilGetDeviceInfo_9:
   \   000143   7401         MOV       A,#0x1
   \   000145   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E5..         MOV       A,?V4
   \   000002   240C         ADD       A,#0xc
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   35..         ADDC      A,?V5
   \   000009   F583         MOV       DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V4
   \   000004   85..83       MOV       DPH,?V5
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET
    442          
    443          #ifdef MT_SRNG
    444          /***************************************************************************************************
    445          * @fn      MT_UtilSrngGen
    446          *
    447          * @brief   Generate Secure Random Numbers
    448          *
    449          * @param   None.
    450          *
    451          * @return  void
    452          ***************************************************************************************************/
    453          static void MT_UtilSrngGen(void)
    454          {
    455            static uint32 count = 125000; /* 125000 * 8 bits = 1000000 bits */
    456            uint8 outrng[100];
    457            uint8 status;
    458          
    459            if(count > 0)
    460            {
    461              status = ssp_srng_generate((uint8 *)outrng, 100, NULL);
    462              if (status != SRNG_SUCCESS)
    463              {
    464                if(RNG_INIT_ERROR == status)
    465                {
    466                  ssp_srng_reseed();
    467                }
    468                else
    469                {
    470                  while(1)
    471                  {
    472                    ASM_NOP;
    473                  }
    474                } /* if(RNG_INIT_ERROR == status) */
    475              }/*if (status != SRNG_SUCCESS) */
    476          
    477              if(count >= 100)
    478              {
    479                count -= 100;
    480              }
    481              else
    482              {
    483                count = 0;
    484              }
    485              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ |
    486                                           (uint8)MT_RPC_SYS_DBG),
    487                                            MT_DEBUG_MSG,
    488                                            100,
    489                                            outrng);
    490              osal_start_timerEx(MT_TaskID, MT_SRNG_EVENT, 100);
    491            }
    492          }
    493          #endif
    494          
    495          /***************************************************************************************************
    496           * @fn      MT_UtilGetNvInfo
    497           *
    498           * @brief   The Get NV Info serial message.
    499           *
    500           * @param   None.
    501           *
    502           * @return  void
    503           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    504          static void MT_UtilGetNvInfo(void)
   \                     MT_UtilGetNvInfo:
    505          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    506            uint8 len;
    507            uint8 stat;
    508            uint8 *buf;
    509            uint8 *pBuf;
    510            uint16 tmp16;
    511            uint32 tmp32;
    512          
    513            /*
    514              Get required length of buffer
    515              Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
    516            */
    517            len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
    518          
    519            buf = osal_mem_alloc( len );
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   7A20         MOV       R2,#0x20
   \   00000C   7B00         MOV       R3,#0x0
   \   00000E   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   AE..         MOV       R6,?V0
   \   000017   AF..         MOV       R7,?V1
    520            if ( buf )
   \   000019   EE           MOV       A,R6
   \   00001A   4F           ORL       A,R7
   \   00001B   7003         JNZ       $+5
   \   00001D   02....       LJMP      ??MT_UtilGetNvInfo_0 & 0xFFFF
    521            {
    522              /* Assume NV not available */
    523              osal_memset( buf, 0xFF, len );
   \   000020                ; Setup parameters for call to function osal_memset
   \   000020   7C20         MOV       R4,#0x20
   \   000022   7D00         MOV       R5,#0x0
   \   000024   79FF         MOV       R1,#-0x1
   \   000026   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    524          
    525              /* Skip over status */
    526              pBuf = buf + 1;
   \   000029   8E82         MOV       DPL,R6
   \   00002B   8F83         MOV       DPH,R7
   \   00002D   A3           INC       DPTR
   \   00002E   8582..       MOV       ?V2,DPL
   \   000031   8583..       MOV       ?V3,DPH
    527          
    528              /* Start with 64-bit extended address */
    529              stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
   \   000034                ; Setup parameters for call to function osal_nv_read
   \   000034   78..         MOV       R0,#?V2
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   75..08       MOV       ?V0,#0x8
   \   00003C   75..00       MOV       ?V1,#0x0
   \   00003F   78..         MOV       R0,#?V0
   \   000041   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000044   7C00         MOV       R4,#0x0
   \   000046   7D00         MOV       R5,#0x0
   \   000048   7A01         MOV       R2,#0x1
   \   00004A   7B00         MOV       R3,#0x0
   \   00004C   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00004F   7404         MOV       A,#0x4
   \   000051   12....       LCALL     ?DEALLOC_XSTACK8
   \   000054   E9           MOV       A,R1
   \   000055   F5..         MOV       ?V0,A
    530              if ( stat ) stat = 0x01;
   \   000057   6003         JZ        ??MT_UtilGetNvInfo_1
   \   000059   75..01       MOV       ?V0,#0x1
    531              pBuf += Z_EXTADDR_LEN;
   \                     ??MT_UtilGetNvInfo_1:
   \   00005C   E5..         MOV       A,?V2
   \   00005E   2408         ADD       A,#0x8
   \   000060   F5..         MOV       ?V2,A
   \   000062   5002         JNC       ??MT_UtilGetNvInfo_2
   \   000064   05..         INC       ?V3
    532          
    533              /* Scan channel list (bit mask) */
    534              if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
   \                     ??MT_UtilGetNvInfo_2:
   \   000066                ; Setup parameters for call to function osal_nv_read
   \   000066   7402         MOV       A,#0x2
   \   000068   12....       LCALL     ?XSTACK_DISP100_8
   \   00006B   88..         MOV       ?V4,R0
   \   00006D   89..         MOV       ?V5,R1
   \   00006F   78..         MOV       R0,#?V4
   \   000071   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000074   75..04       MOV       ?V4,#0x4
   \   000077   75..00       MOV       ?V5,#0x0
   \   00007A   78..         MOV       R0,#?V4
   \   00007C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007F   7C00         MOV       R4,#0x0
   \   000081   7D00         MOV       R5,#0x0
   \   000083   7A84         MOV       R2,#-0x7c
   \   000085   7B00         MOV       R3,#0x0
   \   000087   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00008A   7404         MOV       A,#0x4
   \   00008C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008F   E9           MOV       A,R1
   \   000090   6008         JZ        ??MT_UtilGetNvInfo_3
    535              {
    536                stat |= 0x02;
   \   000092   E5..         MOV       A,?V0
   \   000094   D2E1         SETB      0xE0 /* A   */.1
   \   000096   F5..         MOV       ?V0,A
   \   000098   8060         SJMP      ??MT_UtilGetNvInfo_4
    537              }
    538              else
    539              {
    540                pBuf[0] = BREAK_UINT32( tmp32, 3 );
   \                     ??MT_UtilGetNvInfo_3:
   \   00009A   7402         MOV       A,#0x2
   \   00009C   12....       LCALL     ?XSTACK_DISP0_8
   \   00009F   78..         MOV       R0,#?V4
   \   0000A1   12....       LCALL     ?L_MOV_X
   \   0000A4   7418         MOV       A,#0x18
   \   0000A6   78..         MOV       R0,#?V4
   \   0000A8   12....       LCALL     ?UL_SHR
   \   0000AB   85..82       MOV       DPL,?V2
   \   0000AE   85..83       MOV       DPH,?V3
   \   0000B1   E5..         MOV       A,?V4
   \   0000B3   F0           MOVX      @DPTR,A
    541                pBuf[1] = BREAK_UINT32( tmp32, 2 );
   \   0000B4   7402         MOV       A,#0x2
   \   0000B6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B9   78..         MOV       R0,#?V4
   \   0000BB   12....       LCALL     ?L_MOV_X
   \   0000BE   7410         MOV       A,#0x10
   \   0000C0   78..         MOV       R0,#?V4
   \   0000C2   12....       LCALL     ?UL_SHR
   \   0000C5   85..82       MOV       DPL,?V2
   \   0000C8   85..83       MOV       DPH,?V3
   \   0000CB   A3           INC       DPTR
   \   0000CC   E5..         MOV       A,?V4
   \   0000CE   F0           MOVX      @DPTR,A
    542                pBuf[2] = BREAK_UINT32( tmp32, 1 );
   \   0000CF   7402         MOV       A,#0x2
   \   0000D1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D4   78..         MOV       R0,#?V4
   \   0000D6   12....       LCALL     ?L_MOV_X
   \   0000D9   E5..         MOV       A,?V5
   \   0000DB   85..82       MOV       DPL,?V2
   \   0000DE   85..83       MOV       DPH,?V3
   \   0000E1   A3           INC       DPTR
   \   0000E2   A3           INC       DPTR
   \   0000E3   F0           MOVX      @DPTR,A
    543                pBuf[3] = BREAK_UINT32( tmp32, 0 );
   \   0000E4   7402         MOV       A,#0x2
   \   0000E6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E9   78..         MOV       R0,#?V4
   \   0000EB   12....       LCALL     ?L_MOV_X
   \   0000EE   85..82       MOV       DPL,?V2
   \   0000F1   85..83       MOV       DPH,?V3
   \   0000F4   A3           INC       DPTR
   \   0000F5   A3           INC       DPTR
   \   0000F6   A3           INC       DPTR
   \   0000F7   E5..         MOV       A,?V4
   \   0000F9   F0           MOVX      @DPTR,A
    544              }
    545              pBuf += sizeof( tmp32 );
   \                     ??MT_UtilGetNvInfo_4:
   \   0000FA   E5..         MOV       A,?V2
   \   0000FC   2404         ADD       A,#0x4
   \   0000FE   F5..         MOV       ?V2,A
   \   000100   5002         JNC       ??MT_UtilGetNvInfo_5
   \   000102   05..         INC       ?V3
    546          
    547              /* ZigBee PanID */
    548              if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
   \                     ??MT_UtilGetNvInfo_5:
   \   000104                ; Setup parameters for call to function osal_nv_read
   \   000104   A8..         MOV       R0,?XSP + 0
   \   000106   A9..         MOV       R1,?XSP + 1
   \   000108   88..         MOV       ?V4,R0
   \   00010A   89..         MOV       ?V5,R1
   \   00010C   78..         MOV       R0,#?V4
   \   00010E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000111   75..02       MOV       ?V4,#0x2
   \   000114   75..00       MOV       ?V5,#0x0
   \   000117   78..         MOV       R0,#?V4
   \   000119   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00011C   7C00         MOV       R4,#0x0
   \   00011E   7D00         MOV       R5,#0x0
   \   000120   7A83         MOV       R2,#-0x7d
   \   000122   7B00         MOV       R3,#0x0
   \   000124   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000127   7404         MOV       A,#0x4
   \   000129   12....       LCALL     ?DEALLOC_XSTACK8
   \   00012C   E9           MOV       A,R1
   \   00012D   6008         JZ        ??MT_UtilGetNvInfo_6
    549              {
    550                stat |= 0x04;
   \   00012F   E5..         MOV       A,?V0
   \   000131   D2E2         SETB      0xE0 /* A   */.2
   \   000133   F5..         MOV       ?V0,A
   \   000135   801E         SJMP      ??MT_UtilGetNvInfo_7
    551              }
    552              else
    553              {
    554                pBuf[0] = LO_UINT16( tmp16 );
   \                     ??MT_UtilGetNvInfo_6:
   \   000137   85..82       MOV       DPL,?XSP + 0
   \   00013A   85..83       MOV       DPH,?XSP + 1
   \   00013D   E0           MOVX      A,@DPTR
   \   00013E   85..82       MOV       DPL,?V2
   \   000141   85..83       MOV       DPH,?V3
   \   000144   F0           MOVX      @DPTR,A
    555                pBuf[1] = HI_UINT16( tmp16 );
   \   000145   85..82       MOV       DPL,?XSP + 0
   \   000148   85..83       MOV       DPH,?XSP + 1
   \   00014B   A3           INC       DPTR
   \   00014C   E0           MOVX      A,@DPTR
   \   00014D   85..82       MOV       DPL,?V2
   \   000150   85..83       MOV       DPH,?V3
   \   000153   A3           INC       DPTR
   \   000154   F0           MOVX      @DPTR,A
    556              }
    557              pBuf += sizeof( tmp16 );
   \                     ??MT_UtilGetNvInfo_7:
   \   000155   E5..         MOV       A,?V2
   \   000157   2402         ADD       A,#0x2
   \   000159   F5..         MOV       ?V2,A
   \   00015B   5002         JNC       ??MT_UtilGetNvInfo_8
   \   00015D   05..         INC       ?V3
    558          
    559              /* Security level */
    560              if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
   \                     ??MT_UtilGetNvInfo_8:
   \   00015F                ; Setup parameters for call to function osal_nv_read
   \   00015F   78..         MOV       R0,#?V2
   \   000161   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000164   75..01       MOV       ?V4,#0x1
   \   000167   78..         MOV       R0,#?V4
   \   000169   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00016C   7C00         MOV       R4,#0x0
   \   00016E   7D00         MOV       R5,#0x0
   \   000170   7A61         MOV       R2,#0x61
   \   000172   7B00         MOV       R3,#0x0
   \   000174   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000177   7404         MOV       A,#0x4
   \   000179   12....       LCALL     ?DEALLOC_XSTACK8
   \   00017C   E9           MOV       A,R1
   \   00017D   F8           MOV       R0,A
   \   00017E   85..82       MOV       DPL,?V2
   \   000181   85..83       MOV       DPH,?V3
   \   000184   A3           INC       DPTR
   \   000185   8582..       MOV       ?V2,DPL
   \   000188   8583..       MOV       ?V3,DPH
   \   00018B   6006         JZ        ??MT_UtilGetNvInfo_9
    561              {
    562                stat |= 0x08;
   \   00018D   E5..         MOV       A,?V0
   \   00018F   D2E3         SETB      0xE0 /* A   */.3
   \   000191   F5..         MOV       ?V0,A
    563              }
    564              /* Pre-configured security key */
    565              if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
   \                     ??MT_UtilGetNvInfo_9:
   \   000193                ; Setup parameters for call to function osal_nv_read
   \   000193   78..         MOV       R0,#?V2
   \   000195   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000198   75..10       MOV       ?V2,#0x10
   \   00019B   75..00       MOV       ?V3,#0x0
   \   00019E   78..         MOV       R0,#?V2
   \   0001A0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001A3   7C00         MOV       R4,#0x0
   \   0001A5   7D00         MOV       R5,#0x0
   \   0001A7   7A62         MOV       R2,#0x62
   \   0001A9   7B00         MOV       R3,#0x0
   \   0001AB   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0001AE   7404         MOV       A,#0x4
   \   0001B0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001B3   E9           MOV       A,R1
   \   0001B4   6006         JZ        ??MT_UtilGetNvInfo_10
    566              {
    567                stat |= 0x10;
   \   0001B6   E5..         MOV       A,?V0
   \   0001B8   D2E4         SETB      0xE0 /* A   */.4
   \   0001BA   F5..         MOV       ?V0,A
    568              }
    569              /* Status bit mask - bit=1 indicates failure */
    570              *buf = stat;
   \                     ??MT_UtilGetNvInfo_10:
   \   0001BC   8E82         MOV       DPL,R6
   \   0001BE   8F83         MOV       DPH,R7
   \   0001C0   E5..         MOV       A,?V0
   \   0001C2   F0           MOVX      @DPTR,A
    571          
    572              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
    573                                            len, buf );
   \   0001C3                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0001C3   EE           MOV       A,R6
   \   0001C4   FC           MOV       R4,A
   \   0001C5   EF           MOV       A,R7
   \   0001C6   FD           MOV       R5,A
   \   0001C7   7B20         MOV       R3,#0x20
   \   0001C9   7A01         MOV       R2,#0x1
   \   0001CB   7967         MOV       R1,#0x67
   \   0001CD   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
    574          
    575              osal_mem_free( buf );
   \   0001D0                ; Setup parameters for call to function osal_mem_free
   \   0001D0   EE           MOV       A,R6
   \   0001D1   FA           MOV       R2,A
   \   0001D2   EF           MOV       A,R7
   \   0001D3   FB           MOV       R3,A
   \   0001D4   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    576            }
    577          }
   \                     ??MT_UtilGetNvInfo_0:
   \   0001D7   7406         MOV       A,#0x6
   \   0001D9   02....       LJMP      ?Subroutine0 & 0xFFFF
    578          
    579          /***************************************************************************************************
    580           * @fn      MT_UtilSetPanID
    581           *
    582           * @brief   Set PanID message
    583           *
    584           * @param   pBuf - pointer to the data
    585           *
    586           * @return  void
    587           ***************************************************************************************************/
    588          static void MT_UtilSetPanID(uint8 *pBuf)
    589          {
    590            uint16 temp16;
    591            uint8 retValue;
    592            uint8 cmdId;
    593          
    594            /* parse header */
    595            cmdId = pBuf[MT_RPC_POS_CMD1];
    596            pBuf += MT_RPC_FRAME_HDR_SZ;
    597          
    598            temp16 = osal_build_uint16( pBuf );
    599          
    600            retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
    601          
    602            /* Build and send back the response */
    603            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
    604          }
    605          
    606          /***************************************************************************************************
    607           * @fn      MT_UtilSetChannels
    608           *
    609           * @brief   Set Channels
    610           *
    611           * @param   pBuf - pointer to the data
    612           *
    613           * @return  void
    614           ***************************************************************************************************/
    615          static void MT_UtilSetChannels(uint8 *pBuf)
    616          {
    617            uint32 tmp32;
    618            uint8 retValue;
    619            uint8 cmdId;
    620          
    621            /* parse header */
    622            cmdId = pBuf[MT_RPC_POS_CMD1];
    623            pBuf += MT_RPC_FRAME_HDR_SZ;
    624          
    625            tmp32 = osal_build_uint32( pBuf, 4 );
    626          
    627            retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
    628          
    629            /* Build and send back the response */
    630            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
    631          }
    632          
    633          /***************************************************************************************************
    634           * @fn      MT_UtilSetSecLevel
    635           *
    636           * @brief   Set Sec Level
    637           *
    638           * @param   byte *msg - pointer to the data
    639           *
    640           * @return  void
    641           ***************************************************************************************************/
    642          static void MT_UtilSetSecLevel(uint8 *pBuf)
    643          {
    644            uint8 retValue;
    645            uint8 cmdId;
    646          
    647            /* parse header */
    648            cmdId = pBuf[MT_RPC_POS_CMD1];
    649            pBuf += MT_RPC_FRAME_HDR_SZ;
    650          
    651            retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
    652          
    653            /* Build and send back the response */
    654            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    655          
    656          }
    657          
    658          /***************************************************************************************************
    659           * @fn      MT_UtilSetPreCfgKey
    660           *
    661           * @brief   Set Pre Cfg Key
    662           *
    663           * @param   pBuf - pointer to the data
    664           *
    665           * @return  void
    666           ***************************************************************************************************/
    667          static void MT_UtilSetPreCfgKey(uint8 *pBuf)
    668          {
    669            uint8 retValue;
    670            uint8 cmdId;
    671          
    672            /* parse header */
    673            cmdId = pBuf[MT_RPC_POS_CMD1];
    674            pBuf += MT_RPC_FRAME_HDR_SZ;
    675          
    676            retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
    677          
    678            /* Build and send back the response */
    679            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    680          
    681          }
    682          
    683          #ifdef FEATURE_GET_PRIMARY_IEEE
    684          /***************************************************************************************************
    685           * @fn      MT_UtilGetPrimaryIEEE
    686           *
    687           * @brief   Return a copy of the Primary IEEE address
    688           *
    689           * @param   none
    690           *
    691           * @return  void
    692           ***************************************************************************************************/
    693          static void MT_UtilGetPrimaryIEEE(void)
    694          {
    695            uint8 i;
    696            uint8 retBuf[Z_EXTADDR_LEN+1];
    697          
    698            retBuf[0] = SUCCESS;
    699          
    700            for(i = 1; i <= Z_EXTADDR_LEN; i++)
    701            {
    702              retBuf[i] = ieeeMac[i];
    703            }
    704          
    705            MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    706                                            MT_UTIL_GET_PRIMARY_IEEE, Z_EXTADDR_LEN+1, retBuf );
    707          }
    708          #endif /* FEATURE_GET_PRIMARY_IEEE */
    709          
    710          /***************************************************************************************************
    711           * @fn      MT_UtilCallbackSub
    712           *
    713           * @brief   The Callback subscribe.
    714           *
    715           * @param   pBuf - pointer to the data
    716           *
    717           * @return  void
    718           ***************************************************************************************************/
    719          void MT_UtilCallbackSub(uint8 *pBuf)
    720          {
    721            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
    722            uint8 retValue = ZFailure;
    723          
    724          #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
    725            uint8 subSystem;
    726            uint16 subscribed_command;
    727          
    728            // Move past header
    729            retValue = ZSuccess;
    730            pBuf += MT_RPC_FRAME_HDR_SZ;
    731          
    732            /* Command */
    733            subscribed_command = osal_build_uint16( pBuf );
    734            pBuf += 2;
    735          
    736            /* Subsystem - 5 bits on the MSB of the command */
    737            subSystem = HI_UINT16(subscribed_command) & 0x1F ;
    738          
    739            /* What is the action - SUBSCRIBE or !SUBSCRIBE */
    740            if (*pBuf)
    741            {
    742              /* Turn ON */
    743            #if defined( MT_MAC_CB_FUNC )
    744              if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
    745              {
    746              #if !defined (FEATURE_DUAL_MAC)
    747                _macCallbackSub = 0xFFFF;
    748              #else
    749                DMMGR_SaveMacCbReg( 0xFFFF );
    750              #endif /* ! FEATURE_DUAL_MAC */
    751              }
    752            #endif
    753          
    754            #if defined( MT_NWK_CB_FUNC )
    755              if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
    756                _nwkCallbackSub = 0xFFFF;
    757            #endif
    758          
    759            #if defined( MT_ZDO_CB_FUNC )
    760              if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
    761                _zdoCallbackSub = 0xFFFFFFFF;
    762            #endif
    763          
    764            #if defined( MT_AF_CB_FUNC )
    765              if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
    766                _afCallbackSub = 0xFFFF;
    767            #endif
    768          
    769            #if defined( MT_SAPI_CB_FUNC )
    770              if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
    771                _sapiCallbackSub = 0xFFFF;
    772            #endif
    773            }
    774            else
    775            {
    776              /* Turn OFF */
    777            #if defined( MT_MAC_CB_FUNC )
    778              if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
    779                _macCallbackSub = 0x0000;
    780          
    781            #if defined (FEATURE_DUAL_MAC )
    782              DMMGR_SaveMacCbReg( 0x0000 );
    783            #endif /* FEATURE_DUAL_MAC */
    784          
    785            #endif
    786          
    787            #if defined( MT_NWK_CB_FUNC )
    788              if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
    789                _nwkCallbackSub = 0x0000;
    790            #endif
    791          
    792            #if defined( MT_ZDO_CB_FUNC )
    793              if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
    794                _zdoCallbackSub = 0x00000000;
    795            #endif
    796          
    797            #if defined( MT_AF_CB_FUNC )
    798              if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
    799                _afCallbackSub = 0x0000;
    800            #endif
    801          
    802            #if defined( MT_SAPI_CB_FUNC )
    803              if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
    804                  _sapiCallbackSub = 0x0000;
    805            #endif
    806            }
    807          #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
    808          
    809            /* Build and send back the response */
    810            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    811          }
    812          
    813          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    814          /***************************************************************************************************
    815           * @fn      MT_UtilKeyEvent
    816           *
    817           * @brief   Process Key Event
    818           *
    819           * @param   pBuf - pointer to the data
    820           *
    821           * @return  void
    822           ***************************************************************************************************/
    823          static void MT_UtilKeyEvent(uint8 *pBuf)
    824          {
    825            uint8 x = 0;
    826            uint8 retValue;
    827            uint8 cmdId;
    828          
    829            /* parse header */
    830            cmdId = pBuf[MT_RPC_POS_CMD1];
    831            pBuf += MT_RPC_FRAME_HDR_SZ;
    832          
    833            /* Translate between SPI values to device values */
    834            if ( *pBuf & 0x01 )
    835              x |= HAL_KEY_SW_1;
    836            if ( *pBuf & 0x02 )
    837              x |= HAL_KEY_SW_2;
    838            if ( *pBuf & 0x04 )
    839              x |= HAL_KEY_SW_3;
    840            if ( *pBuf & 0x08 )
    841              x |= HAL_KEY_SW_4;
    842          #if defined ( HAL_KEY_SW_5 )
    843            if ( *pBuf & 0x10 )
    844              x |= HAL_KEY_SW_5;
    845          #endif
    846          #if defined ( HAL_KEY_SW_6 )
    847            if ( *pBuf & 0x20 )
    848              x |= HAL_KEY_SW_6;
    849          #endif
    850          #if defined ( HAL_KEY_SW_7 )
    851            if ( *pBuf & 0x40 )
    852              x |= HAL_KEY_SW_7;
    853          #endif
    854          #if defined ( HAL_KEY_SW_8 )
    855            if ( *pBuf & 0x80 )
    856              x |= HAL_KEY_SW_8;
    857          #endif
    858            pBuf++;
    859          
    860            retValue = OnBoard_SendKeys(x, *pBuf);
    861          
    862            /* Build and send back the response */
    863            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    864          }
    865          #endif
    866          
    867          /***************************************************************************************************
    868           * @fn      MT_UtilTimeAlive
    869           *
    870           * @brief   Process Time Alive
    871           *
    872           * @param   None.
    873           *
    874           * @return  None
    875           ***************************************************************************************************/
    876          static void MT_UtilTimeAlive(void)
    877          {
    878            uint8 timeAlive[4];
    879            uint32 tmp32;
    880          
    881            /* Time since last reset (seconds) */
    882            tmp32 = osal_GetSystemClock() / 1000;
    883          
    884            /* Convert to high byte first into temp buffer */
    885            osal_buffer_uint32( timeAlive, tmp32 );
    886          
    887            /* Build and send back the response */
    888            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
    889                                                 MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
    890          }
    891          
    892          #if (defined HAL_LED) && (HAL_LED == TRUE)
    893          /***************************************************************************************************
    894           * @fn      MT_UtilLedControl
    895           *
    896           * @brief   Process the LED Control Message
    897           *
    898           * @param   pBuf - pointer to the received data
    899           *
    900           * @return  None
    901           ***************************************************************************************************/
    902          static void MT_UtilLedControl(uint8 *pBuf)
    903          {
    904            uint8 iLed, Led, iMode, Mode, cmdId;
    905            uint8 retValue;
    906          
    907            /* parse header */
    908            cmdId = pBuf[MT_RPC_POS_CMD1];
    909            pBuf += MT_RPC_FRAME_HDR_SZ;
    910          
    911            /* LED and Mode */
    912            iLed = *pBuf++;
    913            iMode = *pBuf;
    914          
    915            if ( iLed == 1 )
    916              Led = HAL_LED_1;
    917            else if ( iLed == 2 )
    918              Led = HAL_LED_2;
    919            else if ( iLed == 3 )
    920              Led = HAL_LED_3;
    921            else if ( iLed == 4 )
    922              Led = HAL_LED_4;
    923            else if ( iLed == 0xFF )
    924              Led = HAL_LED_ALL;
    925            else
    926              Led = 0;
    927          
    928            if ( iMode == 0 )
    929              Mode = HAL_LED_MODE_OFF;
    930            else if ( iMode == 1 )
    931              Mode = HAL_LED_MODE_ON;
    932            else if ( iMode == 2 )
    933              Mode = HAL_LED_MODE_BLINK;
    934            else if ( iMode == 3 )
    935              Mode = HAL_LED_MODE_FLASH;
    936            else if ( iMode == 4 )
    937              Mode = HAL_LED_MODE_TOGGLE;
    938            else
    939              Led = 0;
    940          
    941            if ( Led != 0 )
    942            {
    943              HalLedSet (Led, Mode);
    944              retValue = ZSuccess;
    945            }
    946            else
    947            {
    948              retValue = ZFailure;
    949            }
    950          
    951            /* Build and send back the response */
    952            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    953          }
    954          #endif /* HAL_LED */
    955          
    956          /***************************************************************************************************
    957           * @fn          MT_UtilSrcMatchEnable
    958           *
    959           * @brief      Enabled AUTOPEND and source address matching.
    960           *
    961           * @param      pBuf - Buffer contains the data
    962           *
    963           * @return     void
    964           ***************************************************************************************************/
    965          static void MT_UtilSrcMatchEnable (uint8 *pBuf)
    966          {
    967            uint8 retValue, cmdId;
    968          
    969            /* Parse header */
    970            cmdId = pBuf[MT_RPC_POS_CMD1];
    971            pBuf += MT_RPC_FRAME_HDR_SZ;
    972          
    973          #ifdef AUTO_PEND
    974            /* Call the routine */
    975            retValue = ZMacSrcMatchEnable();
    976          #else
    977            retValue = ZMacUnsupported;
    978          #endif
    979          
    980            /* Build and send back the response */
    981            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
    982          
    983          }
    984          
    985          /***************************************************************************************************
    986           * @fn          MT_UtilSrcMatchAddEntry
    987           *
    988           * @brief       Add a short or extended address to source address table.
    989           *
    990           * @param       pBuf - Buffer contains the data
    991           *
    992           * @return      void
    993           ***************************************************************************************************/
    994          static void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
    995          {
    996            uint8 retValue, cmdId;
    997          
    998            /* Parse header */
    999            cmdId = pBuf[MT_RPC_POS_CMD1];
   1000            pBuf += MT_RPC_FRAME_HDR_SZ;
   1001          
   1002          #ifdef AUTO_PEND
   1003            uint16 panID;
   1004            zAddrType_t devAddr;
   1005          
   1006            /* Address mode */
   1007            devAddr.addrMode = *pBuf++;
   1008          
   1009            /* Address based on the address mode */
   1010            MT_UtilSpi2Addr( &devAddr, pBuf);
   1011            pBuf += Z_EXTADDR_LEN;
   1012          
   1013            /* PanID */
   1014            panID = osal_build_uint16( pBuf );
   1015          
   1016            /* Call the routine */
   1017            retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
   1018          #else
   1019            retValue = ZMacUnsupported;
   1020          #endif
   1021          
   1022            /* Build and send back the response */
   1023            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   1024          }
   1025          
   1026          /***************************************************************************************************
   1027           * @fn          MT_UtilSrcMatchDeleteEntry
   1028           *
   1029           * @brief      Delete a short or extended address from source address table.
   1030           *
   1031           * @param      pBuf - Buffer contains the data
   1032           *
   1033           * @return     void
   1034           ***************************************************************************************************/
   1035          static void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
   1036          {
   1037            uint8 retValue, cmdId;
   1038          
   1039            /* Parse header */
   1040            cmdId = pBuf[MT_RPC_POS_CMD1];
   1041            pBuf += MT_RPC_FRAME_HDR_SZ;
   1042          
   1043          #ifdef AUTO_PEND
   1044            uint16 panID;
   1045            zAddrType_t devAddr;
   1046          
   1047            /* Address mode */
   1048            devAddr.addrMode = *pBuf++;
   1049          
   1050            /* Address based on the address mode */
   1051            MT_UtilSpi2Addr( &devAddr, pBuf);
   1052            pBuf += Z_EXTADDR_LEN;
   1053          
   1054            /* PanID */
   1055            panID = osal_build_uint16( pBuf );
   1056          
   1057            /* Call the routine */
   1058            retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
   1059          #else
   1060            retValue = ZMacUnsupported;
   1061          #endif
   1062          
   1063            /* Build and send back the response */
   1064            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   1065          }
   1066          
   1067          /***************************************************************************************************
   1068           * @fn          MT_UtilSrcMatchCheckSrcAddr
   1069           *
   1070           * @brief      Check if a short or extended address is in the source address table.
   1071           *
   1072           * @param      pBuf - Buffer contains the data
   1073           *
   1074           * @return     void
   1075           ***************************************************************************************************/
   1076          static void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
   1077          {
   1078            uint8 cmdId;
   1079            uint8 retArray[2];
   1080          
   1081            /* Parse header */
   1082            cmdId = pBuf[MT_RPC_POS_CMD1];
   1083            pBuf += MT_RPC_FRAME_HDR_SZ;
   1084          
   1085          #if 0  /* Unsupported  */
   1086            uint16 panID;
   1087            zAddrType_t devAddr;
   1088          
   1089            /* Address mode */
   1090            devAddr.addrMode = *pBuf++;
   1091          
   1092            /* Address based on the address mode */
   1093            MT_UtilSpi2Addr( &devAddr, pBuf);
   1094            pBuf += Z_EXTADDR_LEN;
   1095          
   1096            /* PanID */
   1097            panID = osal_build_uint16( pBuf );
   1098          
   1099            /* Call the routine */
   1100            retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
   1101          
   1102              /* Return failure if the index is invalid */
   1103            if (retArray[1] == ZMacSrcMatchInvalidIndex )
   1104            {
   1105              retArray[0] = ZFailure;
   1106            }
   1107            else
   1108            {
   1109              retArray[0] = ZSuccess;
   1110            }
   1111          #else
   1112            retArray[0] = ZMacUnsupported;
   1113            retArray[1] = ZMacSrcMatchInvalidIndex;
   1114          #endif
   1115          
   1116            /* Build and send back the response */
   1117            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
   1118          }
   1119          
   1120          /***************************************************************************************************
   1121           * @fn          MT_UtilSrcMatchAckAllPending
   1122           *
   1123           * @brief       Enabled/disable acknowledging all packets with pending bit set
   1124           *              It is normally enabled when adding new entries to
   1125           *              the source address table fails due to the table is full, or
   1126           *              disabled when more entries are deleted and the table has
   1127           *              empty slots.
   1128           *
   1129           * @param       pBuf - Buffer contains the data
   1130           *
   1131           * @return      void
   1132           ***************************************************************************************************/
   1133          static void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
   1134          {
   1135            uint8 retValue, cmdId;
   1136          
   1137            /* Parse header */
   1138            cmdId = pBuf[MT_RPC_POS_CMD1];
   1139            pBuf += MT_RPC_FRAME_HDR_SZ;
   1140          
   1141          #ifdef AUTO_PEND
   1142            /* Call the routine */
   1143            retValue = ZMacSrcMatchAckAllPending(*pBuf);
   1144          #else
   1145            retValue = ZMacUnsupported;
   1146          #endif
   1147          
   1148            /* Build and send back the response */
   1149            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
   1150          }
   1151          
   1152          /***************************************************************************************************
   1153           * @fn          MT_UtilSrcMatchCheckAllPending
   1154           *
   1155           * @brief       Check if acknowledging all packets with pending bit set
   1156           *              is enabled.
   1157           *
   1158           * @param       pBuf - Buffer contains the data
   1159           *
   1160           * @return      void
   1161           ***************************************************************************************************/
   1162          static void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
   1163          {
   1164            uint8 retArray[2], cmdId;
   1165          
   1166            /* Parse header */
   1167            cmdId = pBuf[MT_RPC_POS_CMD1];
   1168            pBuf += MT_RPC_FRAME_HDR_SZ;
   1169          
   1170          #ifdef AUTO_PEND
   1171            /* Call the routine */
   1172            retArray[0] = ZMacSuccess;
   1173            retArray[1] = ZMacSrcMatchCheckAllPending();
   1174          #else
   1175            retArray[0] = ZMacUnsupported;
   1176            retArray[1] = FALSE;
   1177          #endif
   1178          
   1179            /* Build and send back the response */
   1180            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
   1181          }
   1182          
   1183          /***************************************************************************************************
   1184           * SUPPORT
   1185           ***************************************************************************************************/
   1186          
   1187          #ifdef AUTO_PEND
   1188          /***************************************************************************************************
   1189           * @fn      MT_UtilRevExtCpy
   1190           *
   1191           * @brief
   1192           *
   1193           *   Reverse-copy an extended address.
   1194           *
   1195           * @param   pDst - Pointer to data destination
   1196           * @param   pSrc - Pointer to data source
   1197           *
   1198           * @return  void
   1199           ***************************************************************************************************/
   1200          static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
   1201          {
   1202            int8 i;
   1203          
   1204            for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
   1205            {
   1206              *pDst++ = pSrc[i];
   1207            }
   1208          }
   1209          
   1210          /***************************************************************************************************
   1211           * @fn      MT_UtilSpi2Addr
   1212           *
   1213           * @brief   Copy an address from an SPI message to an address struct.  The
   1214           *          addrMode in pAddr must already be set.
   1215           *
   1216           * @param   pDst - Pointer to address struct
   1217           * @param   pSrc - Pointer SPI message byte array
   1218           *
   1219           * @return  void
   1220           ***************************************************************************************************/
   1221          static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
   1222          {
   1223            if ( pDst->addrMode == Addr16Bit )
   1224            {
   1225              pDst->addr.shortAddr = osal_build_uint16( pSrc );
   1226            }
   1227            else if ( pDst->addrMode == Addr64Bit )
   1228            {
   1229              MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
   1230            }
   1231          }
   1232          #endif // AUTO_PEND
   1233          
   1234          /***************************************************************************************************
   1235           * @fn      MT_UtilGpioRead
   1236           *
   1237           * @brief   Read values of all GPIOs (P0_0 -P2_4)
   1238           *
   1239           * @param   void
   1240           *
   1241           * @return  P0, P1, P2, P0DIR, P1DIR, P2DIR
   1242           ***************************************************************************************************/
   1243          static void MT_UtilGpioRead(uint8 *pBuf)
   1244          {
   1245          #if defined ( HAL_MCU_CC2530 )
   1246            uint8 rtrn[6] = {P0, P1, P2, P0DIR, P1DIR, P2DIR};
   1247          #else
   1248            uint8 rtrn[6] = {0, 0, 0, 0, 0, 0};
   1249          #endif
   1250            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_READ,
   1251              6, rtrn);
   1252          }
   1253          
   1254          /***************************************************************************************************
   1255           * @fn      MT_UtilGpioSetDirection
   1256           *
   1257           * @brief   Set the direction of a specific GPIO (P0_0 -P2_4)
   1258           *
   1259           * @param   port - 0, 1 or 2
   1260           * @param   bit - 0 - 7
   1261           * @param   direction - 0 for input, 1 for output
   1262           *
   1263           * @return  oldP0DIR, oldP1DIR, oldP2DIR, newP0DIR, newP1DIR, newP2DIR
   1264           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1265          static void MT_UtilGpioSetDirection(uint8 *pBuf)
   \                     MT_UtilGpioSetDirection:
   1266          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1267          #if defined ( HAL_MCU_CC2530 )
   1268            uint8 rtrn[6] = {P0DIR, P1DIR, P2DIR, 0, 0, 0};
   \   00000A   90....       MOV       DPTR,#`?<Constant {0, 0, 0, 0, 0, 0}>`
   \   00000D   AC..         MOV       R4,?XSP + 0
   \   00000F   AD..         MOV       R5,?XSP + 1
   \   000011   7406         MOV       A,#0x6
   \   000013   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000016   E5FD         MOV       A,0xfd
   \   000018   85..82       MOV       DPL,?XSP + 0
   \   00001B   85..83       MOV       DPH,?XSP + 1
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   E5FE         MOV       A,0xfe
   \   000021   C0E0         PUSH      A
   \   000023   7401         MOV       A,#0x1
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   D0E0         POP       A
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   E5FF         MOV       A,0xff
   \   00002D   C0E0         PUSH      A
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   D0E0         POP       A
   \   000036   12....       LCALL     ?Subroutine2 & 0xFFFF
   1269            uint8 port = pBuf[MT_RPC_POS_DAT0 + 0];
   1270            uint8 bit = pBuf[MT_RPC_POS_DAT0 + 1];
   1271            uint8 direction = pBuf[MT_RPC_POS_DAT0 + 2];
   1272          
   1273            if (direction == 0)
   \                     ??CrossCallReturnLabel_0:
   \   000039   7044         JNZ       ??MT_UtilGpioSetDirection_0
   1274            {
   1275              switch (port)
   \   00003B   E9           MOV       A,R1
   \   00003C   6008         JZ        ??MT_UtilGpioSetDirection_1
   \   00003E   14           DEC       A
   \   00003F   6018         JZ        ??MT_UtilGpioSetDirection_2
   \   000041   14           DEC       A
   \   000042   6028         JZ        ??MT_UtilGpioSetDirection_3
   \   000044   8078         SJMP      ??MT_UtilGpioSetDirection_4
   1276              {
   1277                case 0:
   1278                  P0DIR &= (~ BV(bit));
   \                     ??MT_UtilGpioSetDirection_1:
   \   000046   75..01       MOV       ?V0,#0x1
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   E8           MOV       A,R0
   \   00004D   78..         MOV       R0,#?V0
   \   00004F   12....       LCALL     ?S_SHL
   \   000052   E5..         MOV       A,?V0
   \   000054   F4           CPL       A
   \   000055   52FD         ANL       0xfd,A
   1279                  break;
   \   000057   8065         SJMP      ??MT_UtilGpioSetDirection_4
   1280                case 1:
   1281                  P1DIR &= (~ BV(bit));
   \                     ??MT_UtilGpioSetDirection_2:
   \   000059   75..01       MOV       ?V0,#0x1
   \   00005C   75..00       MOV       ?V1,#0x0
   \   00005F   E8           MOV       A,R0
   \   000060   78..         MOV       R0,#?V0
   \   000062   12....       LCALL     ?S_SHL
   \   000065   E5..         MOV       A,?V0
   \   000067   F4           CPL       A
   \   000068   52FE         ANL       0xfe,A
   1282                  break;
   \   00006A   8052         SJMP      ??MT_UtilGpioSetDirection_4
   1283                case 2:
   1284                  P2DIR &= (~ BV(bit));
   \                     ??MT_UtilGpioSetDirection_3:
   \   00006C   75..01       MOV       ?V0,#0x1
   \   00006F   75..00       MOV       ?V1,#0x0
   \   000072   E8           MOV       A,R0
   \   000073   78..         MOV       R0,#?V0
   \   000075   12....       LCALL     ?S_SHL
   \   000078   E5..         MOV       A,?V0
   \   00007A   F4           CPL       A
   \   00007B   52FF         ANL       0xff,A
   1285                  break;
   \   00007D   803F         SJMP      ??MT_UtilGpioSetDirection_4
   1286              }
   1287            }
   1288            else
   1289            {
   1290              switch (port)
   \                     ??MT_UtilGpioSetDirection_0:
   \   00007F   E9           MOV       A,R1
   \   000080   6008         JZ        ??MT_UtilGpioSetDirection_5
   \   000082   14           DEC       A
   \   000083   6017         JZ        ??MT_UtilGpioSetDirection_6
   \   000085   14           DEC       A
   \   000086   6026         JZ        ??MT_UtilGpioSetDirection_7
   \   000088   8034         SJMP      ??MT_UtilGpioSetDirection_4
   1291              {
   1292                case 0:
   1293                  P0DIR |= BV(bit);
   \                     ??MT_UtilGpioSetDirection_5:
   \   00008A   75..01       MOV       ?V0,#0x1
   \   00008D   75..00       MOV       ?V1,#0x0
   \   000090   E8           MOV       A,R0
   \   000091   78..         MOV       R0,#?V0
   \   000093   12....       LCALL     ?S_SHL
   \   000096   E5..         MOV       A,?V0
   \   000098   42FD         ORL       0xfd,A
   1294                  break;
   \   00009A   8022         SJMP      ??MT_UtilGpioSetDirection_4
   1295                case 1:
   1296                  P1DIR |= BV(bit);
   \                     ??MT_UtilGpioSetDirection_6:
   \   00009C   75..01       MOV       ?V0,#0x1
   \   00009F   75..00       MOV       ?V1,#0x0
   \   0000A2   E8           MOV       A,R0
   \   0000A3   78..         MOV       R0,#?V0
   \   0000A5   12....       LCALL     ?S_SHL
   \   0000A8   E5..         MOV       A,?V0
   \   0000AA   42FE         ORL       0xfe,A
   1297                  break;
   \   0000AC   8010         SJMP      ??MT_UtilGpioSetDirection_4
   1298                case 2:
   1299                  P2DIR |= BV(bit);
   \                     ??MT_UtilGpioSetDirection_7:
   \   0000AE   75..01       MOV       ?V0,#0x1
   \   0000B1   75..00       MOV       ?V1,#0x0
   \   0000B4   E8           MOV       A,R0
   \   0000B5   78..         MOV       R0,#?V0
   \   0000B7   12....       LCALL     ?S_SHL
   \   0000BA   E5..         MOV       A,?V0
   \   0000BC   42FF         ORL       0xff,A
   1300                  break;
   1301              }
   1302            }
   1303          
   1304            rtrn[3] = P0DIR;
   \                     ??MT_UtilGpioSetDirection_4:
   \   0000BE   E5FD         MOV       A,0xfd
   \   0000C0   C0E0         PUSH      A
   \   0000C2   7403         MOV       A,#0x3
   \   0000C4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C7   D0E0         POP       A
   \   0000C9   F0           MOVX      @DPTR,A
   1305            rtrn[4] = P1DIR;
   \   0000CA   E5FE         MOV       A,0xfe
   \   0000CC   C0E0         PUSH      A
   \   0000CE   7404         MOV       A,#0x4
   \   0000D0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D3   D0E0         POP       A
   \   0000D5   F0           MOVX      @DPTR,A
   1306            rtrn[5] = P2DIR;
   \   0000D6   E5FF         MOV       A,0xff
   \   0000D8   C0E0         PUSH      A
   \   0000DA   7405         MOV       A,#0x5
   \   0000DC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DF   D0E0         POP       A
   \   0000E1   12....       LCALL     ?Subroutine13 & 0xFFFF
   1307          #else
   1308            uint8 rtrn[6] = {0, 0, 0, 0, 0, 0};
   1309          #endif
   1310          
   1311            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_SET_DIRECTION,
   1312              6, rtrn);
   \                     ??CrossCallReturnLabel_20:
   \   0000E4   7B06         MOV       R3,#0x6
   \   0000E6   7A14         MOV       R2,#0x14
   \   0000E8   7967         MOV       R1,#0x67
   \   0000EA   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1313          }
   \   0000ED   7406         MOV       A,#0x6
   \   0000EF                REQUIRE ?Subroutine1
   \   0000EF                REQUIRE P0DIR
   \   0000EF                REQUIRE P1DIR
   \   0000EF                REQUIRE P2DIR
   \   0000EF                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine27_0
   \   000003                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000001   AC..         MOV       R4,?XSP + 0
   \   000003   AD..         MOV       R5,?XSP + 1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   F8           MOV       R0,A
   \   00000F   8A82         MOV       DPL,R2
   \   000011   8B83         MOV       DPH,R3
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0, 0, 0, 0}>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   1314          
   1315          /***************************************************************************************************
   1316           * @fn      MT_UtilGpioWrite
   1317           *
   1318           * @brief   Write value of a specific GPIO (P0_0 -P2_4)
   1319           *
   1320           * @param   port - 0, 1 or 2
   1321           * @param   bit - 0 - 7
   1322           * @param   value - 0 or 1
   1323           *
   1324           * @return  oldP0, oldP1, oldP2, newP0, newP1, newP2, P0DIR, P1DIR, P2DIR
   1325           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1326          static void MT_UtilGpioWrite(uint8 *pBuf)
   \                     MT_UtilGpioWrite:
   1327          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1328          #if defined ( HAL_MCU_CC2530 )
   1329            uint8 rtrn[9] = {P0, P1, P2, 0, 0, 0, P0DIR, P1DIR, P2DIR};
   \   00000A   90....       MOV       DPTR,#`?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>`
   \   00000D   AC..         MOV       R4,?XSP + 0
   \   00000F   AD..         MOV       R5,?XSP + 1
   \   000011   7409         MOV       A,#0x9
   \   000013   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000016   E580         MOV       A,0x80
   \   000018   85..82       MOV       DPL,?XSP + 0
   \   00001B   85..83       MOV       DPH,?XSP + 1
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   E590         MOV       A,0x90
   \   000021   C0E0         PUSH      A
   \   000023   7401         MOV       A,#0x1
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   D0E0         POP       A
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   E5A0         MOV       A,0xa0
   \   00002D   C0E0         PUSH      A
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   D0E0         POP       A
   \   000036   F0           MOVX      @DPTR,A
   \   000037   E5FD         MOV       A,0xfd
   \   000039   C0E0         PUSH      A
   \   00003B   7406         MOV       A,#0x6
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   D0E0         POP       A
   \   000042   F0           MOVX      @DPTR,A
   \   000043   E5FE         MOV       A,0xfe
   \   000045   C0E0         PUSH      A
   \   000047   7407         MOV       A,#0x7
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   D0E0         POP       A
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   E5FF         MOV       A,0xff
   \   000051   C0E0         PUSH      A
   \   000053   7408         MOV       A,#0x8
   \   000055   12....       LCALL     ?XSTACK_DISP0_8
   \   000058   D0E0         POP       A
   \   00005A   12....       LCALL     ?Subroutine2 & 0xFFFF
   1330            uint8 port = pBuf[MT_RPC_POS_DAT0 + 0];
   1331            uint8 bit = pBuf[MT_RPC_POS_DAT0 + 1];
   1332            uint8 value = pBuf[MT_RPC_POS_DAT0 + 2];
   1333          
   1334            if (value == 0)
   \                     ??CrossCallReturnLabel_1:
   \   00005D   7044         JNZ       ??MT_UtilGpioWrite_0
   1335            {
   1336              switch (port)
   \   00005F   E9           MOV       A,R1
   \   000060   6008         JZ        ??MT_UtilGpioWrite_1
   \   000062   14           DEC       A
   \   000063   6018         JZ        ??MT_UtilGpioWrite_2
   \   000065   14           DEC       A
   \   000066   6028         JZ        ??MT_UtilGpioWrite_3
   \   000068   8078         SJMP      ??MT_UtilGpioWrite_4
   1337              {
   1338                case 0:
   1339                  P0 &= (~ BV(bit));
   \                     ??MT_UtilGpioWrite_1:
   \   00006A   75..01       MOV       ?V0,#0x1
   \   00006D   75..00       MOV       ?V1,#0x0
   \   000070   E8           MOV       A,R0
   \   000071   78..         MOV       R0,#?V0
   \   000073   12....       LCALL     ?S_SHL
   \   000076   E5..         MOV       A,?V0
   \   000078   F4           CPL       A
   \   000079   5280         ANL       0x80,A
   1340                  break;
   \   00007B   8065         SJMP      ??MT_UtilGpioWrite_4
   1341                case 1:
   1342                  P1 &= (~ BV(bit));
   \                     ??MT_UtilGpioWrite_2:
   \   00007D   75..01       MOV       ?V0,#0x1
   \   000080   75..00       MOV       ?V1,#0x0
   \   000083   E8           MOV       A,R0
   \   000084   78..         MOV       R0,#?V0
   \   000086   12....       LCALL     ?S_SHL
   \   000089   E5..         MOV       A,?V0
   \   00008B   F4           CPL       A
   \   00008C   5290         ANL       0x90,A
   1343                  break;
   \   00008E   8052         SJMP      ??MT_UtilGpioWrite_4
   1344                case 2:
   1345                  P2 &= (~ BV(bit));
   \                     ??MT_UtilGpioWrite_3:
   \   000090   75..01       MOV       ?V0,#0x1
   \   000093   75..00       MOV       ?V1,#0x0
   \   000096   E8           MOV       A,R0
   \   000097   78..         MOV       R0,#?V0
   \   000099   12....       LCALL     ?S_SHL
   \   00009C   E5..         MOV       A,?V0
   \   00009E   F4           CPL       A
   \   00009F   52A0         ANL       0xa0,A
   1346                  break;
   \   0000A1   803F         SJMP      ??MT_UtilGpioWrite_4
   1347              }
   1348            }
   1349            else
   1350            {
   1351              switch (port)
   \                     ??MT_UtilGpioWrite_0:
   \   0000A3   E9           MOV       A,R1
   \   0000A4   6008         JZ        ??MT_UtilGpioWrite_5
   \   0000A6   14           DEC       A
   \   0000A7   6017         JZ        ??MT_UtilGpioWrite_6
   \   0000A9   14           DEC       A
   \   0000AA   6026         JZ        ??MT_UtilGpioWrite_7
   \   0000AC   8034         SJMP      ??MT_UtilGpioWrite_4
   1352              {
   1353                case 0:
   1354                  P0 |= BV(bit);
   \                     ??MT_UtilGpioWrite_5:
   \   0000AE   75..01       MOV       ?V0,#0x1
   \   0000B1   75..00       MOV       ?V1,#0x0
   \   0000B4   E8           MOV       A,R0
   \   0000B5   78..         MOV       R0,#?V0
   \   0000B7   12....       LCALL     ?S_SHL
   \   0000BA   E5..         MOV       A,?V0
   \   0000BC   4280         ORL       0x80,A
   1355                  break;
   \   0000BE   8022         SJMP      ??MT_UtilGpioWrite_4
   1356                case 1:
   1357                  P1 |= BV(bit);
   \                     ??MT_UtilGpioWrite_6:
   \   0000C0   75..01       MOV       ?V0,#0x1
   \   0000C3   75..00       MOV       ?V1,#0x0
   \   0000C6   E8           MOV       A,R0
   \   0000C7   78..         MOV       R0,#?V0
   \   0000C9   12....       LCALL     ?S_SHL
   \   0000CC   E5..         MOV       A,?V0
   \   0000CE   4290         ORL       0x90,A
   1358                  break;
   \   0000D0   8010         SJMP      ??MT_UtilGpioWrite_4
   1359                case 2:
   1360                  P2 |= BV(bit);
   \                     ??MT_UtilGpioWrite_7:
   \   0000D2   75..01       MOV       ?V0,#0x1
   \   0000D5   75..00       MOV       ?V1,#0x0
   \   0000D8   E8           MOV       A,R0
   \   0000D9   78..         MOV       R0,#?V0
   \   0000DB   12....       LCALL     ?S_SHL
   \   0000DE   E5..         MOV       A,?V0
   \   0000E0   42A0         ORL       0xa0,A
   1361                  break;
   1362              }
   1363            }
   1364          
   1365            rtrn[3] = P0;
   \                     ??MT_UtilGpioWrite_4:
   \   0000E2   E580         MOV       A,0x80
   \   0000E4   C0E0         PUSH      A
   \   0000E6   7403         MOV       A,#0x3
   \   0000E8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EB   D0E0         POP       A
   \   0000ED   F0           MOVX      @DPTR,A
   1366            rtrn[4] = P1;
   \   0000EE   E590         MOV       A,0x90
   \   0000F0   C0E0         PUSH      A
   \   0000F2   7404         MOV       A,#0x4
   \   0000F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F7   D0E0         POP       A
   \   0000F9   F0           MOVX      @DPTR,A
   1367            rtrn[5] = P2;
   \   0000FA   E5A0         MOV       A,0xa0
   \   0000FC   C0E0         PUSH      A
   \   0000FE   7405         MOV       A,#0x5
   \   000100   12....       LCALL     ?XSTACK_DISP0_8
   \   000103   D0E0         POP       A
   \   000105   12....       LCALL     ?Subroutine13 & 0xFFFF
   1368          
   1369          #else
   1370            uint8 rtrn[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
   1371          #endif
   1372          
   1373            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_WRITE,
   1374              9, rtrn);
   \                     ??CrossCallReturnLabel_21:
   \   000108   7B09         MOV       R3,#0x9
   \   00010A   7A16         MOV       R2,#0x16
   \   00010C   7967         MOV       R1,#0x67
   \   00010E   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1375          }
   \   000111   7409         MOV       A,#0x9
   \   000113   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   000116                REQUIRE _A_P0
   \   000116                REQUIRE _A_P1
   \   000116                REQUIRE _A_P2
   \   000116                REQUIRE P0DIR
   \   000116                REQUIRE P1DIR
   \   000116                REQUIRE P2DIR

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   00           DB 0
   1376          
   1377          #if !defined NONWK
   1378          /**************************************************************************************************
   1379           * @fn      MT_UtilDataReq
   1380           *
   1381           * @brief   Process the MAC Data Request command.
   1382           *
   1383           * @param   pBuf - pointer to the received data
   1384           *
   1385           * @return  None
   1386          **************************************************************************************************/
   1387          static void MT_UtilDataReq(uint8 *pBuf)
   1388          {
   1389            uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
   1390            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
   1391                                                                                         1, &rtrn);
   1392          }
   1393          
   1394          /***************************************************************************************************
   1395           * @fn      MT_UtilAddrMgrEntryLookupExt
   1396           *
   1397           * @brief   Proxy the AddrMgrEntryLookupExt() function.
   1398           *
   1399           * @param   pBuf - pointer to the received buffer
   1400           *
   1401           * @return  void
   1402           ***************************************************************************************************/
   1403          static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf)
   1404          {
   1405            uint8 nwkAddr[2];
   1406            AddrMgrEntry_t entry;
   1407            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1408            pBuf += MT_RPC_FRAME_HDR_SZ;
   1409          
   1410            osal_memcpy(entry.extAddr, pBuf, Z_EXTADDR_LEN);
   1411            (void)AddrMgrEntryLookupExt(&entry);
   1412          
   1413            nwkAddr[0] = LO_UINT16(entry.nwkAddr);
   1414            nwkAddr[1] = HI_UINT16(entry.nwkAddr);
   1415            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
   1416                                                 cmdId, sizeof(uint16), nwkAddr);
   1417          }
   1418          
   1419          /***************************************************************************************************
   1420           * @fn      MT_UtilAddrMgrEntryLookupNwk
   1421           *
   1422           * @brief   Proxy the AddrMgrEntryLookupNwk() function.
   1423           *
   1424           * @param   pBuf - pointer to the received buffer
   1425           *
   1426           * @return  void
   1427           ***************************************************************************************************/
   1428          static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
   1429          {
   1430            AddrMgrEntry_t entry;
   1431            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1432            pBuf += MT_RPC_FRAME_HDR_SZ;
   1433          
   1434            entry.nwkAddr = osal_build_uint16( pBuf );
   1435            (void)AddrMgrEntryLookupNwk(&entry);
   1436          
   1437            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
   1438                                                 cmdId, Z_EXTADDR_LEN, entry.extAddr);
   1439          }
   1440          
   1441          #if defined MT_SYS_KEY_MANAGEMENT
   1442          /***************************************************************************************************
   1443           * @fn      MT_UtilAPSME_LinkKeyDataGet
   1444           *
   1445           * @brief   Retrieves APS Link Key data from NV.
   1446           *
   1447           * @param   pBuf - pointer to the received buffer
   1448           *
   1449           * @return  void
   1450           ***************************************************************************************************/
   1451          static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
   1452          {
   1453            uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
   1454            APSME_LinkKeyData_t *pData = NULL;
   1455            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1456            uint16 apsLinkKeyNvId;
   1457            uint32 *apsRxFrmCntr;
   1458            uint32 *apsTxFrmCntr;
   1459          
   1460            pBuf += MT_RPC_FRAME_HDR_SZ;
   1461          
   1462            *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
   1463          
   1464            if (SUCCESS == *rsp)
   1465            {
   1466              pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   1467          
   1468              if (pData != NULL)
   1469              {
   1470                // retrieve key from NV
   1471                if ( osal_nv_read( apsLinkKeyNvId, 0,
   1472                                  sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
   1473          
   1474                {
   1475                  uint8 *ptr = rsp+1;
   1476                  apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
   1477                  apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
   1478          
   1479                  (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
   1480                  ptr += SEC_KEY_LEN;
   1481                  osal_buffer_uint32( ptr, *apsTxFrmCntr );
   1482                  ptr += 4;
   1483                  osal_buffer_uint32( ptr, *apsRxFrmCntr );
   1484                }
   1485          
   1486                // clear copy of key in RAM
   1487                osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
   1488          
   1489                osal_mem_free(pData);
   1490              }
   1491            }
   1492            else
   1493            {
   1494              // set data key and counters 0xFF
   1495              osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
   1496            }
   1497          
   1498            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1499                                                 MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
   1500          
   1501            // clear key data
   1502            osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
   1503          
   1504          }
   1505          
   1506          /***************************************************************************************************
   1507           * @fn      MT_UtilAPSME_LinkKeyNvIdGet
   1508           *
   1509           * @brief   Retrieves APS Link Key NV ID from the entry table.
   1510           *
   1511           * @param   pBuf - pointer to the received buffer
   1512           *
   1513           * @return  void
   1514           ***************************************************************************************************/
   1515          static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
   1516          {
   1517            uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
   1518            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1519            uint16 apsLinkKeyNvId;
   1520          
   1521            pBuf += MT_RPC_FRAME_HDR_SZ;
   1522          
   1523            *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
   1524          
   1525            if (SUCCESS == *rsp)
   1526            {
   1527              rsp[1] = LO_UINT16(apsLinkKeyNvId);
   1528              rsp[2] = HI_UINT16(apsLinkKeyNvId);
   1529            }
   1530            else
   1531            {
   1532              // send failure response with invalid NV ID
   1533              osal_memset(&rsp[1], 0xFF, 2);
   1534            }
   1535          
   1536            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1537                                                 MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
   1538          }
   1539          #endif // MT_SYS_KEY_MANAGEMENT
   1540          
   1541          /***************************************************************************************************
   1542           * @fn      MT_UtilAPSME_RequestKeyCmd
   1543           *
   1544           * @brief   Send RequestKey command message to TC for a specific partner Address.
   1545           *
   1546           * @param   pBuf  - pointer to the received buffer
   1547           *
   1548           * @return  void
   1549           ***************************************************************************************************/
   1550          void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
   1551          {
   1552            uint8 cmdId;
   1553            uint8 partnerAddr[Z_EXTADDR_LEN];
   1554            uint8 retValue;
   1555          
   1556            // parse header
   1557            cmdId = pBuf[MT_RPC_POS_CMD1];
   1558            pBuf += MT_RPC_FRAME_HDR_SZ;
   1559          
   1560            /* PartnerAddress */
   1561            osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
   1562          
   1563            retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
   1564          
   1565            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
   1566          }
   1567          
   1568          /***************************************************************************************************
   1569           * @fn      MT_UtilAssocCount
   1570           *
   1571           * @brief   Proxy the AssocCount() function.
   1572           *
   1573           * @param   pBuf - pointer to the received buffer
   1574           *
   1575           * @return  void
   1576           ***************************************************************************************************/
   1577          static void MT_UtilAssocCount(uint8 *pBuf)
   1578          {
   1579            uint16 cnt;
   1580            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1581            pBuf += MT_RPC_FRAME_HDR_SZ;
   1582          
   1583            cnt = AssocCount(pBuf[0], pBuf[1]);
   1584            pBuf[0] = LO_UINT16(cnt);
   1585            pBuf[1] = HI_UINT16(cnt);
   1586          
   1587            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
   1588          }
   1589          
   1590          /***************************************************************************************************
   1591           * @fn      MT_UtilAssocFindDevice
   1592           *
   1593           * @brief   Get an associated device by index.
   1594           *
   1595           * @param   pBuf - pointer to the received buffer
   1596           *
   1597           * @return  void
   1598           ***************************************************************************************************/
   1599          static void MT_UtilAssocFindDevice(uint8 *pBuf)
   1600          {
   1601            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1602            uint8 buf[sizeof(associated_devices_t)];
   1603          
   1604            packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
   1605            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1606                                                 sizeof(associated_devices_t), buf);
   1607          }
   1608          
   1609          /***************************************************************************************************
   1610           * @fn      MT_UtilAssocGetWithAddress
   1611           *
   1612           * @brief   Get an associated device by address.
   1613           *
   1614           * @param   pBuf - pointer to the received buffer
   1615           *
   1616           * @return  void
   1617           ***************************************************************************************************/
   1618          static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
   1619          {
   1620            extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
   1621            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1622            uint8 buf[sizeof(associated_devices_t)];
   1623          
   1624            pBuf += MT_RPC_FRAME_HDR_SZ;
   1625            packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
   1626                                            BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
   1627          
   1628            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1629                                                 sizeof(associated_devices_t), buf);
   1630          }
   1631          
   1632          /***************************************************************************************************
   1633           * @fn      MT_UtilBindAddEntry
   1634           *
   1635           * @brief   Add Binding Entry into Local Table.
   1636           *
   1637           * @param   pBuf - pointer to the received buffer
   1638           *
   1639           * @return  void
   1640           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1641          static void MT_UtilBindAddEntry(uint8 *pBuf)
   \                     MT_UtilBindAddEntry:
   1642          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV       A,#-0x13
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1643            uint8 srcEp;
   1644            zAddrType_t dstAddr;
   1645            uint8 dstEp;
   1646            uint8 numClusterIds;
   1647            uint16 *clusterIds;
   1648            uint8 buf[sizeof(BindingEntry_t)];
   1649            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V7,A
   1650            pBuf += MT_RPC_FRAME_HDR_SZ;
   1651          
   1652            // Initialize the return buffer
   1653            osal_memset( buf, 0xFF, sizeof(BindingEntry_t) );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C0E         MOV       R4,#0xe
   \   000019   7D00         MOV       R5,#0x0
   \   00001B   79FF         MOV       R1,#-0x1
   \   00001D   7409         MOV       A,#0x9
   \   00001F   12....       LCALL     ?XSTACK_DISP101_8
   \   000022   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1654            buf[2] = 0xFE;    // set the default value of INVALID_NODE_ADDR
   \   000025   740B         MOV       A,#0xb
   \   000027   12....       LCALL     ?XSTACK_DISP0_8
   \   00002A   74FE         MOV       A,#-0x2
   \   00002C   F0           MOVX      @DPTR,A
   1655            buf[3] = 0xFF;    // set the default value of INVALID_NODE_ADDR
   \   00002D   740C         MOV       A,#0xc
   \   00002F   12....       LCALL     ?XSTACK_DISP0_8
   \   000032   74FF         MOV       A,#-0x1
   \   000034   F0           MOVX      @DPTR,A
   1656          
   1657            srcEp = *pBuf++;
   \   000035   8E82         MOV       DPL,R6
   \   000037   8F83         MOV       DPH,R7
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   F5..         MOV       ?V4,A
   1658          
   1659            // Destination Address mode
   1660            dstAddr.addrMode = *pBuf++;
   \   00003F   8E82         MOV       DPL,R6
   \   000041   8F83         MOV       DPH,R7
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F8           MOV       R0,A
   \   000049   7408         MOV       A,#0x8
   \   00004B   12....       LCALL     ?XSTACK_DISP0_8
   \   00004E   E8           MOV       A,R0
   \   00004F   F0           MOVX      @DPTR,A
   \   000050   EE           MOV       A,R6
   \   000051   2405         ADD       A,#0x5
   \   000053   FE           MOV       R6,A
   \   000054   5001         JNC       ??MT_UtilBindAddEntry_0
   \   000056   0F           INC       R7
   1661          
   1662            // Destination Address
   1663            if ( dstAddr.addrMode == Addr64Bit )
   \                     ??MT_UtilBindAddEntry_0:
   \   000057   7403         MOV       A,#0x3
   \   000059   68           XRL       A,R0
   \   00005A   700D         JNZ       ??MT_UtilBindAddEntry_1
   1664            {
   1665              uint8 *ptr; // Use this additional pointer because *pBuf is incremented later for both cases
   1666          
   1667              ptr = pBuf;
   1668              osal_cpyExtAddr( dstAddr.addr.extAddr, ptr );
   \   00005C                ; Setup parameters for call to function sAddrExtCpy
   \   00005C   EE           MOV       A,R6
   \   00005D   FC           MOV       R4,A
   \   00005E   EF           MOV       A,R7
   \   00005F   FD           MOV       R5,A
   \   000060   AA..         MOV       R2,?XSP + 0
   \   000062   AB..         MOV       R3,?XSP + 1
   \   000064   12....       LCALL     `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
   \   000067   8012         SJMP      ??MT_UtilBindAddEntry_2
   1669            }
   1670            else
   1671            {
   1672              dstAddr.addr.shortAddr = osal_build_uint16( pBuf );
   \                     ??MT_UtilBindAddEntry_1:
   \   000069                ; Setup parameters for call to function osal_build_uint16
   \   000069   EE           MOV       A,R6
   \   00006A   FA           MOV       R2,A
   \   00006B   EF           MOV       A,R7
   \   00006C   FB           MOV       R3,A
   \   00006D   12....       LCALL     `??osal_build_uint16::?relay`; Banked call to: osal_build_uint16
   \   000070   85..82       MOV       DPL,?XSP + 0
   \   000073   85..83       MOV       DPH,?XSP + 1
   \   000076   EA           MOV       A,R2
   \   000077   F0           MOVX      @DPTR,A
   \   000078   A3           INC       DPTR
   \   000079   EB           MOV       A,R3
   \   00007A   F0           MOVX      @DPTR,A
   1673            }
   1674            // The short address occupies LSB two bytes
   1675            pBuf += Z_EXTADDR_LEN;
   1676          
   1677            // DstEPInt
   1678            dstEp = *pBuf++;
   \                     ??MT_UtilBindAddEntry_2:
   \   00007B   8E82         MOV       DPL,R6
   \   00007D   8F83         MOV       DPH,R7
   \   00007F   A3           INC       DPTR
   \   000080   A3           INC       DPTR
   \   000081   A3           INC       DPTR
   \   000082   A3           INC       DPTR
   \   000083   A3           INC       DPTR
   \   000084   A3           INC       DPTR
   \   000085   A3           INC       DPTR
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   F5..         MOV       ?V5,A
   1679          
   1680            numClusterIds = *pBuf++;
   \   00008A   8E82         MOV       DPL,R6
   \   00008C   8F83         MOV       DPH,R7
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   A3           INC       DPTR
   \   000097   E0           MOVX      A,@DPTR
   \   000098   F5..         MOV       ?V6,A
   1681          
   1682            if ( numClusterIds > 0 )
   \   00009A   6064         JZ        ??MT_UtilBindAddEntry_3
   1683            {
   1684              // copy list of clusters
   1685              clusterIds = (uint16 *)osal_mem_alloc( numClusterIds * sizeof(uint16) );
   \   00009C   25E0         ADD       A,0xE0 /* A   */
   \   00009E   F5..         MOV       ?V2,A
   \   0000A0   E4           CLR       A
   \   0000A1   33           RLC       A
   \   0000A2   F5..         MOV       ?V3,A
   \   0000A4                ; Setup parameters for call to function osal_mem_alloc
   \   0000A4   AA..         MOV       R2,?V2
   \   0000A6   FB           MOV       R3,A
   \   0000A7   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000AA   8A..         MOV       ?V0,R2
   \   0000AC   8B..         MOV       ?V1,R3
   1686              osal_memcpy( clusterIds, pBuf, numClusterIds * sizeof(uint16));
   \   0000AE                ; Setup parameters for call to function osal_memcpy
   \   0000AE   EE           MOV       A,R6
   \   0000AF   240A         ADD       A,#0xa
   \   0000B1   F5..         MOV       ?V8,A
   \   0000B3   E4           CLR       A
   \   0000B4   3F           ADDC      A,R7
   \   0000B5   F5..         MOV       ?V9,A
   \   0000B7   75..00       MOV       ?V10,#0x0
   \   0000BA   78..         MOV       R0,#?V8
   \   0000BC   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000BF   AC..         MOV       R4,?V2
   \   0000C1   AD..         MOV       R5,?V3
   \   0000C3   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000C6   7403         MOV       A,#0x3
   \   0000C8   12....       LCALL     ?DEALLOC_XSTACK8
   1687          
   1688              if ( clusterIds != NULL )
   \   0000CB   E5..         MOV       A,?V0
   \   0000CD   45..         ORL       A,?V1
   \   0000CF   602F         JZ        ??MT_UtilBindAddEntry_3
   1689              {
   1690                // The response to MT interface has to be pack into buf
   1691                packBindEntry_t( buf, bindAddEntry( srcEp, &dstAddr, dstEp, numClusterIds, clusterIds ));
   \   0000D1                ; Setup parameters for call to function bindAddEntry
   \   0000D1   78..         MOV       R0,#?V0
   \   0000D3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D6   AD..         MOV       R5,?V6
   \   0000D8   AC..         MOV       R4,?V5
   \   0000DA   7402         MOV       A,#0x2
   \   0000DC   12....       LCALL     ?XSTACK_DISP101_8
   \   0000DF   A9..         MOV       R1,?V4
   \   0000E1   12....       LCALL     `??bindAddEntry::?relay`; Banked call to: bindAddEntry
   \   0000E4   7402         MOV       A,#0x2
   \   0000E6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000E9   8A..         MOV       ?V2,R2
   \   0000EB   8B..         MOV       ?V3,R3
   \   0000ED   AC..         MOV       R4,?V2
   \   0000EF   AD..         MOV       R5,?V3
   \   0000F1                ; Setup parameters for call to function packBindEntry_t
   \   0000F1   7409         MOV       A,#0x9
   \   0000F3   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F6   12....       LCALL     `??packBindEntry_t::?relay`; Banked call to: packBindEntry_t
   1692          
   1693                osal_mem_free( clusterIds );
   \   0000F9                ; Setup parameters for call to function osal_mem_free
   \   0000F9   AA..         MOV       R2,?V0
   \   0000FB   AB..         MOV       R3,?V1
   \   0000FD   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   1694              }
   1695            }
   1696          
   1697            MT_BuildAndSendZToolResponse( ( (uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL ),
   1698                                          cmdId, sizeof(BindingEntry_t), buf );
   \                     ??MT_UtilBindAddEntry_3:
   \   000100                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000100   7409         MOV       A,#0x9
   \   000102   12....       LCALL     ?XSTACK_DISP102_8
   \   000105   7B0E         MOV       R3,#0xe
   \   000107   AA..         MOV       R2,?V7
   \   000109   7967         MOV       R1,#0x67
   \   00010B   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1699          }
   \   00010E   7417         MOV       A,#0x17
   \   000110   12....       LCALL     ?DEALLOC_XSTACK8
   \   000113   7F0B         MOV       R7,#0xb
   \   000115   02....       LJMP      ?BANKED_LEAVE_XDATA
   1700          
   1701          /***************************************************************************************************
   1702           * @fn      packDev_t
   1703           *
   1704           * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
   1705           *          the pDev parameter is NULL).
   1706           *
   1707           * @param   pBuf - pointer to the buffer into which to pack the structure.
   1708           * @param   pDev - pointer to the structure.
   1709           *
   1710           * @return  void
   1711           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1712          static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
   \                     packDev_t:
   1713          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   \   000009   8C..         MOV       ?V0,R4
   \   00000B   8D..         MOV       ?V1,R5
   1714            if (NULL == pDev)
   \   00000D   EC           MOV       A,R4
   \   00000E   45..         ORL       A,?V1
   \   000010   700C         JNZ       ??packDev_t_0
   1715            {
   1716              uint16 rtrn = INVALID_NODE_ADDR;
   1717              *pBuf++ = LO_UINT16(rtrn);
   \   000012   8E82         MOV       DPL,R6
   \   000014   8F83         MOV       DPH,R7
   \   000016   74FE         MOV       A,#-0x2
   \   000018   F0           MOVX      @DPTR,A
   1718              *pBuf++ = HI_UINT16(rtrn);
   \   000019   A3           INC       DPTR
   \   00001A   04           INC       A
   \   00001B   02....       LJMP      ??packDev_t_1 & 0xFFFF
   1719            }
   1720            else
   1721            {
   1722              *pBuf++ = LO_UINT16(pDev->shortAddr);
   \                     ??packDev_t_0:
   \   00001E   8C82         MOV       DPL,R4
   \   000020   8D83         MOV       DPH,R5
   \   000022   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000025   12....       LCALL     ?Subroutine17 & 0xFFFF
   1723              *pBuf++ = HI_UINT16(pDev->shortAddr);
   \                     ??CrossCallReturnLabel_26:
   \   000028   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00002B   A3           INC       DPTR
   \   00002C   F0           MOVX      @DPTR,A
   1724              *pBuf++ = LO_UINT16(pDev->addrIdx);
   \   00002D   EC           MOV       A,R4
   \   00002E   2402         ADD       A,#0x2
   \   000030   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000033   A3           INC       DPTR
   \   000034   12....       LCALL     ?Subroutine14 & 0xFFFF
   1725              *pBuf++ = HI_UINT16(pDev->addrIdx);
   \                     ??CrossCallReturnLabel_54:
   \   000037   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00003A   12....       LCALL     ?Subroutine16 & 0xFFFF
   1726              *pBuf++ = pDev->nodeRelation;
   \                     ??CrossCallReturnLabel_24:
   \   00003D   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000040   12....       LCALL     ?Subroutine18 & 0xFFFF
   1727              *pBuf++ = pDev->devStatus;
   \                     ??CrossCallReturnLabel_50:
   \   000043   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000046   12....       LCALL     ?Subroutine17 & 0xFFFF
   1728              *pBuf++ = pDev->assocCnt;
   \                     ??CrossCallReturnLabel_27:
   \   000049   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00004C   12....       LCALL     ?Subroutine18 & 0xFFFF
   1729              *pBuf++ = pDev->age;
   \                     ??CrossCallReturnLabel_51:
   \   00004F   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000052   12....       LCALL     ?Subroutine17 & 0xFFFF
   1730              *pBuf++ = pDev->linkInfo.txCounter;
   \                     ??CrossCallReturnLabel_28:
   \   000055   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000058   12....       LCALL     ?Subroutine18 & 0xFFFF
   1731              *pBuf++ = pDev->linkInfo.txCost;
   \                     ??CrossCallReturnLabel_52:
   \   00005B   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00005E   12....       LCALL     ?Subroutine17 & 0xFFFF
   1732              *pBuf++ = pDev->linkInfo.rxLqi;
   \                     ??CrossCallReturnLabel_29:
   \   000061   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000064   A3           INC       DPTR
   \   000065   F0           MOVX      @DPTR,A
   1733              *pBuf++ = pDev->linkInfo.inKeySeqNum;
   \   000066   EC           MOV       A,R4
   \   000067   240B         ADD       A,#0xb
   \   000069   F582         MOV       DPL,A
   \   00006B   E4           CLR       A
   \   00006C   35..         ADDC      A,?V1
   \   00006E   F583         MOV       DPH,A
   \   000070   E0           MOVX      A,@DPTR
   \   000071   C0E0         PUSH      A
   \   000073   EE           MOV       A,R6
   \   000074   240B         ADD       A,#0xb
   \   000076   F582         MOV       DPL,A
   \   000078   E4           CLR       A
   \   000079   3F           ADDC      A,R7
   \   00007A   F583         MOV       DPH,A
   \   00007C   D0E0         POP       A
   \   00007E   F0           MOVX      @DPTR,A
   \   00007F   EE           MOV       A,R6
   \   000080   240C         ADD       A,#0xc
   \   000082   FE           MOV       R6,A
   \   000083   5001         JNC       ??packDev_t_2
   \   000085   0F           INC       R7
   1734              osal_buffer_uint32( pBuf, pDev->linkInfo.inFrmCntr );
   \                     ??packDev_t_2:
   \   000086                ; Setup parameters for call to function osal_buffer_uint32
   \   000086   EC           MOV       A,R4
   \   000087   240C         ADD       A,#0xc
   \   000089   F582         MOV       DPL,A
   \   00008B   E4           CLR       A
   \   00008C   35..         ADDC      A,?V1
   \   00008E   F583         MOV       DPH,A
   \   000090   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000093   EE           MOV       A,R6
   \   000094   FA           MOV       R2,A
   \   000095   EF           MOV       A,R7
   \   000096   FB           MOV       R3,A
   \   000097   12....       LCALL     `??osal_buffer_uint32::?relay`; Banked call to: osal_buffer_uint32
   \   00009A   7404         MOV       A,#0x4
   \   00009C   12....       LCALL     ?DEALLOC_XSTACK8
   1735              *pBuf += 4;
   \   00009F   8E82         MOV       DPL,R6
   \   0000A1   8F83         MOV       DPH,R7
   \   0000A3   E0           MOVX      A,@DPTR
   \   0000A4   2404         ADD       A,#0x4
   \   0000A6   F0           MOVX      @DPTR,A
   1736              *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
   \   0000A7   E5..         MOV       A,?V0
   \   0000A9   2410         ADD       A,#0x10
   \   0000AB   12....       LCALL     ?Subroutine6 & 0xFFFF
   1737              *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
   1738            }
   \                     ??CrossCallReturnLabel_9:
   \   0000AE   12....       LCALL     ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000B1   A3           INC       DPTR
   \   0000B2   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0000B5   A3           INC       DPTR
   \                     ??packDev_t_1:
   \   0000B6   F0           MOVX      @DPTR,A
   \   0000B7   EE           MOV       A,R6
   \   0000B8   2402         ADD       A,#0x2
   1739          }
   \   0000BA   02....       LJMP      ??Subroutine27_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine28_0
   \   000001                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   A3           INC       DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine29_0
   \   000001                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A3           INC       DPTR
   \   000001   E0           MOVX      A,@DPTR
   \   000002   8E82         MOV       DPL,R6
   \   000004   8F83         MOV       DPH,R7
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   F8           MOV       R0,A
   \   000001   E4           CLR       A
   \   000002   35..         ADDC      A,?V1
   \   000004   F9           MOV       R1,A
   \   000005   8882         MOV       DPL,R0
   \   000007   8983         MOV       DPH,R1
   \   000009   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8C82         MOV       DPL,R4
   \   000003   8D83         MOV       DPH,R5
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET
   1740          
   1741          /***************************************************************************************************
   1742           * @fn      packBindEntry_t
   1743           *
   1744           * @brief   Pack a BindingEntry_t structure into a byte buffer (pack INVALID_NODE_ADDR
   1745           *          as dstIdx if the pBind parameter is NULL).
   1746           *
   1747           * @param   pBuf - pointer to the buffer into which to pack the structure.
   1748           * @param   pBind - pointer to the structure.
   1749           *
   1750           * @return  void
   1751           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1752          static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind)
   \                     packBindEntry_t:
   1753          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   1754            if ( NULL == pBind )
   \   000005   EC           MOV       A,R4
   \   000006   4D           ORL       A,R5
   \   000007   7021         JNZ       ??packBindEntry_t_0
   1755            {
   1756              uint16 rtrn = INVALID_NODE_ADDR;
   1757              *pBuf++ = 0xFF;
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   74FF         MOV       A,#-0x1
   \   00000F   F0           MOVX      @DPTR,A
   1758              *pBuf++ = 0xFF;
   \   000010   A3           INC       DPTR
   \   000011   F0           MOVX      @DPTR,A
   1759              *pBuf++ = LO_UINT16(rtrn);
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   14           DEC       A
   \   000019   12....       LCALL     ?Subroutine24 & 0xFFFF
   1760              *pBuf++ = HI_UINT16(rtrn);
   1761              *pBuf++ = 0xFF;
   1762              *pBuf++ = 0xFF;
   1763          
   1764            }
   \                     ??CrossCallReturnLabel_43:
   \   00001C   04           INC       A
   \   00001D   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000020   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000023   A3           INC       DPTR
   \   000024   F0           MOVX      @DPTR,A
   \   000025   EA           MOV       A,R2
   \   000026   2406         ADD       A,#0x6
   \   000028   806D         SJMP      ??packBindEntry_t_1
   1765            else
   1766            {
   1767              *pBuf++ = pBind->srcEP;
   \                     ??packBindEntry_t_0:
   \   00002A   8C82         MOV       DPL,R4
   \   00002C   8D83         MOV       DPH,R5
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   8A82         MOV       DPL,R2
   \   000031   8B83         MOV       DPH,R3
   \   000033   12....       LCALL     ??Subroutine28_0 & 0xFFFF
   1768              *pBuf++ = pBind->dstGroupMode;
   \                     ??CrossCallReturnLabel_53:
   \   000036   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000039   F0           MOVX      @DPTR,A
   1769              *pBuf++ = LO_UINT16( pBind->dstIdx );
   \   00003A   EC           MOV       A,R4
   \   00003B   2402         ADD       A,#0x2
   \   00003D   F8           MOV       R0,A
   \   00003E   E4           CLR       A
   \   00003F   3D           ADDC      A,R5
   \   000040   F9           MOV       R1,A
   \   000041   8882         MOV       DPL,R0
   \   000043   8983         MOV       DPH,R1
   \   000045   12....       LCALL     ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000048   12....       LCALL     ?Subroutine14 & 0xFFFF
   1770              *pBuf++ = HI_UINT16( pBind->dstIdx );
   \                     ??CrossCallReturnLabel_55:
   \   00004B   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00004E   A3           INC       DPTR
   \   00004F   A3           INC       DPTR
   \   000050   12....       LCALL     ?Subroutine16 & 0xFFFF
   1771              *pBuf++ = pBind->dstEP;
   \                     ??CrossCallReturnLabel_25:
   \   000053   A3           INC       DPTR
   \   000054   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000057   F0           MOVX      @DPTR,A
   1772              *pBuf++ = pBind->numClusterIds;
   \   000058   EC           MOV       A,R4
   \   000059   2405         ADD       A,#0x5
   \   00005B   F8           MOV       R0,A
   \   00005C   E4           CLR       A
   \   00005D   3D           ADDC      A,R5
   \   00005E   F9           MOV       R1,A
   \   00005F   E8           MOV       A,R0
   \   000060   FE           MOV       R6,A
   \   000061   E9           MOV       A,R1
   \   000062   FF           MOV       R7,A
   \   000063   8E82         MOV       DPL,R6
   \   000065   8F83         MOV       DPH,R7
   \   000067   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   00006A   A3           INC       DPTR
   \   00006B   F0           MOVX      @DPTR,A
   1773          
   1774              osal_memcpy( pBuf, pBind->clusterIdList, pBind->numClusterIds * sizeof(uint16));
   \   00006C                ; Setup parameters for call to function osal_memcpy
   \   00006C   EC           MOV       A,R4
   \   00006D   2406         ADD       A,#0x6
   \   00006F   F5..         MOV       ?V0,A
   \   000071   E4           CLR       A
   \   000072   3D           ADDC      A,R5
   \   000073   F5..         MOV       ?V1,A
   \   000075   75..00       MOV       ?V2,#0x0
   \   000078   78..         MOV       R0,#?V0
   \   00007A   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00007D   8E82         MOV       DPL,R6
   \   00007F   8F83         MOV       DPH,R7
   \   000081   E0           MOVX      A,@DPTR
   \   000082   25E0         ADD       A,0xE0 /* A   */
   \   000084   FC           MOV       R4,A
   \   000085   E4           CLR       A
   \   000086   33           RLC       A
   \   000087   FD           MOV       R5,A
   \   000088   EA           MOV       A,R2
   \   000089   2406         ADD       A,#0x6
   \   00008B   FA           MOV       R2,A
   \   00008C   5001         JNC       ??packBindEntry_t_2
   \   00008E   0B           INC       R3
   \                     ??packBindEntry_t_2:
   \   00008F   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000092   7403         MOV       A,#0x3
   \   000094   12....       LCALL     ?DEALLOC_XSTACK8
   1775            }
   1776          }
   \                     ??packBindEntry_t_1:
   \   000097   7F03         MOV       R7,#0x3
   \   000099   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   A3           INC       DPTR
   \   000001                REQUIRE ??Subroutine30_0
   \   000001                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FE           MOV       R6,A
   \   000008                ; Setup parameters for call to function osal_build_uint16
   \   000008                ; Setup parameters for call to function osal_build_uint16
   \   000008                REQUIRE ??Subroutine26_0
   \   000008                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   EA           MOV       A,R2
   \   000001   2403         ADD       A,#0x3
   \   000003   FA           MOV       R2,A
   \   000004   E4           CLR       A
   \   000005   35..         ADDC      A,?V1
   \   000007   FB           MOV       R3,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000003   A982         MOV       R1,DPL
   \   000005   AA83         MOV       R2,DPH
   \   000007   89..         MOV       ?V0,R1
   \   000009   8A..         MOV       ?V1,R2
   \   00000B   8F..         MOV       ?V2,R7
   \   00000D   78..         MOV       R0,#?V0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FE           MOV       R6,A
   \   000008                ; Setup parameters for call to function AssocFindDevice
   \   000008                ; Setup parameters for call to function osal_memcpy
   \   000008                ; Setup parameters for call to function osal_memcpy
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   22           RET

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilCommandProcessing::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilCommandProcessing

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGetDeviceInfo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGetDeviceInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGetNvInfo::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGetNvInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGpioSetDirection::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGpioSetDirection

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilGpioWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilGpioWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UtilBindAddEntry::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UtilBindAddEntry

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??packDev_t::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    packDev_t

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??packBindEntry_t::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    packBindEntry_t
   1777          
   1778          #if defined ZCL_KEY_ESTABLISH
   1779          /***************************************************************************************************
   1780           * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
   1781           *
   1782           * @brief   Proxy the zclKE_StartDirect() function.
   1783           *
   1784           * @param   pBuf - pointer to the received buffer
   1785           *
   1786           * @return  void
   1787           ***************************************************************************************************/
   1788          static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
   1789          {
   1790            afAddrType_t partnerAddr;
   1791            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1792            pBuf += MT_RPC_FRAME_HDR_SZ;
   1793          
   1794            partnerAddr.panId = 0;  // Not an inter-pan message.
   1795            partnerAddr.endPoint = pBuf[2];
   1796            partnerAddr.addrMode = afAddr16Bit;
   1797            partnerAddr.addr.shortAddr = osal_build_uint16( &pBuf[4] );
   1798          
   1799            zcl_key_establish_task_id = pBuf[0];
   1800          
   1801            *pBuf = zclKE_StartDirect(MT_TaskID, &partnerAddr, pBuf[1], pBuf[3]);
   1802          
   1803            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
   1804          }
   1805          
   1806          /***************************************************************************************************
   1807           * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
   1808           *
   1809           * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
   1810           *
   1811           * @param   pBuf - pointer to the received buffer
   1812           *
   1813           * @return  void
   1814           ***************************************************************************************************/
   1815          static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
   1816          {
   1817          #if defined ZCL_KEY_ESTABLISH
   1818            uint8 *output;
   1819            uint8 signLen;
   1820            uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
   1821            pBuf += MT_RPC_FRAME_HDR_SZ;
   1822          
   1823            signLen = zclKE_ECDSASignGetLen(ZCL_KE_SUITE_1);
   1824          
   1825            output = osal_mem_alloc(signLen+1);
   1826          
   1827            if (NULL == output)
   1828            {
   1829              *pBuf = FAILURE;
   1830              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
   1831            }
   1832            else
   1833            {
   1834              *output = zclKE_ECDSASign(ZCL_KE_SUITE_1, pBuf+1, *pBuf, output+1);
   1835              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
   1836                                                   signLen+1, output);
   1837              osal_mem_free(output);
   1838            }
   1839          #endif
   1840          }
   1841          
   1842          /***************************************************************************************************
   1843           * @fn      MT_UtilKeyEstablishInd
   1844           *
   1845           * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
   1846           *
   1847           * @param   pInd - Pointer to a zclKE_StatusInd_t structure.
   1848           *
   1849           * @return  None
   1850           ***************************************************************************************************/
   1851          void MT_UtilKeyEstablishInd(zclKE_StatusInd_t *pInd)
   1852          {
   1853            uint8 msg[6];
   1854          
   1855            msg[0] = zcl_key_establish_task_id;
   1856            msg[1] = pInd->hdr.event;
   1857            msg[2] = pInd->hdr.status;
   1858            msg[3] = pInd->waitTime;
   1859            msg[4] = LO_UINT16(pInd->suites);
   1860            msg[5] = HI_UINT16(pInd->suites);
   1861          
   1862            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
   1863                                                 MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
   1864          }
   1865          #endif
   1866          
   1867          /***************************************************************************************************
   1868           * @fn      MT_UtilSync
   1869           *
   1870           * @brief   Process the MT_UTIL_SYNC command
   1871           *
   1872           * @param   None
   1873           *
   1874           * @return  None
   1875           ***************************************************************************************************/
   1876          static void MT_UtilSync(void)
   1877          {
   1878           MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
   1879          }
   1880          #endif /* !defined NONWK */
   1881          #endif /* MT_UTIL_FUNC */
   1882          /**************************************************************************************************
   1883           **************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    123   MT_UtilBindAddEntry
        0     42   -> MT_BuildAndSendZToolResponse
        0     44   -> bindAddEntry
        0     42   -> osal_build_uint16
        0     42   -> osal_mem_alloc
        0     42   -> osal_mem_free
        0     45   -> osal_memcpy
        0     42   -> osal_memset
        0     42   -> packBindEntry_t
        0     42   -> sAddrExtCpy
      1     82   MT_UtilCommandProcessing
        0     78   -> AddrMgrEntryLookupExt
        0     78   -> AddrMgrEntryLookupNwk
        0     78   -> AddrMgrExtAddrValid
        0     78   -> AssocCount
        0     78   -> AssocFindDevice
        0     78   -> AssocGetWithAddress
        0     78   -> MT_BuildAndSendZToolResponse
        0     78   -> MT_UtilBindAddEntry
        0     78   -> MT_UtilGetDeviceInfo
        0     78   -> MT_UtilGetNvInfo
        0     78   -> MT_UtilGpioSetDirection
        0     78   -> MT_UtilGpioWrite
        0     78   -> NwkPollReq
        0     78   -> ZDSecMgrRequestAppKey
        0     78   -> osal_GetSystemClock
        0     82   -> osal_buffer_uint32
        0     78   -> osal_build_uint16
        0     78   -> osal_build_uint32
        0     81   -> osal_memcpy
        0     78   -> osal_nv_item_len
        0     82   -> osal_nv_write
        0     78   -> packDev_t
      1     99   MT_UtilGetDeviceInfo
        0     17   -> AssocMakeList
        0     17   -> MT_BuildAndSendZToolResponse
        0     17   -> NLME_GetShortAddr
        0     17   -> osal_mem_alloc
        0     17   -> osal_mem_free
        0     21   -> osal_nv_read
      1    104   MT_UtilGetNvInfo
        0     22   -> MT_BuildAndSendZToolResponse
        0     22   -> osal_mem_alloc
        0     22   -> osal_mem_free
        0     22   -> osal_memset
        0     26   -> osal_nv_read
      1     94   MT_UtilGpioSetDirection
        0     16   -> MT_BuildAndSendZToolResponse
      1     97   MT_UtilGpioWrite
        0     19   -> MT_BuildAndSendZToolResponse
      1     56   packBindEntry_t
        0     14   -> osal_memcpy
      1     92   packDev_t
        0     14   -> osal_buffer_uint32


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>
       6  ?<Constant {0, 0, 0, 0, 0, 0}>
       9  ??Subroutine26_0
       5  ??Subroutine27_0
       6  ??Subroutine28_0
       6  ??Subroutine29_0
       7  ??Subroutine30_0
       8  ?Subroutine0
       3  ?Subroutine1
       1  ?Subroutine10
       4  ?Subroutine11
      17  ?Subroutine12
       6  ?Subroutine13
       1  ?Subroutine14
       5  ?Subroutine15
       9  ?Subroutine16
       7  ?Subroutine17
       1  ?Subroutine18
      12  ?Subroutine19
      26  ?Subroutine2
      14  ?Subroutine20
      16  ?Subroutine21
       4  ?Subroutine22
       6  ?Subroutine23
       9  ?Subroutine24
      10  ?Subroutine25
      16  ?Subroutine3
       8  ?Subroutine4
       4  ?Subroutine5
      13  ?Subroutine6
       8  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
     280  MT_UtilBindAddEntry
       6  MT_UtilBindAddEntry::?relay
    1254  MT_UtilCommandProcessing
       6  MT_UtilCommandProcessing::?relay
     328  MT_UtilGetDeviceInfo
       6  MT_UtilGetDeviceInfo::?relay
     476  MT_UtilGetNvInfo
       6  MT_UtilGetNvInfo::?relay
     239  MT_UtilGpioSetDirection
       6  MT_UtilGpioSetDirection::?relay
     278  MT_UtilGpioWrite
       6  MT_UtilGpioWrite::?relay
       1  P0DIR
       1  P1DIR
       1  P2DIR
       1  _A_P0
       1  _A_P1
       1  _A_P2
       4  __Constant_3e8
     156  packBindEntry_t
       6  packBindEntry_t::?relay
     189  packDev_t
       6  packDev_t::?relay

 
 3 461 bytes in segment BANKED_CODE
    48 bytes in segment BANK_RELAYS
     6 bytes in segment SFR_AN
    19 bytes in segment XDATA_ROM_C
 
    48 bytes of CODE     memory
    15 bytes of CONST    memory (+ 4 bytes shared)
     0 bytes of DATA     memory (+ 6 bytes shared)
 3 461 bytes of HUGECODE memory

Errors: none
Warnings: none
